% \iffalse
%<*internal>
\begingroup
\input l3docstrip.tex

\def\doOption#1>#2\endLine{%
  \maybeMsg{<#1 . >}%
  \Evaluate{#1}%
  \def\do##1##2##3{%
    \if1\Expr{##2}%
      \def\inLine{#2}%
      \replaceModuleInLine
      \StreamPut##1{\inLine}%
    \fi
  }%
  \activefiles
}

\keepsilent
\usedir{tex/latex/fontspec}
\let\MetaPrefix\relax
\preamble

  _________________________________________
  The fontspec package for XeLaTeX/LuaLaTeX
  (C) 2004--2014    Will Robertson and Khaled Hosny

  License information appended.


\endpreamble
\postamble

Copyright 2004--2014 Will Robertson <wspr81@gmail.com>
Copyright 2009--2013   Khaled Hosny <khaledhosny@eglug.org>

Distributable under the LaTeX Project Public License,
version 1.3c or higher (your choice). The latest version of
this license is at: http://www.latex-project.org/lppl.txt

This work is "maintained" by Will Robertson.

This work consists of this file fontspec.dtx
          and the derived files fontspec.sty,
                                fontspec.cfg,
                                fontspec-xetex.sty,
                                fontspec-luatex.sty,
                                fontspec-patches.sty,
                                fontspec-example.tex,
                            and fontspec.pdf.

\endpostamble
\askforoverwritefalse

\def\MetaPrefix{-- }
\generate{\file{fontspec.lua}          {\from{fontspec.dtx}{lua}}}

\let\MetaPrefix\DoubleperCent

\ifx\FontspecDebug\undefined

\generate{\file{fontspec.sty}          {\from{fontspec.dtx}{fontspec}}}
\generate{\file{fontspec-xetex.sty}    {\from{fontspec.dtx}{fontspec,xetexx}}}
\generate{\file{fontspec-luatex.sty}   {\from{fontspec.dtx}{fontspec,luatex}}}
\generate{\file{fontspec-patches.sty}  {\from{fontspec.dtx}{patches}}}

\else

\generate{\file{fontspec.sty}          {\from{fontspec.dtx}{fontspec,debug}}}
\generate{\file{fontspec-xetex.sty}    {\from{fontspec.dtx}{fontspec,xetexx,debug}}}
\generate{\file{fontspec-luatex.sty}   {\from{fontspec.dtx}{fontspec,luatex,debug}}}
\generate{\file{fontspec-patches.sty}  {\from{fontspec.dtx}{patches,debug}}}

\fi

\nopreamble\nopostamble
\generate{\file{fontspec.cfg}          {\from{fontspec.dtx}{cfg}}}
\generate{\file{fontspec-example.tex}  {\from{fontspec.dtx}{example}}}

\def\tmpa{plain}
\ifx\tmpa\fmtname\endgroup\expandafter\bye\fi

\generate{\file{fontspec-style.sty}    {\from{fontspec.dtx}{doc-style}}}
\endgroup
%</internal>
%
%<*driver>
\ProvidesFile{fontspec.dtx}
%</driver>
%<fontspec&!xetexx&!luatex>\ProvidesPackage{fontspec}
%<fontspec&xetexx>\ProvidesPackage{fontspec-xetex}
%<fontspec&luatex>\ProvidesPackage{fontspec-luatex}
%<patches>\ProvidesPackage{fontspec-patches}
%<*fontspec|patches>
  [2014/08/23 v2.4b Font selection for XeLaTeX and LuaLaTeX]
%</fontspec|patches>
%
%<*driver>
\documentclass[a4paper]{ltxdoc}
\usepackage{fontspec-style}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
%\OnlyDescription
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
%
% \fi
%
% \GetFileInfo{fontspec.dtx}
% \makeatletter                         ^^A% To document @-cmds
% \errorcontextlines=999                ^^A% Show up all my mistakes
%
% \title{The \textsf{fontspec} package\\Font selection for \XeLaTeX\ and \LuaLaTeX}
% \author{
%    \textsc{Will Robertson} and \textsc{Khaled Hosny}\\
%    \texttt{will.robertson@latex-project.org}
% }
% \date{\filedate \qquad \fileversion}
%
% \maketitle
% \tableofcontents
%
% \section{History}
%
% This package began life as a \LaTeX\ interface to select system-installed
% \MacOSX\ fonts in \name{Jonathan Kew}'s \XeTeX, the first widely-used
% Unicode extension to \TeX. Over time, \XeTeX\ was extended to support OpenType
% fonts and then was ported into a cross-platform program to run also on Windows
% and Linux.
%
% More recently, \LuaTeX\ is fast becoming the \TeX\ engine of the day; it
% supports Unicode encodings and OpenType fonts and opens up the internals of
% \TeX\ via the Lua programming language. Hans Hagen's Con\TeX t Mk.\,IV is a
% re-write of his powerful typesetting system, taking full advantage of
% \LuaTeX's features including font support; a kernel of his work in this area
% has been extracted to be useful for other \TeX\ macro systems as well, and
% this has enabled \pkg{fontspec} to be adapted for \LaTeX\ when run with the
% \LuaTeX\ engine.
%
% \section{Introduction}
%
% The \pkg{fontspec} package allows users of either \XeTeX\ or \LuaTeX\ to
% load OpenType fonts in a \LaTeX\ document. No font installation is necessary,
% and font features can be selected and used as desired throughout the document.
%
% Without \pkg{fontspec}, it is necessary to write cumbersome font definition
% files for \LaTeX, since \LaTeX's font selection scheme (known as the
% `\textsc{nfss}') has a lot going on behind the scenes to allow easy
% commands like \cmd\emph\ or \cmd\bfseries. With an uncountable number of
% fonts now available for use, however, it becomes less desirable to have to
% write these font definition (|.fd|) files for every font one wishes to use.
%
% Because \pkg{fontspec} is designed to work in a variety of modes, this
% user documentation is split into separate sections that are designed to be
% relatively independent. Nonetheless, the basic functionality all behaves in
% the same way, so previous users of \pkg{fontspec} under \XeTeX\ should have
% little or no difficulty switching over to \LuaTeX.
%
% This manual can get rather in-depth, as there are a lot of details
% to cover. See the example documents \path{fontspec-xetex.tex} and
% \path{fontspec-luatex.tex} for a complete minimal example with each engine.
%
% \subsection{About this manual}
%
% This document is typeset with pdf\LaTeX\ using pre-compiled examples
% that have been generated by either \XeTeX\ or \LuaTeX. You may regenerate
% the examples by removing the \verb|doc-files/| subdirectory and typesetting the
% manual with the following invocation:
% \begin{Verbatim}
%   pdflatex -shell-escape fontspec.dtx
% \end{Verbatim}
% Note that many of the examples use fonts that are not included in \TeX~Live
% or MiKTeX, and some of them are non-free fonts that must be purchased.
%
% I'd like to reduce the number of non-free fonts used in this
% manual. If you know any freely available fonts that could be used
% as alternative to any of the fonts in this document, please suggest them
% to me.
% Finally, if any aspect of the documentation is unclear or you would
% like to suggest more examples that could be made, get in touch.
% (Contributions especially welcome.)
%
% \subsection{Acknowledgements}
%
% This package could not have been possible without the early and continued support
% the author of \XeTeX, Jonathan Kew. When I started this package, he steered
% me many times in the right direction.
%
% I've had great
% feedback over the years on feature requests, documentation queries, bug reports, font suggestions, and so on from lots of people all around the world.
% Many thanks to you all.
%
% Thanks to David Perry and Markus B\"ohning for numerous documentation
% improvements and David Perry again for contributing the text for one of the
% sections of this manual.
%
% Special thanks to Khaled Hosny, who had been the driving force behind the support for \LuaLaTeX, ultimately leading to version 2.0 of the package.
%
% \section{Package loading and options}
%
% For basic use, no package options are required:
% \begin{Verbatim}
%   \usepackage{fontspec}
% \end{Verbatim}
% Package options will be introduced below; some preliminary details are discussed first:
%
% \paragraph{\pkg{xunicode}}
% Ross Moore's \pkg{xunicode} package is now automatically loaded for
% users of both \XeLaTeX\ and \LuaLaTeX.
% This package provides backwards compatibility with \LaTeX's methods for accessing extra
% characters and accents (for example, |\%|, |\$|, |\textbullet|, |\"u|, and
% so on), plus many more Unicode characters.
%
% \paragraph{\XeTeX\ users only}
% The \pkg{xltxtra} package adds some minor extra features to \XeLaTeX, including, via the \pkg{metalogo} package, the
% \cmd\XeTeX\ macro to typeset the \XeTeX\ logo. While this package was
% previously recommended, it serves a much smaller r\^ole nowadays and generally
% will not be required.
% Please consult its documentation to assess whether its features are warranted before loading it.
%
% \paragraph{\LuaTeX\ users only}
% In order to load fonts by their name rather than by their filename (\eg,
% `Latin Modern Roman' instead of `ec-lmr10'), you may need to run the script
% \texttt{luaotfload-tool}, which is distributed with the \pkg{luaotfload}
% package. Note that if you do not execute this script beforehand, the first
% time you attempt to typeset the process will pause for (up to) several
% minutes. (But only the first time.)
% Please see the \pkg{luaotfload} documentation for more information.
%
% \paragraph{\pkg{babel}}
% \emph{The \pkg{babel} package is not really supported!} Especially Vietnamese,
% Greek, and Hebrew at least might not work correctly, as far as I can tell.
% There's a better chance with Cyrillic and Latin-based languages,
% however---\pkg{fontspec} ensures at least that fonts should load correctly. 
% The \pkg{polyglossia} package is recommended instead as a modern replacement 
% for \pkg{babel}.
%
%
%
% \subsection{Maths fonts adjustments}
% By default, \pkg{fontspec} adjusts \LaTeX's
% default maths setup in order to maintain the correct Computer Modern symbols
% when the roman font changes. However, it will attempt to avoid doing this if
% another maths font package is loaded (such as \pkg{mathpazo} or the
% \pkg{unicode-math} package).
%
% If you find that \pkg{fontspec} is incorrectly changing the maths font when it should be
% leaving well enough alone, apply the |[no-math]| package option to manually
% suppress its maths font.
%
% \subsection{Configuration}
% \label{sec:config}
%
% If you wish to customise any part of the
% \pkg{fontspec} interface, this should be done by creating your own
% \texttt{fontspec.cfg} file,
% which will be automatically loaded if it is found by \XeTeX\ or \LuaTeX.
% A |fontspec.cfg| file is distributed with \pkg{fontspec} with a small number of defaults set up within it.
%
% To customise \pkg{fontspec} to your liking, use the standard |.cfg| file as a starting point or write your own from scratch, then either place it in the same folder as the main document for isolated cases, or in a location
% that \XeTeX\ or \LuaTeX\ searches by default; \eg\ in Mac\TeX: \path{~/Library/texmf/tex/latex/}.
%
% The package option |[no-config]| will suppress the loading of the |fontspec.cfg| file under all circumstances.
%
% \subsection{Warnings}
% \label{sec:quiet-warnings}
%
% This package can give many warnings that can be harmless if you know what
% you're doing. Use the |[quiet]| package option to write these warnings to the
% transcript (\texttt{.log}) file instead.
%
% Use the |[silent]| package option to completely suppress these warnings if you
% don't even want the |.log| file cluttered up.
%
%
%
%
%
% \part{General font selection}
%
% This section concerns the variety of commands that can be used to select
% fonts.
%
% \cmdbox{%
%   \CMD{\string\fontspec}\marg{font name}\oarg{font features}\\
%   \CMD{\string\setmainfont}\marg{font name}\oarg{font features}\\
%   \CMD{\string\setsansfont}\marg{font name}\oarg{font features}\\
%   \CMD{\string\setmonofont}\marg{font name}\oarg{font features}\\
%   \CMD{\string\newfontfamily}\meta{cmd}\marg{font name}\oarg{font features}
% }
%
% These are the main font-selecting commands of this package.
% The \cs{fontspec} command selects a font for one-time use; all
% others should be used to define the standard fonts used in a document, as shown in \exref{fontload}.
% Here, the scales of the fonts have been chosen to equalise their
% lowercase letter heights. The \feat{Scale} font feature will be discussed
% further in \vref{sec:font-ind-features}, including methods for automatic
% scaling.
%
% \begin{Lexample}{fontload}{Loading the default, sans serif, and monospaced fonts.}
%   \setmainfont{TeX Gyre Bonum}
%   \setsansfont{Latin Modern Sans}[Scale=MatchLowercase]
%   \setmonofont{Inconsolata}[Scale=MatchLowercase]
%
%   \rmfamily Pack my box with five dozen liquor jugs\par
%   \sffamily Pack my box with five dozen liquor jugs\par
%   \ttfamily Pack my box with five dozen liquor jugs
% \end{Lexample}
%
% The font features argument accepts comma separated
% \meta{font feature}=\meta{option} lists; these are described in later:
% \begin{itemize}
% \item For general font features, see \vref{sec:font-ind-features}
% \item For OpenType fonts, see Part~\vref{sec:opentype-features}
% \item For \XeTeX-only general font features, see Part~\vref{sec:xetex-features}
% \item For \LuaTeX-only general font features, see Part~\vref{sec:luatex-features}
% \item For features for \AAT\ fonts in \XeTeX, see \vref{sec:aat-features}
% \end{itemize}
%
% \section{Font selection}
%
% In both \LuaTeX\ and \XeTeX, fonts can be selected either by `font name' or
% by `file name'.
%
% \subsection{By font name}
%
% Fonts known to \LuaTeX\ or \XeTeX\ may be loaded by their standard names as 
% you'd speak them out loud, such as \emph{Times New Roman} or 
% \emph{Adobe Garamond}.
% `Known to' in this case generally means `exists in a standard fonts location'
% such as |~/Library/Fonts| on \MacOSX, or |C:\Windows\Fonts| on Windows.
%
% The simplest example might be something like
% \begin{Verbatim}
%   \setmainfont{Cambria}[ ... ]
% \end{Verbatim}
% in which the bold and italic fonts will be found automatically
% (if they exist) and are immediately accessible with the usual
% \cs{textit} and \cs{textbf} commands.
%
% TODO: add explanation for how to find out what the `font name' is.
%
%
% \subsection{By file name}
% \label{sec:by-file-name}
%
% \XeTeX\ and \LuaTeX\ also allow fonts to be loaded by file name instead of font name.
% When you have a very large collection of fonts, you will sometimes not
% wish to have them all installed in your system's font directories.
% In this case, it is more convenient to load them from a different location on your disk.
% This technique is also necessary in \XeTeX\ when loading OpenType fonts that are present within your \TeX\ distribution, such as \path{/usr/local/texlive/2013/texmf-dist/fonts/opentype/public}.
% Fonts in such locations are visible to \XeTeX\ but cannot be loaded by font name, only file name; \LuaTeX\ does not have this restriction.
%
% When selecting fonts by file name, any font that can be found in the default
% search paths may be used directly (including in the current directory)
% without having to explicitly define the location of the font file on disk.
%
% Fonts selected by filename must include bold and italic variants explicitly.
% \begin{Verbatim}
%   \setmainfont{texgyrepagella-regular.otf}[
%        BoldFont       = texgyrepagella-bold.otf ,
%        ItalicFont     = texgyrepagella-italic.otf ,
%        BoldItalicFont = texgyrepagella-bolditalic.otf ]
% \end{Verbatim}
% \pkg{fontspec} knows that the font is to be selected by file name by the
% presence of the `|.otf|' extension.
% An alternative is to specify the extension separately, as shown following:
% \begin{Verbatim}
%   \setmainfont{texgyrepagella-regular}[
%        Extension      = .otf ,
%        BoldFont       = texgyrepagella-bold ,
%        ... ]
% \end{Verbatim}
% If desired, an abbreviation can be applied to the font names based on the
% mandatory `font name' argument:
% \begin{Verbatim}
%   \setmainfont{texgyrepagella}[
%        Extension      = .otf ,
%        UprightFont    = *-regular ,
%        BoldFont       = *-bold ,
%        ... ]
% \end{Verbatim}
% In this case `texgyrepagella' is no longer the name of an actual font,
% but is used to construct the font names for each shape;
% the |*| is replaced by `texgyrepagella'.
% Note in this case that |UprightFont| is required for constructing the font
% name of the normal font to use.
%
% To load a font that is not in one of the default search paths, its location
% in the filesystem must be specified with the |Path| feature:
% \begin{Verbatim}
%   \setmainfont{texgyrepagella}[
%        Path           = /Users/will/Fonts/ ,
%        UprightFont    = *-regular ,
%        BoldFont       = *-bold ,
%        ... ]
% \end{Verbatim}
% Note that \XeTeX\ and \LuaTeX\ are able to load the font without giving an
% extension, but \pkg{fontspec} must know to search for the file; this can can
% be indicated by declaring the font exists in an `|ExternalLocation|':
% \begin{Verbatim}
%   \setmainfont{texgyrepagella-regular}[
%        ExternalLocation ,
%        BoldFont       = texgyrepagella-bold ,
%        ... ]
% \end{Verbatim}
% To be honest, |Path| and |ExternalLocation| are actually the same feature
% with different names. The former can be given without an argument and the
% latter can be given with one; the different names are just for clarity.
%
%
%
%
%
%
% \section{New commands to select font families}
%
% \cmdbox{
%   \CMD{\string\newfontfamily}\cs{\meta{font-switch}}\marg{font name}\oarg{font features} \\
%   \CMD{\string\newfontface}\cs{\meta{font-switch}}\marg{font name}\oarg{font features}
% }
%
% \noindent For cases when a specific font with a specific
% feature set is going to be re-used many times in a document, it is inefficient
% to keep calling \cs{fontspec} for every use. While the \cs{fontspec} command does not define
% a new font instance after the first call, the feature options must still be
% parsed and processed.
%
% \DescribeMacro{\newfontfamily}
% For this reason, new commands can be created for loading a particular font
% family with the \cmd\newfontfamily\ command, demonstrated in \exref{nff}.
% This macro should be used to create commands that would be used in
% the same way as \cmd\rmfamily, for example.
% If you would like to create a command that only changes the font
% inside its argument (i.e., the same behaviour as \cs{emph}) define it using regular \LaTeX\
% commands:
% \begin{Verbatim}
%   \newcommand\textnote[1]{{\notefont #1}}
%   \textnote{This is a note.}
% \end{Verbatim}
% Note that the double braces are intentional; the inner pair are used to
% to delimit the scope of the font change.
%
% \begin{Lexample}{nff}{Defining new font families.}
%   \newfontfamily\notefont{Kurier}
%   \notefont This is a \emph{note}.
% \end{Lexample}
%
% \DescribeMacro{\newfontface}
% Sometimes only a specific font face is desired, without accompanying italic or bold variants
% being automatically selected.
% This is common when selecting a fancy italic font, say, that has swash features unavailable
% in the upright forms. \cmd\newfontface\ is used for this purpose, shown
% in \exref{nfface}, which is repeated in \vref{sec:contextuals}.
%
% \begin{Xexample}{nfface}{Defining a single font face.}
%   \newfontface\fancy{Hoefler Text Italic}%
%       [Contextuals={WordInitial,WordFinal}]
%   \fancy where is all the vegemite
%   % \emph, \textbf, etc., all don't work
% \end{Xexample}
%
% Comment for advanced users:
% The commands defined by \cs{newfontface} and \cs{newfontfamily} include
% their encoding information, so even if the document is set to use a
% legacy \TeX\ encoding, such commands will still work correctly. For example,
% \begin{Verbatim}
% \documentclass{article}
% \usepackage{fontspec}
% \newfontfamily\unicodefont{Lucida Grande}
% \usepackage{mathpazo}
% \usepackage[T1]{fontenc}
% \begin{document}
% A legacy \TeX\ font. {\unicodefont A unicode font.}
% \end{document}
% \end{Verbatim}
%
% \subsection{More control over font shape selection}
% \label{sec:bfitfonts}
%
% \cmdbox{
%  \feat{BoldFont} = \meta{font name} \\
%  \feat{ItalicFont} = \meta{font name} \\
%  \feat{~BoldItalicFont} = \meta{font name} \\
%  \feat{SlantedFont} = \meta{font name} \\
%  \feat{BoldSlantedFont} = \meta{font name} \\
%  \feat{SmallCapsFont} = \meta{font name}
% }
%
% The automatic bold, italic, and bold italic font selections will not be
% adequate for the needs of every font: while some fonts mayn't even
% have bold or italic shapes, in which case a skilled (or lucky)
% designer may be able to chose well-matching accompanying shapes from
% a different font altogether, others can have a range of bold and
% italic fonts to chose among.  The \feat{BoldFont} and
% \feat{ItalicFont} features are provided for these situations. If only
% one of these is used, the bold italic font is requested as the
% default from the \emph{new} font. See \exref{bff}.
%
% \begin{Xexample}{bff}{Explicit selection of the bold font.}
%   \fontspec{Helvetica Neue UltraLight}%
%            [BoldFont={Helvetica Neue}]
%                 Helvetica Neue UltraLight         \\
%   {\itshape     Helvetica Neue UltraLight Italic} \\
%   {\bfseries               Helvetica Neue       } \\
%   {\bfseries\itshape       Helvetica Neue Italic} \\
% \end{Xexample}
%
% If a bold italic shape is not defined, or you want to specify
% \emph{both} custom bold and italic shapes, the \feat{BoldItalicFont}
% feature is provided.
%
% \subsubsection{Input shorthands}
%
% For those cases that the base font name is repeated, you can
% replace it with an asterisk. (This has been shown previously in \vref{sec:by-file-name}.)
% For example,
% some space can be saved instead of writing `\texttt{Baskerville SemiBold}':
% \begin{Verbatim}
%   \setmainfont{Baskerville}[BoldFont={* SemiBold}]
% \end{Verbatim}
%
% As a matter of fact, this feature can also be used for the upright font too:
% \begin{Verbatim}
%   \setmainfont{Baskerville}[UprightFont={* SemiBold},BoldFont={* Bold}]
% \end{Verbatim}
%
% \subsubsection{Small caps and slanted font shapes}
%
% For the rare situations where a font family will have slanted \emph{and}
% italic shapes, these may be specified separately using the analogous
% features \feat{SlantedFont} and \feat{BoldSlantedFont}. Without these,
% however, the \LaTeX\ font switches for slanted (\cs{textsl}, \cs{slshape})
% will default to the italic shape.
%
% Old-fashioned font families used to distribute their small caps
% glyphs in separate fonts due to the limitations on the number
% of glyphs allowed in the PostScript Type~1 format. Such fonts may be used
% by declaring the \feat{SmallCapsFont} of the family you are specifying:
% \begin{Verbatim}
%   \fontspec{Minion MM Roman}[
%     SmallCapsFont={Minion MM Small Caps & Oldstyle Figures}
%   ]
%   Roman 123 \\ \textsc{Small caps 456}
% \end{Verbatim}
% In fact, you may specify the small caps font for each individual bold and
% italic shape as in
% \begin{Verbatim}
%   \fontspec{ <upright> }[
%     UprightFeatures    = { SmallCapsFont={ <sc> } } ,
%     BoldFeatures       = { SmallCapsFont={ <bf sc> } } ,
%     ItalicFeatures     = { SmallCapsFont={ <it sc> } } ,
%     BoldItalicFeatures = { SmallCapsFont={ <bf it sc> } } ,
%   ]
%   Roman 123 \\ \textsc{Small caps 456}
% \end{Verbatim}
%
% For most modern fonts that have small caps as a font feature, this level of
% control isn't generally necessary, but you may still occasionally find font
% families in which the small caps are in a separate font.
%
% All of the bold, italic, and small caps fonts can be loaded with different
% font features from the main font. See \ref{sec:bfit-feat} for details.
% When an OpenType font is selected for |SmallCapsFont|, the small caps
% font feature is \emph{not} automatically enabled. In this case, users
% should write instead, if necessary,
% \begin{Verbatim}
%   \fontspec{...}[
%     SmallCapsFont={...},
%     SmallCapsFeatures={Letters=SmallCaps},
%   ]
% \end{Verbatim}
%
% \subsection{Specifically choosing the NFSS family}
%
% In \LaTeX's NFSS, font families are defined with names such as `\texttt{ppl}' (Palatino), `\texttt{cmr}' (Computer Modern Roman), and so on, which are selected with the \cs{fontfamily} command:
% \begin{Verbatim}
%   \fontfamily{ppl}\selectfont
% \end{Verbatim}
% In \pkg{fontspec}, the family names are auto-generated based on the fontname of the font; for example, writing |\fontspec{Times New Roman}| for the first time would generate an internal font family name of `\texttt{TimesNewRoman(1)}'.
%
% In certain cases it is desirable to be able to choose this internal font family name so it can be re-used elsewhere for interacting with other packages that use the \LaTeX's font selection interface; an example might be
% \begin{Verbatim}
%   \usepackage{fancyvrb}
%   \fvset{fontfamily=myverbatimfont}
% \end{Verbatim}
% To select a font for use in this way in \pkg{fontspec} use the \feat{NFSSFamily} feature:\footnote{Thanks to Luca Fascione for the example and motivation for finally implementing this feature.}
% \begin{Verbatim}
%   \newfontfamily\verbatimfont[NFSSFamily=myverbatimfont]{Inconsolata}
% \end{Verbatim}
% It is then possible to write commands such as:
% \begin{Verbatim}
%   \fontfamily{myverbatimfont}\selectfont
% \end{Verbatim}
% which is essentially the same as writing |\verbatimfont|, or to go back to the orginal example:
% \begin{Verbatim}
%   \fvset{fontfamily=myverbatimfont}
% \end{Verbatim}
% Only use this feature when necessary; the in-built font switching commands that \pkg{fontspec} generates (such as |\verbatimfont| in the example above) are recommended in all other cases.
%
% If you don't wish to explicitly set the NFSS family but you would like to know what it is, an alternative mechanism for package writers is introduced as part of the \pkg{fontspec} programming interface; see the function \cs{fontspec_set_family:Nnn} for details (\vref*{sec:api}).
%
% \subsection{Choosing additional NFSS font faces}
%
% \LaTeX's font selection scheme is more flexible than the \pkg{fontspec} interface discussed up until this point.
% It assigns to each font face a \emph{family} (discussed above), a \emph{series} such as bold or light or condensed, and a \emph{shape} such as italic or slanted or small caps.
% The \pkg{fontspec} features such as \feat{BoldFont} and so on all assign faces for the default series and shapes of the NFSS, but it's not uncommon to have font families that have multiple weights and shapes and so on.
%
% If you set up a regular font family with the `standard four' (upright, bold, italic, and bold italic) shapes and then want to use, say, a light font for a certain document element, many users will be perfectly happy to use \cs{newfontface}\cs{\meta{switch}} and use the resulting font \cs{\meta{switch}}.
% In other cases, however, it is more convenient or even necessary to load additional fonts using additional NFSS specifiers.
%
% \cmdbox{
%   \texttt{FontFace = }\marg{series}\marg{shape}
%      \texttt{\char`\{} \texttt{Font = }\meta{font name} \texttt, \meta{features} \texttt{\char`\}} \\
%   \texttt{FontFace = }\marg{series}\marg{shape}\marg{font name}
% }
%
% The font thus specified will inherit the font features of the main font, with optional addition \meta{features} as requested.
% (Note that the optional \marg{features} argument is still surrounded with curly braces.)
% Multiple \feat{FontFace} commands may be used in a single declaration to specify multiple fonts.
% As an example:
% \begin{Verbatim}
%   \setmainfont{font1.otf}[
%      FontFace = {c}{n}{ font2.otf } ,
%      FontFace = {c}{m}{ Font = font3.otf , Color = red }
%     ]
% \end{Verbatim}
% Writing |\fontseries{c}\selectfont| will result in |font2| being selected, which then followed by |\fontshape{m}\selectfont| will result in |font3| being selected (in red).
% A font face that is defined in terms of a different series but a normal shape will attempt to find a matching small caps feature and define that face as well if appropriate.
% Conversely, a font faced defined in terms of a different font will not.
%
% There are some standards for choosing shape and series codes; the \LaTeXe\ font selection guide\footnote{\texttt{texdoc fntguide}} lists series |m| for medium, |b| for bold, |bx| for bold extended, |sb| for semi-bold, and |c| for condensed.
% A far more comprehensive listing is included in Appendix~A of Philipp Lehman's `The Font Installation Guide'\footnote{\texttt{texdoc fontinstallationguide}} covering 14 separate weights and 12 separate widths.
%
% The \feat{FontFace} command also interacts properly with the \feat{SizeFeatures} command as follows: (nonsense set of font selection choices)
% \begin{Verbatim}
%   FontFace = {c}{n}{
%     Font = Times ,
%     SizeFeatures = {
%       { Size =   -10 , Font=Georgia } ,
%       { Size = 10-15}                 , % default "Font = Times"
%       { Size = 15-   , Font=Cochin  } ,
%     },
%   },
% \end{Verbatim}
% Note that if the first \feat{Font} feature is omitted then each size needs its own inner \feat{Font} declaration. 
%
% \subsection{Math(s) fonts}
%
% When \cmd\setmainfont, \cmd\setsansfont\ and \cmd\setmonofont\ are used in the
% preamble, they also define the fonts to be used in maths mode inside the
% \cmd\mathrm-type commands. This only occurs in the preamble because \LaTeX\
% freezes the maths fonts after this stage of the processing. The \pkg{fontspec}
% package must also be loaded after any maths font packages (\eg, \pkg{euler})
% to be successful. (Actually, it is \emph{only} \pkg{euler} that is the
% problem.\note{Speaking of \pkg{euler}, if you want to use its
% \texttt{[mathbf]} option, it won't work, and you'll need to put this after
% \pkg{fontspec} is loaded instead:
% \ttfamily\cmd\AtBeginDocument\char`\{\cmd\DeclareMathAlphabet\cmd\mathbf\char`\{U\char`\}\char`\{eur\char`\}\char`\{b\char`\}\char`\{n\char`\}})
%
% Note that \pkg{fontspec} will not change the font for general mathematics;
% only the upright and bold shapes will be affected.
% To change the font used for the mathematical symbols, see either the
% \pkg{mathspec} package or the \pkg{unicode-math} package.
%
% Note that you may find that loading some maths packages won't be as smooth as
% you expect since \pkg{fontspec} (and \XeTeX\ in general) breaks many of the
% assumptions of \TeX\ as to where maths characters and accents can be found.
% Contact me if you have troubles, but I can't guarantee to be able to fix any
% incompatibilities. The Lucida and Euler maths fonts should be fine; for all
% others keep an eye out for problems.
%
% \cmdbox{
%   \cmd{\setmathrm}\marg{font name}\oarg{font features} \\
%   \cmd{\setmathsf}\marg{font name}\oarg{font features} \\
%   \cmd{\setmathtt}\marg{font name}\oarg{font features} \\
%   \cmd{\setboldmathrm}\marg{font name}\oarg{font features}
% }
%
% However, the default text fonts may not necessarily be the ones you
% wish to use when typesetting maths (especially with the use of fancy
% ligatures and so on). For this reason, you may optionally use the
% commands above (in the same way as our other
% \cmd\fontspec-like commands) to explicitly state which fonts to use
% inside such commands as \cmd\mathrm. Additionally, the
% \cmd\setboldmathrm\ command allows you define the font used for
% \cmd\mathrm\ when in bold maths mode (which is activated with, among
% others, \cmd\boldmath).
%
% For example, if you were using Optima with the Euler maths font, you
% might have this in your preamble:
% \begin{Verbatim}
%   \usepackage{mathpazo}
%   \usepackage{fontspec,xunicode}
%   \setmainfont{Optima}
%   \setmathrm{Optima}
%   \setboldmathrm[BoldFont={Optima ExtraBlack}]{Optima Bold}
% \end{Verbatim}
%
%
%
% \subsection{Miscellaneous font selecting details}
%
% \paragraph{The optional argument --- from v2.4}
% For the first decade of \pkg{fontspec}'s life, optional font features were selected with a bracketed argument before the font name, as in:
% \begin{Verbatim}
%  \setmainfont[
%    lots and lots ,
%    and more and more ,
%    an excessive number really ,
%    of font features could go here
%  ]{myfont.otf}
% \end{Verbatim}
% This always looked like ugly syntax to me, and the order of these arguments has now been reversed:
% \begin{Verbatim}
%  \setmainfont{myfont.otf}[
%    lots and lots ,
%    and more and more ,
%    an excessive number really ,
%    of font features could go here
%  ]
% \end{Verbatim}
% I hope this doesn't cause any problems.
% \begin{enumerate}
%  \item Backwards compatibility has been preserved. (In fact, you could even write
%  \begin{Verbatim}
% \fontspec[Ligatures=Rare]{myfont.otf}[Color=red]
%  \end{Verbatim}
%  if you really felt like it and both sets of features would be applied.)
%
%  \item
%  Following standard \pkg{xparse} behaviour, there must be no space before the opening bracket; writing
%  \begin{Verbatim*}
% \fontspec{myfont.otf} [Color=red]
%  \end{Verbatim*}
%  will result in |[Color=red]| not being recognised an argument and therefore it will be typeset as text. When breaking over lines, write either of:
%  \begin{Verbatim}
%    \fontspec{myfont.otf}%        \fontspec{myfont.otf}[
%      [Color=red]                    Color=Red]
%  \end{Verbatim}
% 
% \end{enumerate}
%
% \paragraph{Spaces}
% \cmd\fontspec\ and \cmd\addfontfeatures\ ignore trailing spaces as
% if it were a `naked' control sequence; \eg, `|M. \fontspec{...} N|' and
% `|M. \fontspec{...}N|' are the same.
%
% \paragraph{Italic small caps}
% Note that this package redefines the \cs{itshape} and \cs{scshape}
% commands in order to allow them to select italic small caps in
% conjunction.
%
% \paragraph{Emphasis and nested emphasis}
% You may specify the behaviour of the \cs{emph} command by setting the
% \cs{emshape} command. \Eg, for bold emphasis:\par
% \indent|\renewcommand\emshape{\bfseries}|\par\noindent
% Nested emphasis is controlled by the \cs{eminnershape} command.
% For example, for |\emph{\emph{...}}| to produce small caps:\par
% \indent|\renewcommand\eminnershape{\scshape}|\par\noindent
% This functionality is provided with the same interface as the \pkg{fixltx2e} package, with a slightly different internal implementation.
%
%
%
%
% \section{Selecting font features}
% \label{sec:selectingfeature}
%
% The commands discussed so far such as \cs{fontspec} each take an optional argument for
% accessing the font features of the requested font.
% Commands are provided to set default features to be applied for all fonts, and even to change the features that a font is presently loaded with.
% Different font shapes can be loaded with separate features, and different features can even be selected for different sizes that the font appears in.
% This section discusses these options.
%
% \subsection{Default settings} \label{sec:defaults}
%
% \cmdbox{\cmd\defaultfontfeatures\marg{font features}}
%
% It is sometimes useful to define
% font features that are applied to every subsequent font selection command.
% This may be defined with the
% \cmd{\defaultfontfeatures} command, shown in \exref{dff}.
% New calls of \cs{defaultfontfeatures} overwrite previous ones, and defaults can be reset by calling the command with an empty argument.
%
% \begin{Xexample}{dff}{A demonstration of the \cs{defaultfontfeatures} command.}
%   \fontspec{TeX Gyre Adventor}
%   Some default text 0123456789 \\
%   \defaultfontfeatures{
%      Numbers=OldStyle, Color=888888
%   }
%   \fontspec{TeX Gyre Adventor}
%   Now grey, with old-style figures:
%   0123456789
% \end{Xexample}
%
% \cmdbox{\cmd\defaultfontfeatures\oarg{font name}\marg{font features}}
%
% Default font features can be specified on a per-font and per-face basis
% by using the optional argument to \cs{defaultfontfeatures} as shown.\footnote{Internally, \meta{font name} has all spaces removed and is converted to lowercase.}
% \begin{Verbatim}
%   \defaultfontfeatures[TeX Gyre Adventor]{Color=blue}
%   \setmainfont{TeX Gyre Adventor}% will be blue
% \end{Verbatim}
% Multiple fonts may be affected by using a comma separated list of font names.
%
% \cmdbox{\cmd\defaultfontfeatures\oarg{\cs{font-switch}}\marg{font features}}
%
% \textbf{New in v2.4}.
% Defaults can also be applied to symbolic families such as those created with the |\newfontfamily| command and for |\rmfamily|, |\sffamily|, and |\ttfamily|:
% \begin{Verbatim}
%   \defaultfontfeatures[\rmfamily,\sffamily]{Ligatures=TeX}
%   \setmainfont{TeX Gyre Adventor}% will use standard TeX ligatures
% \end{Verbatim}
% The line above to set \TeX-like ligatures is now activated by \emph{default} in \texttt{fontspec.cfg}.
% To reset default font features, simply call the command with an empty argument:
% \begin{Verbatim}
%   \defaultfontfeatures[\rmfamily,\sffamily]{}
%   \setmainfont{TeX Gyre Adventor}% will no longer use standard TeX ligatures
% \end{Verbatim}
%
% \cmdbox{\cmd\defaultfontfeatures\texttt{+}\marg{font features}\\
%         \cmd\defaultfontfeatures\texttt{+}\oarg{font name}\marg{font features}}
%
% \textbf{New in v2.4}.
% Using the |+| form of the command appends the \meta{font features} to any already-selected defaults.
% 
%
% \subsection{Default settings from a file}
%
% In addition to the defaults that may be specified in the document as described above, when a font is first loaded, a configuration file is searched
% for with the name `\meta{fontname}\texttt{.fontspec}'.\footnote{Located in the current folder or within a standard \texttt{texmf} location.}
%
% The contents of this file can be used to specify default font features without
% having to have this information present within each document.
% \meta{fontname} is stripped of spaces and file extensions are omitted; for
% example, the line above for \TeX\ Gyre Adventor could be placed in a file
% called \texttt{TeXGyreAdventor.fontspec}, or for specifying options for
% \texttt{texgyreadventor-regular.otf} (when loading by filename), the configuration
% file would be \texttt{texgyreadventor-regular.fontspec}.
% (N.B. the lettercase of the names should match.)
%
% This mechanism can be used to define custom names or aliases for your font collections.
% If you create a file \texttt{my-charis.fontspec} containing, say,
% \begin{Verbatim}
%   \defaultfontfeatures[my-charis]
%    {
%     Extension = .ttf ,
%     UprightFont = CharisSILR,
%     BoldFont = CharisSILB,
%     ItalicFont = CharisSILI,
%     BoldItalicFont = CharisSILBI,
%     % <any other desired options>
%    }
% \end{Verbatim}
% you can load that family with \verb|\fontspec{my-charis}| and similar.
% The optional argument to \cs{defaultfontfeatures} must match the filename
% else the options won't take effect.
%
% Finally, note that options for font faces can also be defined in this way.
% To continue the example above, here we colour the different faces:
% \begin{Verbatim}
%   \defaultfontfeatures[CharisSILR]{Color=blue}
%   \defaultfontfeatures[CharisSILB]{Color=red}
% \end{Verbatim}
% And such configuration lines can be stored either inline inside \texttt{my-charis.fontspec} or within their own \texttt{.fontspec} files; in this way, \pkg{fontspec} is designed to handle `nested' configuration options as well.
%
% \subsection{Changing the currently selected features}
% \label{sec:addfontfeatures}
%
% \cmdbox{\cmd\addfontfeatures\marg{font features}}
%
% This command allows font features to
% be changed without knowing what features are currently selected or even what
% font is being used. A good example of this could be to add a hook to all
% tabular material to use monospaced numbers, as shown in \exref{aff}.
% Note however that the behaviour in this regard will be unreliable (subject to the font itself) if you attempt to \emph{change} an already selected feature.
% \Eg, this sort of thing can cause troubles:
% \begin{Verbatim}
% \addfontfeature{Numbers=OldStyle}...
% \addfontfeature{Numbers=Lining}...
% 123
% \end{Verbatim}
% With both features active, how will the font render `123'? Depends on the font.
% In the distant future this functionality will be re-written to avoid this issue (giving `\verb|Numbers=OldStyle|' the smarts to know to explicitly de-activate any previous instances of `\verb|Numbers=Lining|', and vice-versa, but as I hope you can imagine this requires a fair degree of elbow grease which I haven't had available for some time now.
%
% \begin{Lexample}{aff}{A demonstration of the \cs{addfontfeatures} command. Note the caveat listed in the text regarding such usage.}
%   \fontspec{TeX Gyre Adventor}%
%            [Numbers={Proportional,OldStyle}]
%   `In 1842, 999 people sailed 97 miles in
%    13 boats. In 1923, 111 people sailed 54
%    miles in 56 boats.'            \bigskip
%
%   {\addfontfeatures{Numbers={Monospaced,Lining}}
%   \begin{tabular}{@{} cccc @{}}
%             Year & People & Miles & Boats \\
%     \hline  1842 &  999   &  75   &  13   \\
%             1923 &  111   &  54   &  56
%   \end{tabular}}
% \end{Lexample}
%
% \DescribeMacro{\addfontfeature}
% This command may also be executed under the alias \cmd{\addfontfeature}.
%
% \subsection{Priority of feature selection}
% Features defined with \cs{addfontfeatures} override features
% specified by \cs{fontspec}, which in turn override features
% specified by \cs{defaultfontfeatures}.  If in doubt, whenever a
% new font is chosen for the first time, an entry is made in the
% transcript (\texttt{.log}) file displaying the font name and the
% features requested.
%
% \subsection{Different features for different font shapes}
% \label{sec:bfit-feat}
%
% \cmdbox{
%  \feat{BoldFeatures}\texttt=\marg{features} \\
%  \feat{ItalicFeatures}\texttt=\marg{features} \\
%  \feat{BoldItalicFeatures}\texttt=\marg{features} \\
%  \feat{SlantedFeatures}\texttt=\marg{features} \\
%  \feat{BoldSlantedFeatures}\texttt=\marg{features} \\
%  \feat{SmallCapsFeatures}\texttt=\marg{features}
% }
%
% It is entirely possible that separate fonts in a family will require
% separate options; \eg, Hoefler Text Italic contains various swash
% feature options that are completely unavailable in the upright shapes.
%
% The font features defined at the top level of the optional \cmd\fontspec\
% argument are applied to \emph{all} shapes of the family.
% Using \feat{Upright-}, \feat{SmallCaps-}, \feat{Bold-},
% \feat{Italic-}, and \feat{BoldItalicFeatures},
% separate font features may be defined to their respective shapes
% \emph{in addition} to, and with precedence over, the `global' font features.
% See \exref{itfeat}.
%
% \begin{Xexample}{itfeat}{Features for, say, just italics.}
%   \fontspec{Hoefler Text} \itshape \scshape
%   Attention All Martini Drinkers \\
%   \addfontfeature{ItalicFeatures={Alternate = 1}}
%   Attention All Martini Drinkers \\
% \end{Xexample}
%
% Combined with the options for selecting arbitrary \emph{fonts} for
% the different shapes, these separate feature options allow the
% selection of arbitrary weights in the Skia typeface, as shown in \exref{bffeat}.
%
% \begin{Xexample}{bffeat}{Multiple Master--like features in AAT fonts.}
%   \fontspec[BoldFont={Skia},
%    BoldFeatures={Weight=2}]{Skia}
%   Skia \\ \bfseries Skia `Bold'
% \end{Xexample}
%
% Note that because most fonts include their small caps glyphs
% within the main font, features specified with \feat{SmallCapsFeatures} are applied \emph{in addition} to
% any other shape-specific features as defined above, and hence \feat{SmallCapsFeatures}
% can be nested within \feat{ItalicFeatures} and friends. Every combination
% of upright, italic, bold and small caps can thus be assigned individual
% features, as shown in the somewhat ludicrous \exref{scfeat}.
%
% \begin{Xexample}{scfeat}{An example of setting the \feat{SmallCapsFeatures}
% separately for each font shape.}
%   \fontspec{TeX Gyre Termes}[
%       UprightFeatures={Color = 220022,
%            SmallCapsFeatures = {Color=115511}},
%        ItalicFeatures={Color = 2244FF,
%            SmallCapsFeatures = {Color=112299}},
%          BoldFeatures={Color = FF4422,
%            SmallCapsFeatures = {Color=992211}},
%    BoldItalicFeatures={Color = 888844,
%            SmallCapsFeatures = {Color=444422}},
%            ]
%   Upright {\scshape Small Caps}\\
%   \itshape Italic {\scshape Italic Small Caps}\\
%   \upshape\bfseries Bold {\scshape Bold Small Caps}\\
%   \itshape Bold Italic {\scshape Bold Italic Small Caps}
% \end{Xexample}
%
% \subsection{Different features for different font sizes}
% \label{sec:sizefeature}
%
% \cmdbox{
% \ttfamily SizeFeatures = \char`\{\\
% \null\quad...\\
% \null\quad\char`\{~Size =
% \rmfamily\meta{size range}\ttfamily
% ,
% \rmfamily \meta{font features}\ttfamily
% ~\char`\} , \\
% \null\quad\char`\{~Size =
% \rmfamily\meta{size range}\ttfamily
% , Font =
% \rmfamily\meta{font name}\texttt, \meta{font features}\ttfamily
% ~\char`\} , \\
% \null\quad... \\
% \char`\}}
%
% The \feat{SizeFeature} feature is a little more complicated
% than the previous features discussed. It allows different fonts
% and different font features to be selected for a given font
% family as the point size varies.
%
% It takes a comma separated list of braced, comma separated lists of features for each size range.
% Each sub-list must contain the \opt{Size} option
% to declare the size range, and optionally \opt{Font} to change the
% font based on size. Other (regular) fontspec features that are added
% are used on top of the font features that would be used anyway.
% A demonstration to clarify these details is shown in \exref{sizefeat}.
% A less trivial example is shown in the context of optical font sizes
% in \vref{sec:opticalsize}.
%
% \begin{Xexample}{sizefeat}{An example of specifying different font features for different sizes of font with \feat{SizeFeatures}.}
%   \fontspec{TeX Gyre Chorus}[
%     SizeFeatures={
%       {Size={-8}, Font=TeX Gyre Bonum Italic, Color=AA0000},
%       {Size={8-14}, Color=00AA00},
%       {Size={14-}, Color=0000AA}} ]
%
%   {\scriptsize Small\par} Normal size\par {\Large Large\par}
% \end{Xexample}
%
% To be precise, the \opt{Size} sub-feature accepts arguments in the form shown in \vref{tab:sizing}.
% Braces around the size range are optional. For an exact font size (|Size=X|)
% font sizes chosen near that size will `snap'. For example, for size definitions
% at exactly 11pt and 14pt, if a 12pt font is requested \emph{actually} the
% 11pt font will be selected. This is a remnant of the past when fonts were designed
% in metal (at obviously rigid sizes) and later when bitmap fonts were similarly
% designed for fixed sizes.
%
% If additional features are only required for a single size, the other sizes
% must still be specified.  As in:
% \begin{Verbatim}
%   SizeFeatures={
%      {Size=-10,Numbers=Uppercase},
%      {Size=10-}}
% \end{Verbatim}
% Otherwise, the font sizes greater than 10 won't be defined at all!
%
% \begin{table}
% \caption{Syntax for specifying the size to apply custom font features.}\label{tab:sizing}
% \centering
% \begin{tabular}{@{}ll@{}}
% \toprule
% Input & Font size, $s$ \\
% \midrule
%  |Size = X-| & $s \geq \texttt{X}$ \\
%  |Size = -Y| & $s < \texttt{Y}$ \\
%  |Size = X-Y| & $\texttt{X} \leq s < \texttt{Y}$ \\
%  |Size = X| & $s = \texttt{X}$ \\
% \bottomrule
% \end{tabular}
% \end{table}
%
% \paragraph{Interaction with other features}
% For \feat{SizeFeatures} to work with \feat{ItalicFeatures}, \feat{BoldFeatures}, etc., and \feat{SmallCapsFeatures}, a strict heirarchy is required:
% \begin{Verbatim}
%  UprightFeatures =
%   {
%    SizeFeatures =
%     {
%      {
%       Size = -10,
%       Font = ..., % if necessary
%       SmallCapsFeatures = {...},
%       ... % other features for this size range
%      },
%      ... % other size ranges
%     }
%   }
% \end{Verbatim}
% Suggestions on simplifying this interface welcome.
%
%
% \section{Font independent options} \label{sec:font-ind-features}
%
% Features introduced in this section may be used with any font.
%
% \subsection{Colour}
%
% \feat{Color} (or \feat{Colour}), also shown in \vref{sec:defaults}
% and elsewhere, uses font specifications to set the colour of
% the text. The colour is defined as a triplet of two-digit Hex RGB
% values, with optionally another value for the transparency (where
% |00| is completely transparent and |FF| is opaque.)
% \begin{Lexample}{color}{Selecting colour with transparency. N.B. due to a conflict betweeen \pkg{fontspec} and the \pkg{preview} package, this example currently does not show any transparency!}
%   \fontsize{48}{48}
%   \fontspec{TeX Gyre Bonum Bold}
%   {\addfontfeature{Color=FF000099}W}\kern-0.5ex
%   {\addfontfeature{Color=0000FF99}S}\kern-0.4ex
%   {\addfontfeature{Color=DDBB2299}P}\kern-0.4ex
%   {\addfontfeature{Color=00BB3399}R}
% \end{Lexample}
% Transparency is supported by \LuaLaTeX; \XeLaTeX\ with the \texttt{xdvipdfmx} driver
% does not support this feature.
%
% If you load the \pkg{xcolor} package, you may use any named colour instead
% of writing the colours in hexadecimal.
% \begin{Verbatim}
%  \usepackage{xcolor}
%  ...
%  \fontspec[Color=red]{Verdana} ...
%  \definecolor{Foo}{rgb}{0.3,0.4,0.5}
%  \fontspec[Color=Foo]{Verdana} ...
% \end{Verbatim}
% The \pkg{color} package is \emph{not} supported; use \pkg{xcolor} instead.
%
% You may specify the transparency with a named colour using the \feat{Opacity}
% feature which takes an decimal from zero to one corresponding to
% transparent to opaque respectively:
% \begin{Verbatim}
%  \fontspec[Color=red,Opacity=0.7]{Verdana} ...
% \end{Verbatim}
% It is still possible to specify a colour in six-char hexadecimal form
% while defining opacity in this way, if you like.
%
% \subsection{Scale}
%
% \cmdbox{
%  \feat{Scale} = \meta{number} \\
%  \feat{Scale} = \opt{MatchLowercase} \\
%  \feat{Scale} = \opt{MatchUppercase}
% }
%
% In its explicit form, \feat{Scale} takes a single
% numeric argument for linearly scaling the font, as demonstrated
% in \exref{fontload}.
% It is now possible to
% measure the correct dimensions of the fonts loaded and
% calculate values to scale them automatically.
%
% As well as a numerical argument, the \feat{Scale} feature
% also accepts options \opt{MatchLowercase}
% and \opt{MatchUppercase}, which will scale the font being selected to match
% the current default roman font to either the height of the lowercase or
% uppercase letters, respectively; these features are shown in \exref{scale}.
%
% \begin{Xexample}{scale}{Automatically calculated scale values.}
%   \setmainfont{Georgia}
%   \newfontfamily\lc[Scale=MatchLowercase]{Verdana}
%    The perfect match {\lc is hard to find.}\\
%   \newfontfamily\uc[Scale=MatchUppercase]{Arial}
%    L O G O \uc F O N T
% \end{Xexample}
%
% The amount of scaling used in each instance is reported in the \texttt{.log} file.
% Since there is some subjectivity about the exact scaling to be used, these values
% should be used to fine-tune the results.
%
% Note that when |Scale=MatchLowercase| is used with |\setmainfont|, the new `main' font of the document will be scaled to match the old default.
% This may be undesirable in some cases, so to achieve `natural' scaling for the main font but automatically scale all other fonts selected, you may write
% \begin{Verbatim}
%   \defaultfontfeatures{ Scale = MatchLowercase }
%   \defaultfontfeatures[\rmfamily]{ Scale = 1}
% \end{Verbatim}
% One or both of these lines may be placed into a local |fontspec.cfg| file (see \vref{sec:config}) for this behaviour to be effected in your own documents automatically.
% (Also see \vref{sec:defaults} for more information on setting font defaults.)
%
%
%
% \subsection{Interword space}
%
% While the space between words can be varied on an individual
% basis with the \TeX\ primitive \cmd\spaceskip\ command, it is
% more convenient to specify this information when the font is
% first defined.
%
% The space in between words in a paragraph will be chosen automatically,
% and generally will not need to be adjusted. For those
% times when the precise details are important, the \feat{WordSpace}
% feature is
% provided, which takes either a single scaling factor to scale the
% default value, or a triplet of comma-separated
% values to scale the nominal value, the stretch, and the shrink of the
% interword space by, respectively. (|WordSpace={|$x$|}| is the same as
% |WordSpace={|$x$|,|$x$|,|$x$|}|.)
%
% \begingroup
% \let\centering\relax
% \begin{Xexample}{wordspace}{Scaling the default interword space. An exaggerated value has been chosen to emphasise the effects here.}
%   \fontspec{TeX Gyre Termes}
%   Some text for our example to take
%   up some space, and to demonstrate
%   the default interword space.
%   \bigskip
%
%   \addfontfeature{ WordSpace = 0.3 }
%   Some text for our example to take
%   up some space, and to demonstrate
%   the default interword space.
% \end{Xexample}
% \endgroup
%
% \subsection{Post-punctuation space}
%
% If \cmd\frenchspacing\ is \emph{not} in effect, \TeX\ will allow extra
% space after some punctuation in its goal of justifying the lines of text.
% Generally, this is considered old-fashioned, but occasionally in small amounts the
% effect can be justified, pardon the pun.
%
% The \feat{PunctuationSpace} feature takes a scaling factor by which to
% adjust the nominal value chosen for the font; this is demonstrated in
% \exref{punctspace}.
% Note that |PunctuationSpace=0|
% is \emph{not} equivalent to \cmd\frenchspacing, although the difference
% will only be apparent when a line of text is under-full.
%
% \begin{Lexample}{punctspace}{Scaling the default post-punctuation space.}
%   \nonfrenchspacing
%   \fontspec{TeX Gyre Schola}
%    Letters, Words. Sentences.          \par
%   \fontspec{TeX Gyre Schola}[PunctuationSpace=2]
%    Letters, Words. Sentences.          \par
%   \fontspec{TeX Gyre Schola}[PunctuationSpace=0]
%    Letters, Words. Sentences.
% \end{Lexample}
%
%
%
%
% \subsection{The hyphenation character}
%
% The letter used for hyphenation may be chosen with the \feat{HyphenChar}
% feature. It takes three types of input, which are chosen according to some
% simple rules. If the input is the string \opt{None}, then hyphenation is
% suppressed for this font.
% If the input is a single character, then this
% character is used. Finally, if the input is longer than a single character
% it must be the UTF-8 slot number of the hyphen character you desire.
%
% This package
% redefines \LaTeX's \cmd\-\ macro
% such that it adjusts along with the above changes.
%
% \begin{Xexample}{hyphchar}{Explicitly choosing the hyphenation character.}
%  \def\text{\fbox{\parbox{1.55cm}{%
%    EXAMPLE HYPHENATION%
%  }}\qquad\qquad\null\par\bigskip}
%
%  \fontspec{Linux Libertine O}
%  \addfontfeature{HyphenChar=None}
%  \text
%  \addfontfeature{HyphenChar={+}}
%  \text
% \end{Xexample}
%
% \subsection{Optical font sizes} \label{sec:opticalsize}
%
% Optically scaled fonts thicken out as the font size decreases
% in order to make the glyph shapes more robust (less prone to losing
% detail), which improves legibility. Conversely, at large optical
% sizes the serifs and other small details may be more delicately
% rendered.
%
% OpenType fonts with optical scaling will exist in
% several discrete sizes, and these will be selected by \XeTeX\
% and Lua\TeX\
% \emph{automatically} determined by the current font size as in
% \exref{optsize}, in which we've scaled down some large text in order to be
% able to compare the difference for equivalent font sizes.
%
% The
% \opt{OpticalSize} option may be used to specify a different optical
% size.
% With \opt{OpticalSize} set
% to zero, no optical size font substitution is performed, as shown in
% \exref{optsize0}.
%
% \begin{Xexample}{optsize}{A demonstration of automatic optical size selection.}
%   \fontspec{Latin Modern Roman}
%    Automatic optical size                  \\
%   \scalebox{0.4}{\Huge
%    Automatic optical size}
% \end{Xexample}
%
% \begin{Xexample}{optsize0}{Optical size substitution is suppressed when set to zero.}
%   \fontspec{Latin Modern Roman 5 Regular}[OpticalSize=0]
%    Latin Modern optical sizes                \\
%   \fontspec{Latin Modern Roman 8 Regular}[OpticalSize=0]
%    Latin Modern optical sizes                \\
%   \fontspec{Latin Modern Roman 12 Regular}[OpticalSize=0]
%    Latin Modern optical sizes                \\
%   \fontspec{Latin Modern Roman 17 Regular}[OpticalSize=0]
%    Latin Modern optical sizes
% \end{Xexample}
%
% The \feat{SizeFeatures} feature (\vref*{sec:sizefeature}) can be
% used to specify exactly which optical sizes will be used for ranges
% of font size. For example, something like:
% \begin{Verbatim}
%   \fontspec{Latin Modern Roman}[
%     UprightFeatures = { SizeFeatures = {
%       {Size=-10,     OpticalSize=8 },
%       {Size= 10-14,  OpticalSize=10},
%       {Size= 14-18,  OpticalSize=14},
%       {Size=    18-, OpticalSize=18}}}
%            ]
% \end{Verbatim}
%
% \part{OpenType}
% \label{sec:opentype-features}
%
% \section{Introduction}
% \label{sec:opentype-features-intro}
%
% OpenType fonts (and other `smart' font technologies such as AAT and Graphite) can change the appearance of text in many different ways.
% These changes are referred to as features.
% When the user applies a feature~--- for example, small capitals~--- to a run of text, the code inside the font makes appropriate adjustments and small capitals appear in place of lowercase letters.
% However, the use of such features does not affect the underlying text.
% In our small caps example, the lowercase letters are still stored in the document; only the appearance has been changed by the OpenType feature.
% This makes it possible to search and copy text without difficulty.
% If the user selected a different font that does not support small caps, the `plain' lowercase letters would appear instead.
%
% Some OpenType features are required to support particular scripts, and these features are often applied automatically.
% The scripts used in India, for example, often require that characters be reshaped and reordered after they are typed by the user, in order to display them in the traditional ways that readers expect.
% Other features can be applied to support a particular language.
% The Junicode font for medievalists uses by default the Old English shape of the letter thorn, while in modern Icelandic thorn has a more rounded shape.
% If a user tags some text as being in Icelandic, Junicode will automatically change to the Icelandic shape through an OpenType feature that localizes the shapes of letters.
%
% A very large group of OpenType features is designed to support high quality typography in Latin, Greek, Cyrillic and other standard scripts.
% Examples of some font features have already been shown in previous sections; the complete set of OpenType font features supported by \pkg{fontspec} is described below in \ref{sec:ot-feat}.
%
% The OpenType specification provides four-letter codes (e.g., \texttt{smcp} for small capitals) for each feature.  The four-letter codes are given below along with the \pkg{fontspec} names for various features, for the benefit of people who are already familiar with OpenType.  You can ignore the codes if they don't mean anything to you.
%
%
% \subsection{How to select font features}
%
% Font features are selected by a series of \meta{feature}=\meta{option}
% selections. Features are (usually) grouped logically; for example, all
% font features relating to ligatures are accessed by writing \verb|Ligatures={...}| with the appropriate argument(s), which could be \texttt{TeX}, \texttt{Rare}, etc., as shown below in \ref{sec:ot-feat-liga}.
%
% Multiple options may be given to
% any feature that accepts non-numerical input, although doing so will
% not always work. Some options will override others in generally
% obvious ways; \Verb|Numbers={OldStyle,Lining}| doesn't make much
% sense because the two options are mutually exclusive, and \XeTeX\
% will simply use the last option that is specified (in this case
% using \opt{Lining} over \opt{OldStyle}).
%
% If a feature or an option is requested that the font does not have,
% a warning is given in the console output. As mentioned in \vref{sec:quiet-warnings}
% these warnings can be suppressed by selecting the \texttt{[quiet]} package option.
%
% \section{Complete listing of OpenType font features}
% \label{sec:ot-feat}
%
% \subsection{Ligatures}
% \label{sec:ot-feat-liga}
%
% \feat{Ligatures} refer to the replacement of two separate characters
% with a specially drawn glyph for functional or \ae sthetic reasons.
% The list of options, of which multiple may be selected at one time,
% is shown in \ref{feat:Ligatures}.
% A demonstration with the Linux Libertine fonts\note{\url{http://www.linuxlibertine.org/}} is shown in \exref{lig}.
%
% Note the additional features accessed with \verb|Ligatures=TeX|. These are
% not actually real OpenType features, but additions provided by \pkg{luaotfload} (i.e., \LuaTeX\ only) to emulate \TeX's behaviour for \textsc{ascii} input of curly quotes and punctuation. In \XeTeX\ this is achieved with the \feat{Mapping} feature (see \vref{sec:mapping}) but for consistency \verb|Ligatures=TeX| will perform the same function as \verb|Mapping=tex-text|.
%
% \begin{features}{Ligatures}
% \otf*{Required}{rlig}
% \otf*{Common}{liga}
% \otf*{Contextual}{clig}
% \otf{Rare/Discretionary}{dlig}
% \otf{Historic}{hlig}
% \otf{TeX}{tlig/trep}
% \end{features}
%
% \begin{Lexample}[firstline=2]{lig}{An example of the \feat{Ligatures} feature.}
%    \Huge\centering
%    \def\test#1#2{%
%      #2 $\to$ {\addfontfeature{#1} #2}\\}
%    \fontspec{Linux Libertine O}
%    \test{Ligatures=Historic}{strict}
%    \test{Ligatures=Rare}{wurtzite}
%    \test{Ligatures=NoCommon}{firefly}
% \end{Lexample}
%
% \subsection{Letters} \label{sec:letters}
% The \opt{Letters} feature specifies how the letters in the current font
% will look. OpenType fonts may contain the following options:
% \opt{Uppercase}, \opt{SmallCaps}, \opt{PetiteCaps},
% \opt{UppercaseSmallCaps}, \opt{UppercasePetiteCaps}, and
% \opt{Unicase}.
%
% \begin{features}{Letters}
% \otf{Uppercase}{case}
% \otf{SmallCaps}{smcp}
% \otf{PetiteCaps}{pcap}
% \otf{UppercaseSmallCaps}{c2sc}
% \otf{UppercasePetiteCaps}{c2pc}
% \otf{Unicase}{unic}
% \end{features}
%
% Petite caps are smaller than small caps.
% \opt{SmallCaps} and \opt{PetiteCaps}
% turn lowercase letters into the smaller caps letters,
% whereas the \opt{Uppercase...} options turn the \emph{capital} letters into
% the smaller
% caps (good, \eg, for applying to already uppercase acronyms like
% `NASA').
% This difference is shown in \exref{caps}.
% `Unicase' is a weird hybrid of upper and lower case letters.
%
% \begin{Lexample}{caps}{Small caps from lowercase or uppercase letters.}
%   \fontspec{TeX Gyre Adventor}[Letters=SmallCaps]
%    THIS SENTENCE no verb                \\
%   \fontspec{TeX Gyre Adventor}[Letters=UppercaseSmallCaps]
%    THIS SENTENCE no verb
% \end{Lexample}
%
% Note that the \opt{Uppercase} option will (probably)
% not actually map letters to uppercase.
%  \note{If you want automatic uppercase letters, look to \LaTeX's
%       \cmd\MakeUppercase\ command.}
% It is designed to select various
% uppercase forms for glyphs such as accents and dashes, such as shown
% in \exref{letters-uppercase}; note the raised position of the hyphen
% to better match the surrounding letters.
%
% \begin{Lexample}{letters-uppercase}{An example of the \opt{Uppercase} option of the \feat{Letters} feature.}
%   \fontspec{Linux Libertine O}
%    UPPER-CASE example \\
%   \addfontfeature{Letters=Uppercase}
%    UPPER-CASE example
% \end{Lexample}
%
% The \feat{Kerning} feature also contains an \opt{Uppercase} option,
% which adds a small amount of spacing in between letters (see \vref{sec:kerning}).
%
% \subsection{Numbers}
%
% The \feat{Numbers} feature defines how numbers will look in the
% selected font, accepting options shown in \ref{feat:Numbers}.
%
% \begin{features}{Numbers}
% \otf{Uppercase/Lining}{lnum}
% \otf{Lowercase/OldStyle}{onum}
% \otf{Proportional}{pnum}
% \otf{Monospaced}{tnum}
% \otf{SlashedZero}{zero}
% \otf{Arabic}{anum}
% \end{features}
%
% The synonyms
% \opt{Uppercase} and \opt{Lowercase} are equivalent to \opt{Lining} and
% \opt{OldStyle}, respectively.
% The differences have been shown previously
% in \vref{sec:addfontfeatures}.
% The \opt{Monospaced} option is useful for tabular material when digits need
% to be vertically aligned.
%
% The \opt{SlashedZero} option
% replaces the default zero with a slashed version to prevent
% confusion with an uppercase `O', shown in \exref{slashzero}.
%
% \begin{Lexample}{slashzero}{The effect of the \opt{SlashedZero} option.}
%   \fontspec[Numbers=Lining]{TeX Gyre Bonum}
%    0123456789
%   \fontspec[Numbers=SlashedZero]{TeX Gyre Bonum}
%    0123456789
% \end{Lexample}
%
% The \opt{Arabic} option (with tag \verb|anum|) maps regular numerals to their Arabic script or Persian equivalents
% based on the current \opt{Language} setting (see \vref{sec:ot}), shown in
% \exref{num-arab} using the Persian Modern font, which is included in \TeX\ Live
% and MiK\TeX.
% This option is based on a \LuaTeX\ feature of the \pkg{luaotfload} package,
% not an OpenType feature. (Thus, this feature is unavailable in \XeTeX.)
%
% \begin{Lexample}[firstline=2]{num-arab}{An example of number remapping to Arabic or Persian. (\LuaTeX\ only.)}
%   \huge
%   \fontspec{persian-modern-regular.ttf}%
%     [Script=Arabic,Numbers=Arabic]
%   {\addfontfeature{Language=Arabic}
%    0123456789} \\
%   {\addfontfeature{Language=Parsi}
%    0123456789}
% \end{Lexample}
%
% \subsection{Contextuals}
% This feature refers to substitutions of glyphs that vary `contextually' by their relative position in a word or string of characters;
% features such as contextual swashes are accessed via the options shown in \ref{feat:Contextuals}.
%
% \begin{features}{Contextuals}
% \otf{Swash}{cswh}
% \otf{Alternate}{calt}
% \otf{WordInitial}{init}
% \otf{WordFinal}{fina}
% \otf{LineFinal}{falt}
% \otf{Inner}{medi}
% \end{features}
%
% Historic forms are accessed in OpenType
% fonts via the feature \feat{Style=Historic}; this is generally \emph{not}
% contextual in OpenType, which is why it is not included in this feature.
%
% \subsection{Vertical Position}
%
% \begin{features}{VerticalPosition}
% \otf{Superior}{sups}
% \otf{Inferior}{subs}
% \otf{Numerator}{numr}
% \otf{Denominator}{dnom}
% \otf{ScientificInferior}{sinf}
% \otf{Ordinal}{ordn}
% \end{features}
%
% The \feat{VerticalPosition} feature is used to access things like
% subscript (\opt{Inferior}) and superscript (\opt{Superior}) numbers and
% letters (and a small amount of punctuation, sometimes).
% The \opt{Ordinal} option will only raise characters that are used
% in some languages directly after a number.
% The \opt{ScientificInferior} feature will move glyphs
% further below the baseline than the \opt{Inferior} feature.
% These are shown in \exref{vertpos}
%
% \opt{Numerator} and \opt{Denominator} should only be used for creating
% arbitrary fractions (see next section).
%
% \begin{Lexample}{vertpos}{The \feat{VerticalPosition} feature.}
%   \fontspec{LibreCaslonText-Regular.otf}[VerticalPosition=Superior]
%    Superior: 1234567890                                   \\
%   \fontspec{LibreCaslonText-Regular.otf}[VerticalPosition=Numerator]
%    Numerator: 12345                                       \\
%   \fontspec{LibreCaslonText-Regular.otf}[VerticalPosition=Denominator]
%    Denominator: 12345                                     \\
%   \fontspec{LibreCaslonText-Regular.otf}[VerticalPosition=ScientificInferior]
%    Scientific Inferior: 12345
% \end{Lexample}
%
% The \pkg{realscripts} package
% (which is also loaded by \pkg{xltxtra} for \XeTeX)
% redefines the \cmd\textsubscript\ and
% \cmd\textsuperscript\ commands to use the above font features automatically,
% including for use in footnote labels.
% If this is the only feature of \pkg{xltxtra} you wish to use, consider
% loading \pkg{realscripts} on its own instead.
%
%
% \subsection{Fractions}
%
% \begin{features}{Fractions}
% \otf{On}{frac}
% \otf{Alternate}{afrc}
% \end{features}
%
% For OpenType fonts use a regular text slash to create fractions, but
% the \feat{Fraction} feature must be explicitly activated.
% Some (Asian fonts predominantly) also provide for the
% \opt{Alternate} feature. These are both shown in \exref{ot-frac}.
%
% \begin{Xexample}{ot-frac}{The \feat{Fractions} feature.}
%   \fontspec{Hiragino Maru Gothic Pro W4}
%    1/2 \quad 1/4 \quad 5/6 \quad 13579/24680 \\
%   \addfontfeature{Fractions=On}
%    1/2 \quad 1/4 \quad 5/6 \quad 13579/24680 \\
%   \addfontfeature{Fractions=Alternate}
%    1/2 \quad 1/4 \quad 5/6 \quad 13579/24680 \\
% \end{Xexample}
%
%
% \subsection{Stylistic Set variations}
%
% This feature selects a `Stylistic Set' variation,
% which usually corresponds to an alternate glyph style for a range of
% characters (usually an alphabet or subset thereof).
% This feature is specified numerically. These correspond to OpenType
% features |ss01|, |ss02|, etc.
%
% Two demonstrations from the Junicode
% font\note{\url{http://junicode.sf.net}}
% are shown in \exref{ss} and \exref{ss2}; thanks to Adam
% Buchbinder for the suggestion.
%
% \begin{Lexample}{ss}{Insular letterforms, as used in medieval Northern Europe, for the Junicode font accessed with the \feat{StylisticSet} feature.}
%   \fontspec{Junicode}
%    Insular forms. \\
%   \addfontfeature{StylisticSet=2}
%    Insular forms. \\
% \end{Lexample}
%
% \begin{Lexample}{ss2}{Enlarged minuscules (capital letters remain unchanged) for the Junicode font, accessed with the \feat{StylisticSet} feature.}
%   \fontspec{Junicode}
%    ENLARGED Minuscules. \\
%   \addfontfeature{StylisticSet=6}
%    ENLARGED Minuscules. \\
% \end{Lexample}
%
% Multiple stylistic sets may be selected simultaneously by writing, e.g.,
% |StylisticSet={1,2,3}|.
%
% The |StylisticSet| feature is a synonym of the \feat{Variant} feature for \AAT\ fonts.
% See \vref{sec:newfeatures} for a way to assign names to stylistic sets, which should be done on a per-font basis.
%
% \subsection{Character Variants}
%
% Similar to the `Stylistic Sets' above, `Character Variations' are selected
% numerically to adjust the output of (usually) a single character for the
% particular font. These correspond to the OpenType features |cv01| to |cv99|.
%
% For each character that can be varied, it is possible to select among
% possible options for that particular glyph.
% For example, in \exref{cv} a variety of glyphs for the character `v' are
% selected, in which |5| corresponds to the character `v' for this font feature,
% and the trailing |:|\meta{n} corresponds to which variety to choose.
% Georg Duffner's open source Garamond revival font\footnote{\url{http://www.georgduffner.at/ebgaramond/}} is used in this example.
% Character variants are specifically designed not to conflict with each
% other, so you can enable them individually per character as shown in
% \exref{cv2}. (Unlike stylistic alternates, say.)
%
% Note that the indexing starts from zero.
%
% \begin{Lexample}[firstline=2]{cv}{The \feat{CharacterVariant} feature showing off Georg Duffner's open source Garamond revival font.}
%   \huge
%   \fontspec{EB Garamond 12 Italic}                       very \\
%   \fontspec{EB Garamond 12 Italic}[CharacterVariant=5]   very \\
%   \fontspec{EB Garamond 12 Italic}[CharacterVariant=5:0] very \\
%   \fontspec{EB Garamond 12 Italic}[CharacterVariant=5:1] very \\
%   \fontspec{EB Garamond 12 Italic}[CharacterVariant=5:2] very \\
%   \fontspec{EB Garamond 12 Italic}[CharacterVariant=5:3] very
% \end{Lexample}
%
% \begin{Lexample}[firstline=2]{cv2}{The \feat{CharacterVariant} feature selecting multiple variants simultaneously.}
%   \huge
%   \fontspec{EB Garamond 12 Italic}                           \& violet \\
%   \fontspec{EB Garamond 12 Italic}[CharacterVariant={4}]     \& violet \\
%   \fontspec{EB Garamond 12 Italic}[CharacterVariant={5:2}]   \& violet \\
%   \fontspec{EB Garamond 12 Italic}[CharacterVariant={4,5:2}] \& violet
% \end{Lexample}
%
% \subsection{Alternates}
%
% The \feat{Alternate} feature (for the raw OpenType feature |salt|) is used to access alternate font glyphs when variations exist in the font, such as in \exref{salt}.
% It uses a numerical selection, starting from zero, that will be different for each font.
% Note that the \texttt{Style=Alternate} option is equivalent
% to \texttt{Alternate=0} to access the default case.
%
% \begin{Xexample}[firstline=2]{salt}{The \feat{Alternate} feature.}
%   \huge
%   \fontspec{Linux Libertine O}
%   \textsc{a} \& h \\
%   \addfontfeature{Alternate=0}
%   \textsc{a} \& h
% \end{Xexample}
%
% Note that the indexing starts from zero.
%
% See \vref{sec:newfeatures} for a way to assign names to alternates,
% which must be done on a per-font basis.
%
% \subsection{Style}
% \label{sec:ot-feat-style}
%
% \begin{features}{Style}
% \otf{Alternate}{salt}
% \otf{Italic}{ital}
% \otf{Ruby}{ruby}
% \otf{Swash}{swsh}
% \otf{Historic}{hist}
% \otf{TitlingCaps}{titl}
% \otf{HorizontalKana}{hkna}
% \otf{VerticalKana}{vkna}
% \end{features}
%
% `Ruby' refers to a small optical size, used in
% Japanese typography for annotations.
% For fonts with multiple |salt| OpenType features,
% use the fontspec \feat{Alternate} feature instead.
%
% \Exref{style-alt} and \exref{style-hist} both contain glyph
% substitutions with similar characteristics.
% Note the occasional inconsistency with which font features are labelled; a long-tailed `Q' could turn up anywhere!
%
%  \begin{Xexample}[firstline=2]{style-alt}{Example of the \opt{Alternate} option of the \feat{Style} feature.}
%   \Large
%   \fontspec{Quattrocento Roman}
%    M Q W                      \\
%   \addfontfeature{Style=Alternate}
%    M Q W
% \end{Xexample}
%
% \begin{Xexample}[firstline=2]{style-hist}{Example of the \opt{Historic} option of the \feat{Style} feature.}
%   \Large
%   \fontspec{Adobe Jenson Pro}
%    M Q Z                      \\
%   \addfontfeature{Style=Historic}
%    M Q Z
% \end{Xexample}
%
% In other features, larger breadths of changes can be seen, covering
% the style of an entire alphabet. See \exref{style-titl} and \exref{style-itrub}; in the latter, the \opt{Italic} option affects the Latin text and the \opt{Ruby} option the Japanese.
%
% \begin{Xexample}[firstline=2]{style-titl}{Example of the \opt{TitlingCaps} option of the \feat{Style} feature.}
%   \Large
%   \fontspec{Adobe Garamond Pro}
%    TITLING CAPS                       \\
%   \addfontfeature{Style=TitlingCaps}
%    TITLING CAPS
% \end{Xexample}
%
% \begin{Xexample}[firstline=2]{style-itrub}{Example of the \opt{Italic} and \opt{Ruby} options of the \feat{Style} feature.}
%   \Large \def\kana{ようこそ ワカヨタレソ}
%   \fontspec{Hiragino Mincho Pro}
%    Latin \kana        \\
%   \addfontfeature{Style={Italic, Ruby}}
%    Latin \kana
% \end{Xexample}
%
% Note the difference here between the default and the horizontal style kana
% in \exref{style-hvkana}: the horizontal style is slightly wider.
%
% \begin{Xexample}[firstline=2]{style-hvkana}{Example of the \opt{HorizontalKana} and \opt{VerticalKana} options of the \feat{Style} feature.}
%   \Large \def\kana{ようこそ ワカヨタレソ}
%    \fontspec{Hiragino Mincho Pro}
%     \kana   \\
%   {\addfontfeature{Style=HorizontalKana}
%     \kana } \\
%   {\addfontfeature{Style=VerticalKana}
%     \kana }
% \end{Xexample}
%
% \subsection{Diacritics}
% Specifies how combining diacritics should be placed.
% These will usually be controlled automatically
% according to the Script setting.
%
% \begin{features}{Diacritics}
% \otf*{MarkToBase}{mark}
% \otf*{MarkToMark}{mkmk}
% \otf*{AboveBase}{abvm}
% \otf*{BelowBase}{blwm}
% \end{features}
%
% \subsection{Kerning}\label{sec:kerning}
% Specifies how inter-glyph spacing should behave.
% Well-made fonts include information for how differing
% amounts of space should be inserted between separate character pairs.
% This kerning space is inserted automatically but in rare
% circumstances you may wish to turn it off.
%
% \begin{features}{Kerning}
% \otf{Uppercase}{cpsp}
% \otf*[Off]{On}{kern}
% \end{features}
%
% As briefly mentioned previously at the end of \vref{sec:letters},
% the \opt{Uppercase} option will add a small amount of tracking between
% uppercase letters, seen in \exref{kernup}, which uses the Romande
% fonts\note{\url{http://arkandis.tuxfamily.org/adffonts.html}}
% (thanks to Clea F. Rees for the suggestion).
% The \opt{Uppercase} option acts separately to the regular kerning
% controlled by the \opt{On}/\opt{Off} options.
%
% \begin{Xexample}[firstline=2]{kernup}{Adding extra kerning for uppercase letters. (The difference is usually very small.)}
%   \large
%   \fontspec{Romande ADF Std Bold}
%    UPPERCASE EXAMPLE \\
%   \addfontfeature{Kerning=Uppercase}
%    UPPERCASE EXAMPLE
% \end{Xexample}
%
%
% \subsection{Font transformations}
%
% In rare situations users may want to mechanically distort the shapes of the glyphs in the current font such as shown in \exref{fake}. Please don't overuse these features; they are \emph{not} a good alternative to having the real shapes.
%
% \begin{Xexample}{fake}{Articifial font transformations.}
%   \fontspec{Charis SIL} \emph{ABCxyz} \quad
%   \fontspec{Charis SIL}[FakeSlant=0.2] ABCxyz
%
%   \fontspec{Charis SIL}  ABCxyz \quad
%   \fontspec{Charis SIL}[FakeStretch=1.2] ABCxyz
%
%   \fontspec{Charis SIL} \textbf{ABCxyz} \quad
%   \fontspec{Charis SIL}[FakeBold=1.5] ABCxyz
% \end{Xexample}
%
% If values are omitted, their defaults are as shown above.
%
% If you want the bold shape to be faked automatically, or the italic shape
% to be slanted automatically, use the \feat{AutoFakeBold} and
% \feat{AutoFakeSlant} features. For example, the following two invocations
% are equivalent:
% \begin{Verbatim}
%   \fontspec[AutoFakeBold=1.5]{Charis SIL}
%   \fontspec[BoldFeatures={FakeBold=1.5}]{Charis SIL}
% \end{Verbatim}
% If both of the \feat{AutoFake...} features are used, then the bold italic
% font will also be faked.
%
% The \feat{FakeBold} and \feat{AutoFakeBold} features are only available with the \XeTeX\ engine and will be ignored in \LuaTeX.
%
% \subsection{Annotation}
% Some fonts are equipped with an extensive range of
% numbers and numerals in different forms. These are accessed with the
% \feat{Annotation} feature (OpenType feature |nalt|), selected numerically as shown in
% \exref{ot-annot}.
%
% \begin{Xexample}{ot-annot}{Annotation forms for OpenType fonts.}
%   \fontspec{Hiragino Maru Gothic Pro}
%    1 2 3 4 5 6 7 8 9
%   \def\x#1{\\{\addfontfeature{Annotation=#1}
%             1 2 3 4 5 6 7 8 9 }}
%   \x0\x1\x2\x3\x4\x5\x6\x7\x7\x8\x9
% \end{Xexample}
%
% Note that the indexing starts from zero.
%
% \subsection{CJK shape}
%
% \begin{features}{CJKShape}
% \otf{Traditional}{trad}
% \otf{Simplified} {smpl}
% \otf{JIS1978}    {jp78}
% \otf{JIS1983}    {jp83}
% \otf{JIS1990}    {jp90}
% \otf{Expert}     {expt}
% \otf{NLC}        {nlck}
% \end{features}
%
% There have been many standards for how CJK ideographic
% glyphs are `supposed' to look. Some fonts will contain many alternate
% glyphs available in order to be able to display these gylphs
% correctly in whichever form is appropriate. Both \AAT\ and OpenType
% fonts support the following \feat{CJKShape} options:
% \opt{Traditional}, \opt{Simplified}, \opt{JIS1978}, \opt{JIS1983},
% \opt{JIS1990}, and \opt{Expert}. OpenType also supports the \opt{NLC} option.

% \begin{Xexample}[firstline=2]{ot-cjk-shape}{Different standards for CJK ideograph presentation.}
%   \LARGE\def\text{ 唖噛躯 妍并訝}
%   \fontspec{Hiragino Mincho Pro}
%   {\addfontfeature{CJKShape=Traditional}
%   \text }                          \\
%   {\addfontfeature{CJKShape=NLC}
%   \text }                          \\
%   {\addfontfeature{CJKShape=Expert}
%   \text }
% \end{Xexample}
%
% \subsection{Character width}\label{sec:CharacterWidth}
% Many Asian fonts are equipped with variously spaced characters for
% shoe-horning into their generally monospaced text.
% These are
% accessed through the \feat{CharacterWidth} feature.
%
% \begin{features}{CharacterWidth}
% \otf{Proportional}{pwid}
% \otf{Full}        {fwid}
% \otf{Half}        {hwid}
% \otf{Third}       {twid}
% \otf{Quarter}     {qwid}
% \otf{AlternateProportional}{palt}
% \otf{AlternateHalf}{halt}
% \end{features}
%
% Japanese alphabetic glyphs (in Hiragana or Katakana) may be typeset
% proportionally, to better fit horizontal measures, or monospaced, to
% fit into the rigid grid imposed by ideographic typesetting. In this
% latter case, there are also half-width forms for squeezing more kana
% glyphs (which are less complex than the kanji they are amongst) into
% a given block of space. The same features are given to roman letters
% in Japanese fonts, for typesetting foreign words in the same style
% as the surrounding text.
%
% \begin{Xexample}[firstline=2]{charwdprop}{Proportional or fixed width forms.}
%   \def\texta{ようこそ}\def\textb{ワカヨタレソ}
%   \def\test{\makebox[2cm][l]{\texta}%
%             \makebox[2.5cm][l]{\textb}%
%             \makebox[2.5cm][l]{abcdef}}
%   \fontspec{Hiragino Mincho Pro}
%   {\addfontfeature{CharacterWidth=Proportional}\test}\\
%   {\addfontfeature{CharacterWidth=Full}\test}\\
%   {\addfontfeature{CharacterWidth=Half}\test}
% \end{Xexample}
%
% The same situation occurs with numbers, which are provided in
% increasingly illegible compressed forms seen in \exref{charwd}.
%
% \begin{Xexample}[firstline=2]{charwd}{Numbers can be compressed significantly.}
%   \centering
%   \fontspec[Renderer=AAT]{Hiragino Mincho Pro}
%   {\addfontfeature{CharacterWidth=Full}
%    ---12321---}\\
%   {\addfontfeature{CharacterWidth=Half}
%    ---1234554321---}\\
%   {\addfontfeature{CharacterWidth=Third}
%    ---123456787654321---}\\
%   {\addfontfeature{CharacterWidth=Quarter}
%    ---12345678900987654321---}
% \end{Xexample}
%
% \subsection{Vertical typesetting}
%
% TODO!
%
%
% \subsection{OpenType scripts and languages}\label{sec:ot}
%
% Fonts that include glyphs for various scripts and languages may contain different font features for the different character sets and languages they support, and different font features may behave differently depending on the script or language chosen.
% When multilingual fonts are used, it is important to select which language
% they are being used for, and more importantly what script is being used.
%
% The `script' refers to the alphabet in use; for example, both English
% and French use the Latin script. Similarly, the Arabic script can be used
% to write in both the Arabic and Persian languages.
%
% The
% \feat{Script} and \feat{Language} features are used to designate this information. The possible options are
% tabulated in \vref{tab:ot-scpt} and \vref{tab:ot-lang},
% respectively. When a script or language is requested that is not
% supported by the current font, a warning is printed in the console output.
%
% Because these font features can
% change which features are able to be selected for the font, they are automatically selected
% by \pkg{fontspec} before all others and, if \XeTeX\ is being used, will
% specifically select the \opt{OpenType}
% renderer for this font, as described in \vref{sec:renderer}.
%
%
% \subsubsection{\feat{Script} and \feat{Language} examples}
%
% In the examples shown in \exref{script-lang},
% the Code2000 font\note{\url{http://www.code2000.net/}}
% is used to typeset various input texts with and without the OpenType Script
% applied for various alphabets.
% The text is only rendered correctly in the second case;
% many examples of incorrect diacritic spacing as
% well as a lack of contextual ligatures and rearrangement can be
% seen.
% Thanks to \name{Jonathan Kew}, \name{Yves Codet} and
% \name{Gildas Hamel} for their contributions towards these examples.
%
% \begin{Xexample}[firstline=14,lastline=23]{script-lang}{An example of various Scripts and Languages.}
% \def\testfeature#1#2{%^^A
%   \fontspec{\examplefont}#2 & \fontspec[#1]{\examplefont}#2\\[1ex]}
% \def \examplefont{Code2000}
% \def \arabictext{العربي}
% \def \devanagaritext{हिन्दी}
% \def \bengalitext{লেখ}
% \def \gujaratitext{મર્યાદા-સૂચક નિવેદન}
% \def \malayalamtext{നമ്മുടെ പാരബര്യ}
% \def \gurmukhitext{ਆਦਿ ਸਚੁ ਜੁਗਾਦਿ ਸਚੁ}
% \def \tamiltext{தமிழ் தேடி}
% \def \hebrewtext{רִדְתָּֽהּ}
% \def \vietnamesetext{cấp số mỗi}
% \begin{tabular}{r@{\quad}l}
%   \testfeature{Script=Arabic}{\arabictext}
%   \testfeature{Script=Devanagari}{\devanagaritext}
%   \testfeature{Script=Bengali}{\bengalitext}
%   \testfeature{Script=Gujarati}{\gujaratitext}
%   \testfeature{Script=Malayalam}{\malayalamtext}
%   \testfeature{Script=Gurmukhi}{\gurmukhitext}
%   \testfeature{Script=Tamil}{\tamiltext}
%   \testfeature{Script=Hebrew}{\hebrewtext}
%   \def\examplefont{Doulos SIL}
%   \testfeature{Language=Vietnamese}{\vietnamesetext}
% \end{tabular}
% \end{Xexample}
%
%
%
% \subsubsection{Defining new scripts and languages}
%
% \DescribeMacro{\newfontscript}
% \DescribeMacro{\newfontlanguage}
% While the scripts and languages listed in \ref{tab:ot-scpt} and \ref{tab:ot-lang}
% are intended to be comprehensive, there may be some missing; alternatively,
% you might wish to use different names to access scripts/languages that are
% already listed.
% Adding scripts and languages can be performed with the \cmd\newfontscript\
% and \cmd\newfontlanguage\ commands. For example,
% \begin{Verbatim}
%   \newfontscript{Arabic}{arab}
%   \newfontlanguage{Zulu}{ZUL}
% \end{Verbatim}
% The first argument is the \pkg{fontspec} name, the second the OpenType
% tag. The advantage to using these commands rather than \cmd\newfontfeature\
% (see \vref{sec:newfeatures}) is the error-checking that is performed when
% the script or language is requested.
%
% \begin{table}[!hbp]
%   \caption{Defined \opt{Script}s for OpenType fonts. Aliased names are shown in adjacent positions marked with red pilcrows ({\sffamily\textcolor{red}{\P}}).}
%   \label{tab:ot-scpt}
% \def\dup{\makebox[0pt][r]{\textcolor{red}{\P}}}
% \setlength\columnseprule{0pt}
%   \hrule
%   \begin{multicols}{4}\setlength\parindent{0pt}
%     \sffamily\scriptsize
%     Arabic \par Armenian \par Balinese \par Bengali \par Bopomofo \par Braille \par Buginese \par Buhid \par Byzantine Music \par Canadian Syllabics \par Cherokee \par \dup CJK \par \dup CJK Ideographic \par Coptic \par Cypriot Syllabary \par Cyrillic \par Default \par Deseret \par Devanagari \par Ethiopic \par Georgian \par Glagolitic \par Gothic \par Greek \par Gujarati \par Gurmukhi \par Hangul Jamo \par Hangul \par Hanunoo \par Hebrew \par \dup Hiragana and Katakana \par \dup Kana \par Javanese \par Kannada \par Kharosthi \par Khmer \par Lao \par Latin \par Limbu \par Linear B \par Malayalam \par \dup Math \par \dup Maths \par Mongolian \par Musical Symbols \par Myanmar \par N'ko \par Ogham \par Old Italic \par Old Persian Cuneiform \par Oriya \par Osmanya \par Phags-pa \par Phoenician \par Runic \par Shavian \par Sinhala \par Sumero-Akkadian Cuneiform \par Syloti Nagri \par Syriac \par Tagalog \par Tagbanwa \par Tai Le \par Tai Lu \par Tamil \par Telugu \par Thaana \par Thai \par Tibetan \par Tifinagh \par Ugaritic Cuneiform \par Yi
%   \end{multicols}
%   \hrule
% \end{table}
%
% \begin{table}[p]
%   \vspace*{-3cm}
%   \hspace{-3cm}
%   \def\dup{\makebox[0pt][r]{\textcolor{red}{\P}}}
%   \begin{minipage}{\linewidth+4cm}
%   \caption{Defined \opt{Language}s for OpenType fonts. Aliased names are shown in adjacent positions marked with red pilcrows ({\sffamily\textcolor{red}{\P}}).}
%   \label{tab:ot-lang}
%   \setlength\columnseprule{0pt}
%   \hrule
%   \begin{multicols}{6}
%     \everypar{\setlength\parindent{0pt}\setlength\hangindent{2em}}
%     \sffamily\footnotesize\raggedright
%     Abaza \par Abkhazian \par Adyghe \par Afrikaans \par Afar \par Agaw \par Altai \par Amharic \par Arabic \par Aari \par Arakanese \par Assamese \par Athapaskan \par Avar \par Awadhi \par Aymara \par Azeri \par Badaga \par Baghelkhandi \par Balkar \par Baule \par Berber \par Bench \par Bible Cree \par Belarussian \par Bemba \par Bengali \par Bulgarian \par Bhili \par Bhojpuri \par Bikol \par Bilen \par Blackfoot \par Balochi \par Balante \par Balti \par Bambara \par Bamileke \par Breton \par Brahui \par Braj Bhasha \par Burmese \par Bashkir \par Beti \par Catalan \par Cebuano \par Chechen \par Chaha Gurage \par Chattisgarhi \par Chichewa \par Chukchi \par Chipewyan \par Cherokee \par Chuvash \par Comorian \par Coptic \par Cree \par Carrier \par Crimean Tatar \par Church Slavonic \par Czech \par Danish \par Dargwa \par Woods Cree \par German \par Default \par Dogri \par Divehi \par Djerma \par Dangme \par Dinka \par Dungan \par Dzongkha \par Ebira \par Eastern Cree \par Edo \par Efik \par Greek \par English \par Erzya \par Spanish \par Estonian \par Basque \par Evenki \par Even \par Ewe \par French Antillean \par \dup Farsi \par \dup Parsi \par \dup Persian \par Finnish \par Fijian \par Flemish \par Forest Nenets \par Fon \par Faroese \par French \par Frisian \par Friulian \par Futa \par Fulani \par Ga \par Gaelic \par Gagauz \par Galician \par Garshuni \par Garhwali \par Ge'ez \par Gilyak \par Gumuz \par Gondi \par Greenlandic \par Garo \par Guarani \par Gujarati \par Haitian \par Halam \par Harauti \par Hausa \par Hawaiin \par Hammer-Banna \par Hiligaynon \par Hindi \par High Mari \par Hindko \par Ho \par Harari \par Croatian \par Hungarian \par Armenian \par Igbo \par Ijo \par Ilokano \par Indonesian \par Ingush \par Inuktitut \par Irish \par Irish Traditional \par Icelandic \par Inari Sami \par Italian \par Hebrew \par Javanese \par Yiddish \par Japanese \par Judezmo \par Jula \par Kabardian \par Kachchi \par Kalenjin \par Kannada \par Karachay \par Georgian \par Kazakh \par Kebena \par Khutsuri Georgian \par Khakass \par Khanty-Kazim \par Khmer \par Khanty-Shurishkar \par Khanty-Vakhi \par Khowar \par Kikuyu \par Kirghiz \par Kisii \par Kokni \par Kalmyk \par Kamba \par Kumaoni \par Komo \par Komso \par Kanuri \par Kodagu \par Korean Old Hangul \par Konkani \par Kikongo \par Komi-Permyak \par Korean \par Komi-Zyrian \par Kpelle \par Krio \par Karakalpak \par Karelian \par Karaim \par Karen \par Koorete \par Kashmiri \par Khasi \par Kildin Sami \par Kui \par Kulvi \par Kumyk \par Kurdish \par Kurukh \par Kuy \par Koryak \par Ladin \par Lahuli \par Lak \par Lambani \par Lao \par Latin \par Laz \par L-Cree \par Ladakhi \par Lezgi \par Lingala \par Low Mari \par Limbu \par Lomwe \par Lower Sorbian \par Lule Sami \par Lithuanian \par Luba \par Luganda \par Luhya \par Luo \par Latvian \par Majang \par Makua \par Malayalam Traditional \par Mansi \par Marathi \par Marwari \par Mbundu \par Manchu \par Moose Cree \par Mende \par Me'en \par Mizo \par Macedonian \par Male \par Malagasy \par Malinke \par Malayalam Reformed \par Malay \par Mandinka \par Mongolian \par Manipuri \par Maninka \par Manx Gaelic \par Moksha \par Moldavian \par Mon \par Moroccan \par Maori \par Maithili \par Maltese \par Mundari \par Naga-Assamese \par Nanai \par Naskapi \par N-Cree \par Ndebele \par Ndonga \par Nepali \par Newari \par Nagari \par Norway House Cree \par Nisi \par Niuean \par Nkole \par N'ko \par Dutch \par Nogai \par Norwegian \par Northern Sami \par Northern Tai \par Esperanto \par Nynorsk \par Oji-Cree \par Ojibway \par Oriya \par Oromo \par Ossetian \par Palestinian Aramaic \par Pali \par Punjabi \par Palpa \par Pashto \par Polytonic Greek \par Pilipino \par Palaung \par Polish \par Provencal \par Portuguese \par Chin \par Rajasthani \par R-Cree \par Russian Buriat \par Riang \par Rhaeto-Romanic \par Romanian \par Romany \par Rusyn \par Ruanda \par Russian \par Sadri \par Sanskrit \par Santali \par Sayisi \par Sekota \par Selkup \par Sango \par Shan \par Sibe \par Sidamo \par Silte Gurage \par Skolt Sami \par Slovak \par Slavey \par Slovenian \par Somali \par Samoan \par Sena \par Sindhi \par Sinhalese \par Soninke \par Sodo Gurage \par Sotho \par Albanian \par Serbian \par Saraiki \par Serer \par South Slavey \par Southern Sami \par Suri \par Svan \par Swedish \par Swadaya Aramaic \par Swahili \par Swazi \par Sutu \par Syriac \par Tabasaran \par Tajiki \par Tamil \par Tatar \par TH-Cree \par Telugu \par Tongan \par Tigre \par Tigrinya \par Thai \par Tahitian \par Tibetan \par Turkmen \par Temne \par Tswana \par Tundra Nenets \par Tonga \par Todo \par Turkish \par Tsonga \par Turoyo Aramaic \par Tulu \par Tuvin \par Twi \par Udmurt \par Ukrainian \par Urdu \par Upper Sorbian \par Uyghur \par Uzbek \par Venda \par Vietnamese \par Wa \par Wagdi \par West-Cree \par Welsh \par Wolof \par Tai Lue \par Xhosa \par Yakut \par Yoruba \par Y-Cree \par Yi Classic \par Yi Modern \par Chinese Hong Kong \par Chinese Phonetic \par Chinese Simplified \par Chinese Traditional \par Zande \par Zulu
%   \end{multicols}
%   \hspace{4pt}
%   \hrule
%  \end{minipage}
% \end{table}
%
%
%
% \part{\LuaTeX-only font features}
% \label{sec:luatex-features}
%
% \section{OpenType font feature files}
%
% An OpenType font feature file is a plain text file describing OpenType layout
% feature of a font in a human-readable format. The syntax of OpenType feature
% files is defined by Adobe\note{\url{http://www.adobe.com/devnet/opentype/afdko/topic_feature_file_syntax.html}}.
%
% Feature files can be used to add or customize OpenType features of a font on
% the fly without editing the font file itself.
%
% Adding a new OpenType feature is as creating a plain text file defining
% the new feature and then loading it by passing its name or path to
% \feat{FeatureFile}, then OpenType features defined in the file can be
% activated as usual.
%
% For example, when adding one of the default features like \texttt{kern}
% or \texttt{liga}, no special activation is needed. On the other hand,
% an optional feature like \texttt{onum} or \texttt{smcp} will be
% activated when old style numbers or small capitals are activated,
% respectively. However, OpenType feature in the feature file can have any
% and that can be used to selectively activate the feature; for example
% defining a ligature feature called \texttt{mlig} and then activating it
% using \feat{RawFeature} option without activating other ligatures in the
% font.
%
% Figure~\ref{fig:featurefile} shows an example feature file. The first two
% lines set the script and language under which the defined features will be
% available, which the default language in both default and Latin scripts,
% respectively.
%
% Then it defines a \texttt{liga} feature, which is a glyph substitution
% feature. The names starting with backslash are glyph names that is to be
% substituted and while the leading backslash is optional, it is used to
% escape glyph names when they interfere with preserved keywords. It should
% also be noted that glyph names are font specific and the same glyph can be
% named differently in different fonts.
%
% Glyph positioning features like kerning can be defined in a similar way,
% but instead of the keyword \texttt{sub(stitute)} the keyword
% \texttt{pos(ition)} is used instead. Figure~\ref{fig:featurefile} shows
% an example of adding kerning between \texttt{AY} and \texttt{ay}\note{
% The kerning is expressed in font design units which are fractions of em
% depending on the \emph{units per em} value of the font, usually 1000 for
% PostScript fonts and 2048 for TrueType fonts.}.
%
% Lines starting with \verb|#| are comments and will be ignored.
%
% An OpenType feature file can have any number of features and can have a
% mix of substitution and positioning features, please refer to the full
% feature file specification for further documentation.
%
% \begin{figure}
% \caption{An example font feature file.}
% \label{fig:featurefile}
% \hrule
% \begin{Verbatim}
% languagesystem DFLT dflt;
% languagesystem latn dflt;
%
% # Ligatures
% feature liga {
%   sub \f \i by \fi;
%   sub \f \l by \fl;
% } liga;
%
% # Kerning
% feature kern {
%  pos \A \Y -200;
%  pos \a \y -80;
% } kern;
% \end{Verbatim}
% \hrule
% \end{figure}
%
% \part{Fonts and features with \XeTeX}
% \label{sec:xetex-features}
%
%
%
%
% \section{\XeTeX-only font features}
%
% The features described here are available for any font
% selected by \pkg{fontspec}.
%
% \subsection{Mapping}
% \label{sec:mapping}
%
% \feat{Mapping} enables a \XeTeX\ text-mapping scheme, shown in \exref{mapping}.
%
% \begin{Xexample}{mapping}{\XeTeX's \feat{Mapping} feature.}
%   \fontspec{Cochin}[Mapping=tex-text]
%   ``!`A small amount of---text!''
% \end{Xexample}
%
% Using the |tex-text| mapping is also equivalent to writing |Ligatures=TeX|.
% The use of the latter syntax is recommended for better compatibility with
% \LuaTeX\ documents.
%
%
% \subsection{Letter spacing}
% Letter spacing, or tracking, is the term given to adding (or subtracting) a small amount of horizontal space in between adjacent characters. It is specified with the \feat{LetterSpace}, which takes a numeric argument,
% shown in \exref{tracking}.
%
% The letter spacing parameter is a normalised additive factor (not a scaling factor); it is defined as a percentage of the font size. That is, for a 10\,pt font, a letter spacing parameter of `|1.0|' will add 0.1\,pt between each letter.
%
% \begin{Xexample}{tracking}{The \feat{LetterSpace} feature.}
%   \fontspec{Didot}
%   \addfontfeature{LetterSpace=0.0}
%   USE TRACKING FOR DISPLAY CAPS TEXT \\
%   \addfontfeature{LetterSpace=2.0}
%   USE TRACKING FOR DISPLAY CAPS TEXT
% \end{Xexample}
%
% This functionality \emph{should not be used for lowercase text}, which is spacing correctly to begin with, but it can be very useful, in small amounts, when setting small caps or all caps titles.
% Also see the OpenType \opt{Uppercase}
% option of the \feat{Letters} feature (\vref*{sec:letters}).
%
% \subsection{Different font technologies: \AAT\ and OpenType}\label{sec:renderer}
%
% \XeTeX\ supports two rendering technologies for typesetting, selected with
% the \feat{Renderer} font feature. The first, \opt{AAT}, is
% that provided (only) by \MacOSX\ itself. The second, \opt{OpenType},
% is an open source OpenType interpreter.
% \note{v2.4: This was called `\texttt{ICU}' in previous versions of \XeTeX\ and \pkg{fontspec}.
% Backwards compatibility is preserved.}
% It provides greater support for
% OpenType features, notably contextual arrangement, over \opt{AAT}.
%
% In general, this feature will not need to be explicitly called: for OpenType
% fonts, the \opt{OpenType} renderer is used automatically, and for \AAT\ fonts,
% \opt{AAT} is chosen by default. Some fonts, however, will contain font tables
% for \emph{both} rendering technologies, such as the Hiragino Japanese fonts
% distributed with \MacOSX, and in these cases the choice may be required.
%
% Among some other font features only available through a specific renderer,
% \opt{OpenType} provides for the \feat{Script} and \feat{Language} features, which allow
% different font behaviour for different alphabets and languages; see \vref{sec:ot}
% for the description of these features. {\em Because these font features can
% change which features are able to be selected for the font instance, they are selected
% by \pkg{fontspec} before all others and will automatically and without warning
% select the \opt{OpenType} renderer.}
%
%
% \subsection{Optical font sizes} \label{sec:aat-opticalsize}
%
% Multiple Master fonts are parameterised over
% orthogonal font axes, allowing continuous selection along such
% features as weight, width, and optical size~(see \vref{sec:mm} for
% further details). Whereas an OpenType font will have only a few separate
% optical sizes, a Multiple Master font's optical size can be
% specified over a continuous range. Unfortunately, this flexibility makes
% it harder to create an automatic interface through \LaTeX, and the
% optical size for a Multiple Master font must always be specified
% explicitly.
% \begin{Verbatim}
%   \fontspec{Minion MM Roman}[OpticalSize=11]
%    MM optical size test                    \\
%   \fontspec{Minion MM Roman}[OpticalSize=47]
%    MM optical size test                    \\
%   \fontspec{Minion MM Roman}[OpticalSize=71]
%    MM optical size test                    \\
% \end{Verbatim}
%
%
%
%
% \section{\MacOSX's \AAT\ fonts}
% \label{sec:aat-features}
%
% \begin{quote}\itshape
% \textbf{Warning!}
% \XeTeX's implementation on \MacOSX\ is currently in a state of flux and the information contained below may well be wrong from 2013 onwards.
% There is a good chance that the features described in this section will not be available any more as \XeTeX's completes its transition to a cross-platform--only application.
% \end{quote}
%
% \MacOSX's font technology began life before the ubiquitous-OpenType era
% and revolved around the Apple-invented `\AAT' font format. This format
% had some advantages (and other disadvantages) but it never became widely
% popular in the font world.
%
% Nonetheless, this is the font format that was first supported by \XeTeX\
% (due to its pedigree on \MacOSX\ in the first place) and was the first
% font format supported by \pkg{fontspec}. A number of fonts distributed with
% \MacOSX\ are still in the \AAT\ format, such as `Skia'.
%
% \subsection{Ligatures}
%
% \feat{Ligatures} refer to the replacement of two separate characters
% with a specially drawn glyph for functional or \ae sthetic reasons.
% For \AAT\ fonts, you may choose from any combination of \opt{Required},
% \opt{Common}, \opt{Rare} (or \opt{Discretionary}), \opt{Logos}, \opt{Rebus},
% \opt{Diphthong}, \opt{Squared}, \opt{AbbrevSquared}, and \opt{Icelandic}.
%
% Some other Apple \AAT\ fonts have those `Rare' ligatures contained in
% the \opt{Icelandic} feature. Notice also that the old \TeX\ trick of
% splitting up a ligature with an empty brace pair does not work in
% \XeTeX; you must use a 0\,pt kern or \cs{hbox} (\eg, \cs{null}) to
% split the characters up if you do not want a ligature to be performed (the usual examples for when this might be desired are words like `shelf\null full').
%
% \subsection{Letters} \label{sec:aat-letters}
% The \opt{Letters} feature specifies how the letters in the current font
% will look. For \AAT\ fonts, you may choose from \opt{Normal},
% \opt{Uppercase}, \opt{Lowercase}, \opt{SmallCaps}, and
% \opt{InitialCaps}.
%
%
% \subsection{Numbers}
% The \feat{Numbers} feature defines how numbers will look in the
% selected font. For \AAT\ fonts, they may be a
% combination of \opt{Lining} or \opt{OldStyle} and \opt{Proportional} or
% \opt{Monospaced} (the latter is good for tabular material). The synonyms
% \opt{Uppercase} and \opt{Lowercase} are equivalent to \opt{Lining} and
% \opt{OldStyle}, respectively. The differences have been shown previously
% in \vref{sec:addfontfeatures}.
%
% \subsection{Contextuals} \label{sec:contextuals}
% This feature refers to glyph substitution that vary by their position;
% things like contextual swashes are implemented here.
% The options for \AAT\ fonts are
% \opt{WordInitial}, \opt{WordFinal} (\exref{wordcx}), \opt{LineInitial},
% \opt{LineFinal}, and \opt{Inner} (\exref{longsaat}, also called `non-final' sometimes). As
% non-exclusive selectors, like the ligatures, you can turn them off
% by prefixing their name with \opt{No}.
%
% \begin{Xexample}{wordcx}{Contextual glyph for the beginnings and ends of words.}
%   \newfontface\fancy{Hoefler Text Italic}
%       [Contextuals={WordInitial,WordFinal}]
%   \fancy where is all the vegemite
% \end{Xexample}
%
% \begin{Xexample}{longsaat}{A contextual feature for the `long s' can be convenient as the character does not need to be marked up explicitly.}
%   \fontspec{Hoefler Text}[Contextuals=Inner]
%   `Inner' swashes can \emph{sometimes}    \\
%    contain the archaic long~s.
% \end{Xexample}
%
%
%
% \subsection{Vertical position}
% The \feat{VerticalPosition} feature is used to access things like
% subscript (\opt{Inferior}) and superscript (\opt{Superior}) numbers and
% letters (and a small amount of punctuation, sometimes).
% The \opt{Ordinal} option is (supposed to be)
% contextually sensitive to only raise characters that appear directly
% after a number.
% These are shown in \exref{aat-supp}.
%
% \begin{Xexample}{aat-supp}{Vertical position for AAT fonts.}
%   \fontspec{Skia}
%    Normal
%   \fontspec{Skia}[VerticalPosition=Superior]
%    Superior
%   \fontspec{Skia}[VerticalPosition=Inferior]
%    Inferior                \\
%   \fontspec{Skia}[VerticalPosition=Ordinal]
%    1st 2nd 3rd 4th 0th 8abcde
% \end{Xexample}
%
% The \pkg{realscripts} package
% (also loaded by \pkg{xltxtra})
% redefines the \cmd\textsubscript\ and
% \cmd\textsuperscript\ commands to use the above font features,
% including for use in footnote labels.
%
% \subsection{Fractions}
% Many fonts come with the capability to typeset various forms of
% fractional material. This is accessed in \pkg{fontspec} with the
% \feat{Fractions} feature, which may be turned \opt{On} or \opt{Off}
% in both \AAT\ and OpenType fonts.
%
% In \AAT\ fonts, the `fraction slash' or solidus character, is
% to be used to create fractions. When \feat{Fractions} are turned
% \opt{On}, then only pre-drawn fractions will be used.
% See \exref{aat-frac}.
%
% Using the \opt{Diagonal} option (\AAT\ only), the font will attempt
% to create the fraction from superscript and subscript
% characters.
%
% \edef\caretcc{\the\catcode`\^}
% \catcode`\^=12\relax
% \begin{Xexample}{aat-frac}{Fractions in AAT fonts. The \texttt{\relax^^^^2044} glyph is the `fraction slash' that may be typed in \MacOSX\ with \textsc{opt+shift+1}; not shown literally here due to font contraints.}
%   \fontspec[Fractions=On]{Skia}
%    1{^^^^2044}2 \quad 5{^^^^2044}6 \\ % fraction slash
%    1/2 \quad 5/6    % regular  slash
%
%   \fontspec[Fractions=Diagonal]{Skia}
%          13579{^^^^2044}24680 \\ % fraction slash
%    \quad 13579/24680    % regular  slash
% \end{Xexample}
% \catcode`\^=\caretcc\relax
%
% Some (Asian fonts predominantly) also provide for the
% \opt{Alternate} feature shown in \exref{frac-alt}.
%
% \begin{Xexample}{frac-alt}{Alternate design of pre-composed fractions.}
%   \fontspec{Hiragino Maru Gothic Pro}
%    1/2 \quad 1/4 \quad 5/6 \quad 13579/24680 \\
%   \addfontfeature{Fractions=Alternate}
%    1/2 \quad 1/4 \quad 5/6 \quad 13579/24680
% \end{Xexample}
%
%
% \subsection{Variants}
% The \feat{Variant} feature takes a single numerical input for
% choosing different alphabetic shapes. Don't mind my fancy \exref{aat-var}
% \texttt{:)} I'm just looping through the nine~(\,!\,) variants of
% Zapfino.
%
% \begin{Xexample}[firstline=2,lastline=9]{aat-var}{Nine variants of Zapfino.}
%   \Huge \rule{0pt}{2cm}
%   \newcounter{var}
%   \whiledo{\value{var}<9}{%
%     \edef\1{%
%     \noexpand\fontspec[Variant=\thevar,
%       Color=0099\thevar\thevar]{Zapfino}}\1%
%     \makebox[0.75\width]{d}%
%     \stepcounter{var}}
%   \hspace*{2cm}
% \end{Xexample}
%
% See \vref{sec:newfeatures} for a way to assign names to variants,
% which should be done on a per-font basis.
%
% \subsection{Alternates}
%
% Selection of \feat{Alternate}s \emph{again}
% must be done numerically; see \exref{aat-alt}.
% See \vref{sec:newfeatures} for a way to assign names to alternates,
% which should be done on a per-font basis.
%
% \begin{Xexample}{aat-alt}{Alternate shape selection must be numerical.}
%   \fontspec{Hoefler Text Italic}[Alternate=0]
%    Sphinx Of Black Quartz, {\scshape Judge My Vow} \\
%   \fontspec{Hoefler Text Italic}[Alternate=1]
%    Sphinx Of Black Quartz, {\scshape Judge My Vow}
% \end{Xexample}
%
%
% \subsection{Style}
%
% The options of the \feat{Style} feature
% are defined in \AAT\ as one of the following: \opt{Display},
% \opt{Engraved}, \opt{IlluminatedCaps}, \opt{Italic},
% \opt{Ruby},\footnotemark\ \opt{TallCaps}, or \opt{TitlingCaps}.
% \footnotetext{`Ruby' refers to a small optical size, used in
% Japanese typography for annotations.}
%
% Typical examples for these features are shown in \ref{sec:ot-feat-style}.
%
%
%
%
%
%
% \subsection{CJK shape}
% There have been many standards for how CJK ideographic
% glyphs are `supposed' to look. Some fonts will contain many alternate
% glyphs in order to be able to display these gylphs
% correctly in whichever form is appropriate. Both \AAT\ and OpenType
% fonts support the following \feat{CJKShape} options:
% \opt{Traditional}, \opt{Simplified}, \opt{JIS1978}, \opt{JIS1983},
% \opt{JIS1990}, and \opt{Expert}. OpenType also supports the \opt{NLC} option.
%
% \subsection{Character width}
% See \vref{sec:CharacterWidth} for relevant examples; the features are
% the same between OpenType and \AAT\ fonts.
% \AAT\ also allows \feat{CharacterWidth}|=|\opt{Default} to return to
% the original font settings.
%
%


%
%
%
% \subsection{Vertical typesetting}
%
% TODO: improve!
%
% \XeTeX\ provides for vertical typesetting simply with the ability to rotate
% the individual glyphs as a font is used for typesetting, as shown in
% \exref{vert}.
%
% \begin{Xexample}[firstline=2]{vert}{Vertical typesetting.}
%   \def\verttext{共産主義者は}
%   \fontspec{Hiragino Mincho Pro}
%   \verttext
%
%   \fontspec{Hiragino Mincho Pro}[Renderer=AAT,Vertical=RotatedGlyphs]
%   \rotatebox{-90}{\verttext}% requires the graphicx package
% \end{Xexample}
%
% No actual provision is made for typesetting top-to-bottom
% languages; for an example of how to do this, see the vertical Chinese
% example provided in the \XeTeX\ documentation.
%
%
%
%
% \subsection{Diacritics}
% Diacritics are marks, such as the acute accent or the tilde, applied to letters; they usually indicate a change in pronunciation.
% In Arabic scripts, diacritics are used to indicate vowels.
% You may either choose
% to \opt{Show}, \opt{Hide} or \opt{Decompose} them in \AAT\ fonts.
% The \opt{Hide} option is for scripts such as Arabic which may be
% displayed either with or without vowel markings. E.g.,
% \verb|\fontspec[Diacritics=Hide]{...}|
%
% Some older fonts distributed with \MacOSX\ included `|O/|' \etc\ as shorthand for writing `\O' under the label of the \feat{Diacritics} feature. If you come across such fonts, you'll
% want to turn this feature off (imagine typing |hello/goodbye| and
% getting `hell\o goodbye' instead!) by decomposing the two characters
% in the diacritic into the ones you actually
% want. I recommend using
% the proper \LaTeX\ input conventions for obtaining such characters
% instead.
%
%
%
% \subsection{Annotation}
% Various Asian fonts are equipped with a more extensive range of
% numbers and numerals in different forms. These are accessed through
% the \feat{Annotation} feature (see \exref{aat-annot}) with the following
% options: \opt{Off},
% \opt{Box}, \opt{RoundedBox}, \opt{Circle}, \opt{BlackCircle},
% \opt{Parenthesis}, \opt{Period}, \opt{RomanNumerals}, \opt{Diamond},
% \opt{BlackSquare}, \opt{BlackRoundSquare}, and \opt{DoubleCircle}.
%
% \begin{Xexample}{aat-annot}{Various annotation forms.}
%   \fontspec{Hei Regular}
%    1 2 3 4 5 6 7 8 9                         \\
%   \fontspec{Hei Regular}[Annotation=Circle]
%    1 2 3 4 5 6 7 8 9                         \\
%   \fontspec{Hei Regular}[Annotation=Parenthesis]
%    1 2 3 4 5 6 7 8 9                         \\
%   \fontspec{Hei Regular}[Annotation=Period]
%    1 2 3 4 5 6 7 8 9
% \end{Xexample}
%
%
%
% \part{Programming interface}
%
% This is the beginning of some work to provide some hooks that use
% \pkg{fontspec} for various macro programming purposes.
%
%
% \section{Defining new features} \label{sec:newfeatures}
% This package cannot hope to contain every possible font
% feature. Three commands are provided for selecting font features
% that are not provided for out of the box. If you are using
% them a lot, chances are I've left something out, so please let me
% know.
%
% \DescribeMacro{\newAATfeature}
% New \AAT\ features may be created with this command:\par
% {\centering\cmd\newAATfeature\marg{feature}\marg{option}\marg{feature code}\marg{selector code}\par}\noindent
% Use the \XeTeX\ file \path{AAT-info.tex} to obtain the code numbers.
% See \exref{newAATfeat}.
%
% \begin{Xexample}{newAATfeat}{Assigning new \AAT\ features.}
%   \newAATfeature{Alternate}{HoeflerSwash}{17}{1}
%   \fontspec{Hoefler Text Italic}[Alternate=HoeflerSwash]
%    This is XeTeX by Jonathan Kew.
% \end{Xexample}
%
%
% \DescribeMacro{\newopentypefeature}
% New OpenType features may be created with this command:\par
% {\centering\cmd\newopentypefeature\marg{feature}\marg{option}\marg{feature tag}\par}
% The synonym \cs{newICUfeature} is deprecated.
%
% Here's what it would look like in practise:
% \begin{Verbatim}
% \newopentypefeature{Style}{NoLocalForms}{-locl}
% \end{Verbatim}
%
% \DescribeMacro{\newfontfeature}
% In case the above commands do not accommodate the desired font feature
% (perhaps a new \XeTeX\ feature that \pkg{fontspec} hasn't been updated
% to support), a command is provided to pass arbitrary input into the
% font selection string:\par
% {\centering\cmd{\newfontfeature}\marg{name}\marg{input string}\par}
%
% For example, Zapfino
% contains the feature `Avoid d-collisions'. To access it
% with this package, you could do some like that shown in \exref{avoidd}.
% (For some reason this feature doesn't appear to be working although \pkg{fontspec} is doing the right thing. To be investigated.)
%
% \begin{Xexample}{avoidd}{Assigning new arbitary features.}
%   \newfontfeature{AvoidD}{Special=Avoid d-collisions}
%   \newfontfeature{NoAvoidD}{Special=!Avoid d-collisions}
%   \fontspec{Zapfino}[AvoidD,Variant=1]
%    sockdolager rubdown               \\
%   \fontspec{Zapfino}[NoAvoidD,Variant=1]
%    sockdolager rubdown
% \end{Xexample}
%
% The advantage to using the \cmd\newAATfeature\ and \cmd\newopentypefeature\
% commands instead of \cs{newfontfeature} is that they check if the selected font actually contains the desired font
% feature at load time. By contrast, \cmd\newfontfeature\ will not give a warning
% for improper input.
%
% \section{Going behind \pkg{fontspec}'s back}
% Expert users may wish not to use \pkg{fontspec}'s feature handling at all,
% while still taking advantage of its \LaTeX\ font selection conveniences. The
% \feat{RawFeature} font feature allows literal \XeTeX\ font feature selection
% when you happen to have the OpenType feature tag memorised.
%
% \begin{Xexample}{raw}{Using raw font features directly.}
%   \fontspec{texgyrepagella-regular.otf}[RawFeature=+smcp]
%   Pagella small caps
% \end{Xexample}
%
% Multiple features can either be included in a single declaration:\par
% {\centering|[RawFeature=+smcp;+onum]|\par}
% \noindent or with multiple declarations:\par
% {\centering|[RawFeature=+smcp, RawFeature=+onum]|\par}
%
% \section{Renaming existing features \& options}
% \label{sec:aliasfontfeature}
%
% \DescribeMacro{\aliasfontfeature}
% If you don't like the name of a particular font feature,
% it may be aliased to another with the
% \cs{aliasfontfeature}\marg{existing name}\marg{new name} command,
% such as shown in \exref{alias}.
%
% \begin{Xexample}{alias}{Renaming font features.}
%   \aliasfontfeature{ItalicFeatures}{IF}
%   \fontspec{Hoefler Text}[IF = {Alternate=1}]
%   Roman Letters \itshape And Swash
% \end{Xexample}
%
% Spaces in feature (and option names, see below) \emph{are} allowed. (You may have
% noticed this already in the lists of OpenType scripts and languages).
%
% \DescribeMacro{\aliasfontfeatureoption}
% If you wish to change the name of a font feature option,
% it can be aliased to another with the command
% \cs{aliasfontfeatureoption}\marg{font feature}\marg{existing name}\marg{new name}, such as shown in \exref{aliasopt}.
%
% \begin{Lexample}{aliasopt}{Renaming font feature options.}
%   \aliasfontfeature{VerticalPosition}{Vert Pos}
%   \aliasfontfeatureoption{VerticalPosition}{ScientificInferior}{Sci Inf}
%   \fontspec{LinLibertine_R.otf}[Vert Pos=Sci Inf]
%    Scientific Inferior: 12345
% \end{Lexample}
%
% This example demonstrates an important point: when aliasing the feature
% options, the \emph{original} feature name must be used when declaring
% to which feature the option belongs.
%
% Only feature options that exist as sets of fixed strings may be altered in
% this way. That is, \opt{Proportional} can be aliased to \opt{Prop} in the
% \feat{Letters} feature, but \opt{550099BB} cannot be substituted for \opt{Purple}
% in a \feat{Color} specification. For this type of thing, the \cmd\newfontfeature\
% command should be used to declare a new, \eg, \feat{PurpleColor} feature:
% \begin{Verbatim}
%   \newfontfeature{PurpleColor}{color=550099BB}
% \end{Verbatim}
% Except that this example was written before support for named colours was
% implemented. But you get the idea.
%
% \section{Programming details}
% \label{sec:api}
%
% In some cases, it is useful to know what the \LaTeX\ font family
% of a specific \pkg{fontspec} font is. After a \cmd\fontspec-like
% command, this is stored inside the \cmd\l_fontspec_family_tl\ macro.
% Otherwise, \LaTeX's own \cmd\f@family\ macro can be useful here,
% too.
% The raw \TeX\ font that is defined is stored temporarily
% in \cmd{\l_fontspec_font}.
%
% The following commands in \pkg{expl3} syntax may be used
% for writing code that interfaces with fontspec-loaded fonts.
% All of the following conditionals also exist with |T| and |F|
% as well as |TF| suffixes.
%
% \begin{macro}{\fontspec_if_fontspec_font:TF}
% Test whether the currently selected font has been loaded by fontspec.
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_aat_feature:nnTF}
% Test whether the currently selected font contains the \AAT\
% feature (|#1|,|#2|).
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_opentype:TF}
% Test whether the currently selected font is an OpenType font.
% Always true for \LuaTeX{} fonts.
% \end{macro}
%
% \begin{macro}{\fontspec_if_feature:nTF}
% Test whether the currently selected font contains the raw OpenType
% feature |#1|. E.g.: |\fontspec_if_feature:nTF {pnum} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
% \end{macro}
%
% \begin{macro}{\fontspec_if_feature:nnnTF}
% Test whether the currently selected font with raw OpenType script tag |#1| and raw OpenType language tag |#2| contains the raw OpenType feature tag |#3|. E.g.: |\fontspec_if_feature:nTF {latn} {ROM} {pnum} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
% \end{macro}
%
% \begin{macro}{\fontspec_if_script:nTF}
% Test whether the currently selected font contains the raw OpenType
% script |#1|. E.g.: |\fontspec_if_script:nTF {latn} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
% \end{macro}
%
% \begin{macro}{\fontspec_if_language:nTF}
% Test whether the currently selected font contains the raw OpenType language
% tag |#1|. E.g.: |\fontspec_if_language:nTF {ROM} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
% \end{macro}
%
% \begin{macro}{\fontspec_if_language:nnTF}
% Test whether the currently selected font contains the raw OpenType language
% tag |#2| in script |#1|. E.g.: |\fontspec_if_language:nnTF {cyrl} {SRB} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_current_script:nTF}
% Test whether the currently loaded font is using the specified raw
% OpenType script tag |#1|.
% \end{macro}
%
% \begin{macro}{\fontspec_if_current_language:nTF}
% Test whether the currently loaded font is using the specified raw
% OpenType language tag |#1|.
% \end{macro}
%
% \begin{macro}{\fontspec_set_family:Nnn}
% \darg{\LaTeX\ family}
% \darg{fontspec features}
% \darg{font name}
% Defines a new NFSS family from given \meta{features} and \meta{font},
% and stores the family name in the variable \meta{family}.
% This font family can then be selected with standard \LaTeX\ commands
% \cs{fontfamily}\marg{family}\cs{selectfont}.
% See the standard \pkg{fontspec} user commands for applications of this
% function.
% \end{macro}
%
% \begin{macro}{\fontspec_set_fontface:NNnn}
% \darg{primitive font}
% \darg{\LaTeX\ family}
% \darg{fontspec features}
% \darg{font name}
% Variant of the above in which the primitive \TeX\ font command is stored in
% the variable \meta{primitive font}.
% If a family is loaded (with bold and italic shapes) the primitive font
% command will only select the regular face.
% This feature is designed for \LaTeX\ programmers who need to
% perform subsequent font-related tests on the \meta{primitive font}.
% \end{macro}
%
%  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \part{The patching/improvement of \LaTeXe\ and other packages}
% \label{sec:patching}
%
% Derived originally from xltxtra, this package contains patches to various
% \LaTeX\ components and third-party packages to improve the default
% behaviour.
%
% \section{Inner emphasis}
% \label{sec:emph}
%
% \pkg{fixltx2e}'s method for checking for ``inner'' emphasis is a little fragile in \XeTeX, because
% font slant information might be missing from the font. Therefore, we use \LaTeX's NFSS
% information, which is more likely to be correct.
%
% \section{Unicode footnote symbols}
% By default \LaTeX\ defines symbolic footnote characters in terms of commands
% that don't resolve well; better results can be achieved by using specific Unicode characters or proper LICRs with the \pkg{xunicode} package.
%
% This problem is solved by defining \cs{@fnsymbol} in a similar manner to the \pkg{fixltx2e} package.
%
% \section{Verbatim}
% \label{sec:verb}
%
% Many verbatim mechanisms assume the existence of a `visible space' character that exists in the \textsc{ascii} space slot of the typewriter font. This character is known in Unicode as \unichar{2423}{box open}, which looks like this: `\verb*| |'.
%
% When a Unicode typewriter font is used, \LaTeX\ no longer prints visible spaces for the |verbatim*| environment and |\verb*| command. This problem is fixed by using the correct Unicode glyph, and the following packages are patched to do the same:
% \pkg{listings}, \pkg{fancyvrb}, \pkg{moreverb}, and \pkg{verbatim}.
%
% In the case that the typewriter font does not contain `\verb*| |', the Latin Modern Mono font is used as a fallback.
%
% \section{Discretionary hyphenation: \cmd\-}
% \label{sec:hyphen}
%
% \LaTeX\ defines the macro \cmd\-\ to insert discretionary hyphenation points.
% However, it is hard-coded in \LaTeX\ to use the hyphen |-| character. Since \pkg{fontspec}
% makes it easy to change the hyphenation character on a per font basis, it would
% be nice if \cmd\-\ adjusted automatically --- and now it does.
%
% \section{Commands for old-style and lining numbers}
%
% \DescribeMacro{\oldstylenums}
% \DescribeMacro{\liningnums}
% \LaTeX's definition of \cs{oldstylenums} relies on strange font encodings.
% We provide a \pkg{fontspec}-compatible alternative and while we're at it
% also throw in the reverse option as well. Use \cs{oldstylenums}\marg{text}
% to explicitly use old-style (or lowercase) numbers in \meta{text}, and
% the reverse for \cs{liningnums}\marg{text}.
%
% \StopEventually{}
%
% \clearpage
% \part{fontspec.sty and friends}
%
% Herein lie the implementation details of this package. Welcome!
% It was my first.
%
% \section{`Header' code}
%
% We will eventually load the correct version of the code according to which
% engine we're running. As we'll see later, there are some minor differences
% between what we have to do in \XeLaTeX\ and \LuaLaTeX.
%
% The \textsf{expl3} module is \texttt{fontspec}.
%    \begin{macrocode}
%<@@=fontspec>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*fontspec&!xetexx&!luatex>
%    \end{macrocode}
% But for now, this is the shared code.
%    \begin{macrocode}
\RequirePackage{expl3}[2011/09/05]
\RequirePackage{xparse}
\ExplSyntaxOn
%    \end{macrocode}
%
% Quick fix for lualatex-math:
%    \begin{macrocode}
\cs_if_exist:NF \lua_now_x:n
 { \cs_set_eq:NN \lua_now_x:n \directlua }
%    \end{macrocode}
%
%    Check engine and load specific modules. For Lua\TeX, load only
%    \pkg{luaotfload} which loads \pkg{luatexbase} and \pkg{lualibs} too.
%
%    \begin{macrocode}
\msg_new:nnn {fontspec} {cannot-use-pdftex}
 {
  The~ fontspec~ package~ requires~ either~ XeTeX~ or~ LuaTeX~ to~ function.
  \\\\
  You~ must~ change~ your~ typesetting~ engine~ to,~
    e.g.,~ "xelatex"~ or~ "lualatex"\\
  instead~ of~ plain~ "latex"~ or~ "pdflatex".
 }
\xetex_if_engine:F
 {
  \luatex_if_engine:TF
   {
    \RequirePackage{luaotfload}[2013/05/20]
    \RequireLuaModule{fontspec}
   }
   {
    \msg_fatal:nn {fontspec} {cannot-use-pdftex}
   }
 }
%    \end{macrocode}
%
%
% \subsection{expl3 tools}
%
%
%
%
% \subsection{Bits and pieces}
% \paragraph{Conditionals}
% \subparagraph{firsttime} As \cs{keys_set:nn} is run multiple times, some of its
% information storing only occurs once while we decide if the font family
% has been defined or not. When the later processing is occuring per-shape
% this no longer needs to happen; this is indicated by the `firsttime'
% conditional (initialised true).
%    \begin{macrocode}
\bool_new:N \l_@@_firsttime_bool
\bool_new:N \l_@@_nobf_bool
\bool_new:N \l_@@_noit_bool
\bool_new:N \l_@@_nosc_bool
%    \end{macrocode}
%
%    \begin{macrocode}
\bool_new:N \l_@@_tfm_bool
\bool_new:N \l_@@_atsui_bool
\bool_new:N \l_@@_ot_bool
\bool_new:N \l_@@_mm_bool
\bool_new:N \l_@@_graphite_bool
%    \end{macrocode}
% For dealing with legacy maths
%    \begin{macrocode}
\bool_new:N \g_@@_math_euler_bool
\bool_new:N \g_@@_math_lucida_bool
\bool_new:N \g_@@_pkg_euler_loaded_bool
%    \end{macrocode}
% For package options:
%    \begin{macrocode}
\bool_new:N \g_@@_cfg_bool
\bool_new:N \g_@@_math_bool
%    \end{macrocode}
% \paragraph{Counters}
%    \begin{macrocode}
\int_new:N \l_fontspec_script_int
\int_new:N \l_fontspec_language_int
\int_new:N \l_fontspec_strnum_int
%    \end{macrocode}
% \paragraph{Other variables}
%    \begin{macrocode}
\fp_new:N \l_@@_tmpa_fp
\fp_new:N \l_@@_tmpb_fp
\dim_new:N \l_@@_tmpa_dim
\dim_new:N \l_@@_tmpb_dim
\dim_new:N \l_@@_tmpc_dim
%    \end{macrocode}
%
%    \begin{macrocode}
\tl_set:Nx \c_colon_str { \tl_to_str:N : }
\cs_set:Npn \use_v:nnnnn #1#2#3#4#5 {#5}
\cs_set:Npn \use_iv:nnnnn #1#2#3#4#5 {#4}
%    \end{macrocode}
%
% Need these:
%    \begin{macrocode}
\cs_generate_variant:Nn \str_if_eq:nnTF {nv}
\cs_generate_variant:Nn \int_set:Nn {Nv}
\cs_generate_variant:Nn \tl_gset:Nn {cV}
\cs_generate_variant:Nn \keys_set:nn {nx}
\cs_generate_variant:Nn \keys_set_known:nnN {nx}
%    \end{macrocode}
%
% \begin{macro}{\@@_int_mult_truncate:Nn}
% Missing in expl3, IMO.
%    \begin{macrocode}
\cs_new:Nn \@@_int_mult_truncate:Nn
  {
    \int_set:Nn #1 { \__dim_eval:w #2 #1 \__dim_eval_end: }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Error/warning/info messages}
%
% Shorthands for messages:
%    \begin{macrocode}
\cs_new:Npn \@@_error:n     { \msg_error:nn     {fontspec} }
\cs_new:Npn \@@_error:nx    { \msg_error:nnx    {fontspec} }
\cs_new:Npn \@@_warning:n   { \msg_warning:nn   {fontspec} }
\cs_new:Npn \@@_warning:nx  { \msg_warning:nnx  {fontspec} }
\cs_new:Npn \@@_warning:nxx { \msg_warning:nnxx {fontspec} }
\cs_new:Npn \@@_info:n      { \msg_info:nn      {fontspec} }
\cs_new:Npn \@@_info:nx     { \msg_info:nnx     {fontspec} }
\cs_new:Npn \@@_info:nxx    { \msg_info:nnxx    {fontspec} }
\cs_new:Npn \@@_trace:n     { \msg_trace:nn     {fontspec} }
%    \end{macrocode}
%
% Errors:
%    \begin{macrocode}
\msg_new:nnn {fontspec} {no-size-info}
 {
  Size~ information~ must~ be~ supplied.\\
  For~ example,~ SizeFeatures={Size={8-12},...}.
 }
\msg_new:nnnn {fontspec} {font-not-found}
 {
  The~ font~ "#1"~ cannot~ be~ found.
 }
 {
  A~font~might~not~be~found~for~many~reasons.\\
  Check~the~spelling,~where~the~font~is~installed~etc.~etc.\\\\
  When~in~doubt,~ask~someone~for~help!
 }
\msg_new:nnnn {fontspec} {rename-feature-not-exist}
 {
  The~ feature~ #1~ doesn't~ appear~ to~ be~ defined.
 }
 {
  It~ looks~ like~ you're~ trying~ to~ rename~ a~ feature~ that~ doesn't~ exist.
 }
\msg_new:nnn {fontspec} {no-glyph}
 {
  '\l_fontspec_fontname_tl'~ does~ not~ contain~ glyph~ #1.
 }
\msg_new:nnnn {fontspec} {euler-too-late}
 {
  The~ euler~ package~ must~ be~ loaded~ BEFORE~ fontspec.
 }
 {
  fontspec~ only~ overwrites~ euler's~ attempt~ to~
  define~ the~ maths~ text~ fonts~ if~ fontspec~ is~
  loaded~ after~ euler.~ Type~ <return>~ to~ proceed~
  with~ incorrect~ \string\mathit,~ \string\mathbf,~ etc.
 }
\msg_new:nnnn {fontspec} {no-xcolor}
 {
  Cannot~ load~ named~ colours~ without~ the~ xcolor~ package.
 }
 {
  Sorry,~ I~ can't~ do~ anything~ to~ help.~ Instead~ of~ loading~
  the~ color~ package,~ use~ xcolor~ instead.~ It's~ better.
 }
\msg_new:nnnn {fontspec} {unknown-color-model}
 {
  Error~ loading~ colour~ `#1';~ unknown~ colour~ model.
 }
 {
  Sorry,~ I~ can't~ do~ anything~ to~ help.~ Please~ report~ this~ error~
  to~ my~ developer~ with~ a~ minimal~ example~ that~ causes~ the~ problem.
 }
%    \end{macrocode}
% Warnings:
%    \begin{macrocode}
\msg_new:nnn {fontspec} {addfontfeatures-ignored}
 {
  \string\addfontfeature (s)~ ignored;~
  it~ cannot~ be~ used~ with~ a~ font~ that~ wasn't~ selected~ by~ fontspec.
 }
\msg_new:nnn {fontspec} {feature-option-overwrite}
 {
  Option~ '#2'~ of~ font~ feature~ '#1'~ overwritten.
 }
\msg_new:nnn {fontspec} {script-not-exist-latn}
 {
  Font~ '\l_fontspec_fontname_tl'~ does~ not~ contain~ script~ '#1'.\\
  'Latin'~ script~ used~ instead.
 }
\msg_new:nnn {fontspec} {script-not-exist}
 {
  Font~ '\l_fontspec_fontname_tl'~ does~ not~ contain~ script~ '#1'.
 }
\msg_new:nnn {fontspec} {aat-feature-not-exist}
 {
  '\l_keys_key_tl=\l_keys_value_tl'~ feature~ not~ supported~
  for~ AAT~ font~ '\l_fontspec_fontname_tl'.
 }
\msg_new:nnn {fontspec} {aat-feature-not-exist-in-font}
 {
  AAT~ feature~ '\l_keys_key_tl=\l_keys_value_tl'~ (#1)~ not~ available~
  in~ font~ '\l_fontspec_fontname_tl'.
 }
\msg_new:nnn {fontspec} {icu-feature-not-exist}
 {
  '\l_keys_key_tl=\l_keys_value_tl'~ feature~ not~ supported~
  for~ OpenType~ font~ '\l_fontspec_fontname_tl'
 }
\msg_new:nnn {fontspec} {icu-feature-not-exist-in-font}
 {
  OpenType~ feature~ '\l_keys_key_tl=\l_keys_value_tl'~ (#1)~ not~ available~
  for~ font~ '\l_fontspec_fontname_tl'~
  with~ script~ '\l_@@_script_name_tl'~ and~ language~ '\l_@@_lang_name_tl'.
 }
\msg_new:nnn {fontspec} {no-opticals}
 {
  '\l_fontspec_fontname_tl'~ doesn't~ appear~ to~ have~ an~ Optical~ Size~ axis.
 }
\msg_new:nnn {fontspec} {language-not-exist}
 {
  Language~ '#1'~ not~ available~
  for~ font~ '\l_fontspec_fontname_tl'~
  with~ script~ '\l_@@_script_name_tl'.\\
  'Default'~ language~ used~ instead.
 }
\msg_new:nnn {fontspec} {only-xetex-feature}
 {
  Ignored~ XeTeX~ only~ feature:~ '#1'.
 }
\msg_new:nnn {fontspec} {only-luatex-feature}
 {
  Ignored~ LuaTeX~ only~ feature:~ '#1'.
 }
\msg_new:nnn {fontspec} {no-mapping}
 {
  Input~ mapping~ not~ (yet?)~ supported~ in~ LuaTeX.
 }
\msg_new:nnn {fontspec} {no-mapping-ligtex}
 {
  Input~ mapping~ not~ (yet?)~ supported~ in~ LuaTeX.\\
  Use~ "Ligatures=TeX"~ instead~ of~ "Mapping=tex-text".
 }
\msg_new:nnn {fontspec} {cm-default-obsolete}
 {
  The~ "cm-default"~ package~ option~ is~ obsolete.
 }
\msg_new:nnn {fontspec} {fakebold-only-xetex}
 {
  The~ "FakeBold"~ and~ "AutoFakeBold"~ options~ are~ only~ available~ with~ XeLaTeX.\\
  Option~ ignored.
 }
%    \end{macrocode}
% Info messages:
%    \begin{macrocode}
\msg_new:nnn {fontspec} {defining-font}
 {
  Font~ family~'\l_fontspec_family_tl'~ created~ for~ font~ '#2'~
  with~ options~ [\l_@@_all_features_clist].\\
  \\
  This~ font~ family~ consists~ of~ the~ following~ shapes:
  \l_fontspec_defined_shapes_tl
 }
\msg_new:nnn {fontspec} {no-font-shape}
 {
  Could~ not~ resolve~ font~ #1~ (it~ probably~ doesn't~ exist).
 }
\msg_new:nnn {fontspec} {set-scale}
 {
  \l_fontspec_fontname_tl\space scale ~=~ \l_@@_scale_tl.
 }
\msg_new:nnn {fontspec} {setup-math}
 {
  Adjusting~ the~ maths~ setup~ (use~ [no-math]~ to~ avoid~ this).
 }
\msg_new:nnn {fontspec} {no-scripts}
 {
  Font~ \l_fontspec_fontname_tl\space does~ not~ contain~ any~ OpenType~ `Script'~ information.
 }
\msg_new:nnn {fontspec} {opa-twice}
 {
  Opacity~ set~ twice,~ in~ both~ Colour~ and~ Opacity.\\
  Using~ specification~ "Opacity=#1".
 }
\msg_new:nnn {fontspec} {opa-twice-col}
 {
  Opacity~ set~ twice,~ in~ both~ Opacity~ and~ Colour.\\
  Using~ an~ opacity~ specification~ in~ hex~ of~ "#1/FF".
 }
\msg_new:nnn {fontspec} {bad-colour}
 {
  Bad~ colour~ declaration~ "#1".~
  Colour~ must~ be~ one~ of:\\
  *~ a~ named~ xcolor~ colour\\
  *~ a~ six-digit~ hex~ colour~ RRGGBB\\
  *~ an~ eight-digit~ hex~ colour~ RRGGBBTT~ with~ opacity
 }
%    \end{macrocode}
%
% \subsection{Option processing}
%
%    \begin{macrocode}
\DeclareOption{cm-default}
 { \@@_warning:n {cm-default-obsolete} }
\DeclareOption{math}{\bool_set_true:N \g_@@_math_bool}
\DeclareOption{no-math}{\bool_set_false:N \g_@@_math_bool}
\DeclareOption{config}{\bool_set_true:N \g_@@_cfg_bool}
\DeclareOption{no-config}{\bool_set_false:N \g_@@_cfg_bool}
\DeclareOption{quiet}
 {
  \msg_redirect_module:nnn { fontspec } { warning } { info }
  \msg_redirect_module:nnn { fontspec } { info } { none }
 }
\DeclareOption{silent}
 {
  \msg_redirect_module:nnn { fontspec } { warning } { none }
  \msg_redirect_module:nnn { fontspec } { info } { none }
 }
\ExecuteOptions{config,math}
\ProcessOptions*
%    \end{macrocode}
%
% \subsection{Packages}
%
% New for \LuaTeX, we load a new package called `\pkg{fontspec-patches}'
% designed to incorporate the hidden but useful parts of the old \pkg{xltxtra}
% package.
%    \begin{macrocode}
\RequirePackage{fontspec-patches}
%    \end{macrocode}
%
%    \begin{macrocode}
\luatex_if_engine:T { \RequirePackage{fontspec-luatex} \endinput }
\xetex_if_engine:T  { \RequirePackage{fontspec-xetex}  \endinput }
%    \end{macrocode}
%
%    \begin{macrocode}
%</fontspec&!xetexx&!luatex>
%    \end{macrocode}
%
% \section{The main package code}
%
% That was the driver, and now the fun starts.
%    \begin{macrocode}
%<*fontspec&(xetexx|luatex)>
\ExplSyntaxOn
%    \end{macrocode}
%
% \subsection{Encodings}
% Frank Mittelbach has recommended using the `\texttt{EU}$x$' family of font encodings
% to experiment with Unicode.
% Now that \XeTeX\ can find fonts in the |texmf| tree, the Latin Modern OpenType fonts
% can be used as the defaults. See the |euenc| collection of files for how this is implemented.
%    \begin{macrocode}
%<xetexx>\tl_set:Nn \g_fontspec_encoding_tl {EU1}
%<luatex>\tl_set:Nn \g_fontspec_encoding_tl {EU2}
\tl_set:Nn \rmdefault {lmr}
\tl_set:Nn \sfdefault {lmss}
\tl_set:Nn \ttdefault {lmtt}
\RequirePackage[\g_fontspec_encoding_tl]{fontenc}
\tl_set_eq:NN \UTFencname \g_fontspec_encoding_tl % for xunicode
%    \end{macrocode}
% Dealing with a couple of the problems introduced by \pkg{babel}:
%    \begin{macrocode}
\tl_set_eq:NN \cyrillicencoding \g_fontspec_encoding_tl
\tl_set_eq:NN \latinencoding    \g_fontspec_encoding_tl
\AtBeginDocument
 {
  \tl_set_eq:NN \cyrillicencoding \g_fontspec_encoding_tl
  \tl_set_eq:NN \latinencoding    \g_fontspec_encoding_tl
 }
%    \end{macrocode}
% That latin encoding definition is repeated to suppress font warnings.
% Something to do with \cmd\select@language\ ending up in the \texttt{.aux}
% file which is read at the beginning of the document.
%
% \paragraph{xunicode}
% Now we load \pkg{xunicode}, working around its internal \XeTeX\ check
% when under \LuaTeX.
%    \begin{macrocode}
%<xetexx>\RequirePackage{xunicode}
%<*luatex>
\cs_set_eq:NN \fontspec_tmp: \XeTeXpicfile
\cs_set:Npn \XeTeXpicfile {}
\RequirePackage{xunicode}
\cs_set_eq:NN \XeTeXpicfile \fontspec_tmp:
%</luatex>
%    \end{macrocode}
%
%
% \subsection{User commands}\label{sec:codeuser}
% This section contains the definitions of the commands detailed in
% the user documentation.  Only the `top level' definitions of the
% commands are contained herein; they all use or define macros which
% are defined or used later on in \vref{sec:codeinternal}.
%
% \subsubsection{Helper macros for argument mangling}
%    \begin{macrocode}
\cs_new:Nn \@@_pass_args:nnn
 {
  \IfNoValueTF {#2}
   { \@@_post_arg:w {#1} {#3} }
   { #1 {#2} {#3} }
 }
\NewDocumentCommand \@@_post_arg:w { m m O{} }
 { #1 {#3} {#2} }
%    \end{macrocode}
%
% \subsubsection{Font selection}
% \begin{macro}{\fontspec}
%   This is the main command of the package that
%   selects fonts with various features. It takes two arguments: the
%   font name and the optional requested features of that
%   font. Then this new font family is selected.
%    \begin{macrocode}
\NewDocumentCommand \fontspec { o m }
 { \@@_pass_args:nnn \@@_fontspec:nn {#1} {#2} }

\cs_new:Nn \@@_fontspec:nn
 {
  \fontencoding {\g_fontspec_encoding_tl}
  \fontspec_set_family:Nnn \f@family {#1}{#2}
  \selectfont
  \ignorespaces
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\setmainfont}
% \begin{macro}{\setsansfont}
% \begin{macro}{\setmonofont}
%     The following three macros perform equivalent operations setting
%     the default font for a
%     particular family: `roman', sans serif, or typewriter
%     (monospaced). I end them with |\normalfont| so that if they're
%     used in the document, the change registers immediately.
%    \begin{macrocode}
\DeclareDocumentCommand \setmainfont { o m }
 { \@@_pass_args:nnn \@@_setmainfont:nn {#1} {#2} }

\cs_new:Nn \@@_setmainfont:nn
 {
  \fontspec_set_family:Nnn \rmdefault {#1}{#2}
  \normalfont
  \ignorespaces
 }

\DeclareDocumentCommand \setsansfont { o m }
 { \@@_pass_args:nnn \@@_setsansfont:nn {#1} {#2} }

\cs_new:Nn \@@_setsansfont:nn
 {
  \fontspec_set_family:Nnn \sfdefault {#1}{#2}
  \normalfont
  \ignorespaces
 }

\DeclareDocumentCommand \setmonofont { o m }
 { \@@_pass_args:nnn \@@_setmonofont:nn {#1} {#2} }

\cs_new:Nn \@@_setmonofont:nn
 {
  \fontspec_set_family:Nnn \ttdefault {#1}{#2}
  \normalfont
  \ignorespaces
 }
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
%
%
% \begin{macro}{\setromanfont}
% This is the old name for \cs{setmainfont}, retained
% for backwards compatibility.
%    \begin{macrocode}
\cs_set_eq:NN \setromanfont \setmainfont
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\setmathrm}
% \begin{macro}{\setmathsf}
% \begin{macro}{\setboldmathrm}
% \begin{macro}{\setmathtt}
% These commands are analogous to \cmd\setmainfont\ and others,
% but for selecting the font used for \cmd\mathrm, \etc. They
% can only be used in the preamble of the
% document. \cmd\setboldmathrm\ is used for specifying which
% fonts should be used in \cmd\boldmath.
%    \begin{macrocode}
\tl_new:N \g_@@_mathrm_tl
\tl_new:N \g_@@_bfmathrm_tl
\tl_new:N \g_@@_mathsf_tl
\tl_new:N \g_@@_mathtt_tl
\DeclareDocumentCommand \setmathrm { o m }
 { \@@_pass_args:nnn \@@_setmathrm:nn {#1} {#2} }

\cs_new:Nn \@@_setmathrm:nn
 {
  \fontspec_set_family:Nnn \g_@@_mathrm_tl {#1} {#2}
 }

\DeclareDocumentCommand \setboldmathrm { o m }
 { \@@_pass_args:nnn \@@_setboldmathrm:nn {#1} {#2} }

\cs_new:Nn \@@_setboldmathrm:nn
 {
  \fontspec_set_family:Nnn \g_@@_bfmathrm_tl {#1} {#2}
 }

\DeclareDocumentCommand \setmathsf { o m }
 { \@@_pass_args:nnn \@@_setmathsf:nn {#1} {#2} }

\cs_new:Nn \@@_setmathsf:nn
 {
  \fontspec_set_family:Nnn \g_@@_mathsf_tl {#1} {#2}
 }

\DeclareDocumentCommand \setmathtt { o m }
 { \@@_pass_args:nnn \@@_setmathtt:nn {#1} {#2} }

\cs_new:Nn \@@_setmathtt:nn
 {
  \fontspec_set_family:Nnn \g_@@_mathtt_tl {#1} {#2}
 }
\@onlypreamble\setmathrm
\@onlypreamble\setboldmathrm
\@onlypreamble\setmathsf
\@onlypreamble\setmathtt
%    \end{macrocode}
% If the commands above are not executed, then \cmd\rmdefault\ (\etc)
% will be used.
%    \begin{macrocode}
\tl_set:Nn \g_@@_mathrm_tl {\rmdefault}
\tl_set:Nn \g_@@_mathsf_tl {\sfdefault}
\tl_set:Nn \g_@@_mathtt_tl {\ttdefault}
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
% \end{macro}
%
% \begin{macro}{\newfontfamily}
% \begin{macro}{\newfontface}
%   This macro takes the arguments of \cs{fontspec} with a prepended
%   \meta{instance cmd}. This command is used
%   when a specific font instance needs to be referred to repetitively
%   (\eg, in a section heading) since continuously calling
%   \cs{fontspec_select:nn} is inefficient because it must parse the
%   option arguments every time.
%
%   \cs{fontspec_select:nn} defines a font family and saves its name in
%   \cs{l_fontspec_family_tl}. This family is then used in a typical NFSS \cmd\fontfamily\
%   declaration, saved in the macro name specified.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontfamily { m o m }
 { \@@_pass_args:nnn { \@@_newfontfamily:Nnn #1 } {#2} {#3} }

\cs_new:Nn \@@_newfontfamily:Nnn
 {
  \fontspec_set_family:cnn { g_@@_ \cs_to_str:N #1 _family } {#2} {#3}
  \use:x
   {
    \exp_not:N \DeclareRobustCommand \exp_not:N #1
     {
      \exp_not:N \fontencoding {\g_fontspec_encoding_tl}
      \exp_not:N \fontfamily { \use:c {g_@@_ \cs_to_str:N #1 _family} } \exp_not:N \selectfont
     }
   }
 }
%    \end{macrocode}
% \cmd\newfontface\ uses the fact that if the argument to \feat{BoldFont}, etc., is empty (\ie, |BoldFont={}|), then no bold font is searched for.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontface { m o m }
 { \@@_pass_args:nnn { \@@_newfontface:Nnn #1 } {#2} {#3} }

\cs_new:Nn \@@_newfontface:Nnn
 {
  \newfontfamily #1 [ BoldFont={},ItalicFont={},SmallCapsFont={},#2 ] {#3}
 }
%    \end{macrocode}
% \end{macro} \end{macro}
%
% \subsubsection{Font feature selection}
%
% \begin{macro}{\defaultfontfeatures}
%   This macro takes one argument that consists of all of feature
%   options that will be applied by default to all subsequent
%   \cs{fontspec}, et al., commands. It stores its value in
%   \cs{g_fontspec_default_fontopts_tl} (initialised empty), which is
%   concatenated with the individual macro choices in the
%   [...] macro.
%    \begin{macrocode}
\clist_new:N \g_@@_default_fontopts_clist
\prop_new:N \g_@@_fontopts_prop
%    \end{macrocode}
%
%    \begin{macrocode}
\DeclareDocumentCommand \defaultfontfeatures { t+ o m }
 {
  \IfNoValueTF {#2}
   { \@@_set_default_features:nn {#1} {#3} }
   { \@@_set_font_default_features:nnn {#1} {#2} {#3} }
  \ignorespaces
 }
\cs_new:Nn \@@_set_default_features:nn
 {
  \IfBooleanTF {#1} \clist_put_right:Nn \clist_set:Nn
   \g_@@_default_fontopts_clist {#2}
 }
%    \end{macrocode}
% The optional argument specifies a font identifier.
% Branch for either (a)~single token input such as \verb|\rmdefault|, or (b)~otherwise assume its a fontname.
% In that case, strip spaces and file extensions and lower-case to ensure consistency.
%    \begin{macrocode}
\cs_new:Nn \@@_set_font_default_features:nnn
 {
  \clist_map_inline:nn {#2}
   {
    \tl_if_single:nTF {##1}
     { \tl_set:No \l_@@_tmp_tl { \cs:w g_@@_ \cs_to_str:N ##1 _family\cs_end: } }
     { \@@_sanitise_fontname:Nn \l_@@_tmp_tl {##1} }
    
    \IfBooleanTF {#1}
     {
      \prop_get:NVNF \g_@@_fontopts_prop \l_@@_tmp_tl \l_@@_tmpb_tl
       { \tl_clear:N \l_@@_tmpb_tl }
      \tl_put_right:Nn \l_@@_tmpb_tl {#3,}
      \prop_gput:NVV   \g_@@_fontopts_prop \l_@@_tmp_tl \l_@@_tmpb_tl
     }
     {
      \tl_if_empty:nTF {#3}
       { \prop_gremove:NV \g_@@_fontopts_prop \l_@@_tmp_tl }
       { \prop_put:NVn    \g_@@_fontopts_prop \l_@@_tmp_tl {#3,} }      
     }
   }
 }
%    \end{macrocode}
%
% \begin{macro}{\@@_sanitise_fontname:Nn}
% Assigns font name |#2| to token list variable |#1| and sanitises it as necessary by removing spaces and stripping possible file extensions.
% At one stage this also lowercased the name, but this step has been removed unless someone can remind me why it was necessary.
%    \begin{macrocode}
\cs_new:Nn \@@_sanitise_fontname:Nn
 {
  \tl_set:Nx #1 {#2}
  \tl_remove_all:Nn #1 {~}
  \clist_map_inline:Nn \l_@@_extensions_clist
   { \tl_remove_once:Nn #1 {##1} }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\addfontfeatures}
%   In order to be able to extend the feature selection of
%   a given font, two things need to be known: the currently selected
%   features, and the currently selected font. Every time a font
%   family is created, this information is saved inside a control
%   sequence with the name of the font family itself.
%
%   This macro extracts this information, then appends the requested
%   font features to add to the already existing ones, and calls the
%   font again with the top level \cs{fontspec} command.
%
%   The default options are \emph{not} applied (which is why
%   \cs{g_fontspec_default_fontopts_tl} is emptied inside the group; this is allowed
%   as \cmd\l_fontspec_family_tl\ is globally defined in \cmd\fontspec_select:nn), so this
%   means that the only added features to the font are strictly those
%   specified by this command.
%
%   \cs{addfontfeature} is defined as an alias, as I found that I
%   often typed this instead when adding only a single font feature.
%    \begin{macrocode}
\bool_new:N \l_@@_disable_defaults_bool
\DeclareDocumentCommand \addfontfeatures {m}
 {
  \fontspec_if_fontspec_font:TF
   {
    \group_begin:
      \prop_get:cnN {g_@@_ \f@family _prop} {options} \l_@@_options_tl
      \prop_get:cnN {g_@@_ \f@family _prop} {fontname} \l_@@_fontname_tl
      \bool_set_true:N \l_@@_disable_defaults_bool
      \use:x
       {
        \exp_not:N \fontspec_select:nn
          { \l_@@_options_tl , #1 } {\l_@@_fontname_tl}
       }
    \group_end:
    \fontfamily\l_fontspec_family_tl\selectfont
   }
   {
    \@@_warning:n {addfontfeatures-ignored}
   }
  \ignorespaces
 }
\cs_set_eq:NN \addfontfeature \addfontfeatures
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Defining new font features}
%
% \begin{macro}{\newfontfeature}
%   \cs{newfontfeature} takes two arguments: the name of the feature
%   tag by which to reference it, and the string that is used to
%   select the font feature.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontfeature {mm}
 {
  \keys_define:nn { fontspec }
   {
    #1 .code:n =
     {
      \@@_update_featstr:n {#2}
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\newAATfeature}
% This command assigns a new AAT feature by its code (|#2|,|#3|) to a new name (|#1|).
% Better than \cmd\newfontfeature\ because it checks if the feature exists in the
% font it's being used for.
%    \begin{macrocode}
\DeclareDocumentCommand \newAATfeature {mmmm}
 {
  \keys_if_exist:nnF { fontspec } {#1}
    { \@@_define_font_feature:n {#1} }
  \keys_if_choice_exist:nnnT {fontspec} {#1} {#2}
    { \@@_warning:nxx {feature-option-overwrite} {#1} {#2} }
  \@@_define_feature_option:nnnnn {#1}{#2}{#3}{#4}{}
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\newopentypefeature}
% \begin{macro}{\newICUfeature}
% This command assigns a new OpenType feature by its abbreviation (|#2|) to a new name (|#1|).
% Better than \cmd\newfontfeature\ because it checks if the feature exists in the
% font it's being used for.
%    \begin{macrocode}
\DeclareDocumentCommand \newopentypefeature {mmm}
 {
  \keys_if_exist:nnF { fontspec / options } {#1}
    { \@@_define_font_feature:n {#1} }
  \keys_if_choice_exist:nnnT {fontspec} {#1} {#2}
    { \@@_warning:nxx {feature-option-overwrite} {#1} {#2} }
  \@@_define_feature_option:nnnnn {#1}{#2}{}{}{#3}
 }
\cs_set_eq:NN \newICUfeature \newopentypefeature % deprecated
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\aliasfontfeature}
% \begin{macro}{\aliasfontfeatureoption}
% User commands for renaming font features and font feature options.
%    \begin{macrocode}
\DeclareDocumentCommand \aliasfontfeature {mm}
 {
  \keys_if_exist:nnTF {fontspec} {#1}
    {
     \keys_define:nn {fontspec}
      { #2 .code:n = { \keys_set:nn {fontspec} { #1 = {##1} } } }
    }
    {
     \keys_if_exist:nnTF {fontspec-preparse} {#1}
      {
       \keys_define:nn {fontspec-preparse}
        { #2 .code:n = { \keys_set:nn {fontspec-preparse} { #1 = {##1} } } }
      }
      {
       \keys_if_exist:nnTF {fontspec-preparse-external} {#1}
        {
         \keys_define:nn {fontspec-preparse-external}
          {
           #2 .code:n =
            { \keys_set:nn {fontspec-preparse-external} { #1 = {##1} } }
          }
        }
        {
         \@@_warning:nx {rename-feature-not-exist} {#1}
        }
      }
    }
 }
\DeclareDocumentCommand \aliasfontfeatureoption {mmm}
  { \keys_define:nn { fontspec / #1 } { #3 .meta:n = {#2} } }
%    \end{macrocode}
% \end{macro} \end{macro}
%
% \begin{macro}{\newfontscript}
% Mostly used internally, but also possibly useful for users, to define new OpenType
% `scripts', mapping logical names to OpenType script tags.
% Iterates though the scripts in the selected font to check that it's a valid
% feature choice, and then prepends the (\XeTeX) \cmd\font\ feature string with the appropriate
% script selection tag.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontscript {mm}
 {
  \fontspec_new_script:nn {#1} {#2}
  \fontspec_new_script:nn {#2} {#2}
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\keys_define:nn { fontspec } { Script .choice: }
\cs_new:Nn \fontspec_new_script:nn
 {
  \keys_define:nn { fontspec } { Script / #1 .code:n =
    \fontspec_check_script:nTF {#2}
     {
      \tl_set:Nn \l_fontspec_script_tl {#2}
      \int_set:Nn \l_fontspec_script_int {\l_fontspec_strnum_int}
     }
     {
      \fontspec_check_script:nTF {latn}
       {
        \@@_warning:nx {script-not-exist-latn} {#1}
        \keys_set:nn {fontspec} {Script=Latin}
       }
       {
        \@@_warning:nx {script-not-exist} {#1}
       }
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\newfontlanguage}
% Mostly used internally, but also possibly useful for users, to define new OpenType
% `languages', mapping logical names to OpenType language tags.
% Iterates though the languages in the selected font to check that it's a valid
% feature choice, and then prepends the (\XeTeX) \cmd\font\ feature string with the appropriate
% language selection tag.
%    \begin{macrocode}
\DeclareDocumentCommand \newfontlanguage {mm}
 {
  \fontspec_new_lang:nn {#1} {#2}
  \fontspec_new_lang:nn {#2} {#2}
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\keys_define:nn { fontspec } { Language .choice: }
\cs_new:Nn \fontspec_new_lang:nn
 {
  \keys_define:nn { fontspec } { Language / #1 .code:n =
    \fontspec_check_lang:nTF {#2}
     {
      \tl_set:Nn \l_fontspec_lang_tl {#2}
      \int_set:Nn \l_fontspec_language_int {\l_fontspec_strnum_int}
     }
     {
      \@@_warning:nx {language-not-exist} {#1}
      \keys_set:nn { fontspec } { Language = Default }
     }
  }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DeclareFontsExtensions}
% \texttt{dfont} would never be uppercase, right?
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareFontsExtensions {m}
 {
  \clist_set:Nn \l_@@_extensions_clist { #1 }
  \tl_remove_all:Nn \l_@@_extensions_clist {~}
 }
\DeclareFontsExtensions{.otf,.ttf,.OTF,.TTF,.ttc,.TTC,.dfont}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Programmer's interface}
%
% These functions are not used directly by fontspec when defining fonts;
% they are designed to be used by other packages who wish to do font-related
% things on top of fontspec itself.
%
% Because I haven't fully explored how these functions will behave in
% practise, I am not giving them user-level names. As it becomes more clear
% which of these should be accessible by document writers, I'll open them up
% a little more.
%
% All functions are defined assuming that the font to be queried is
% currently selected as a fontspec font. (I.e., via \verb|\fontspec| or
% from a \verb|\newfontfamily| macro or from \verb|\setmainfont| and so on.)
%
% \begin{macro}{\fontspec_if_fontspec_font:TF}
% Test whether the currently selected font has been loaded by fontspec.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_fontspec_font: {TF,T,F}
 {
  \cs_if_exist:cTF {g_@@_ \f@family _prop} \prg_return_true: \prg_return_false:
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_aat_feature:nnTF}
% Conditional to test if the currently selected font contains the \AAT\
% feature (|#1|,|#2|).
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_aat_feature:nn {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \bool_if:NTF \l_@@_atsui_bool
     {
      \fontspec_make_AAT_feature_string:nnTF {#1}{#2}
        \prg_return_true: \prg_return_false:
     }
     {
      \prg_return_false:
     }
   }
   {
    \prg_return_false:
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_opentype:TF}
% Test whether the currently selected font is an OpenType font.
% Always true for LuaTeX fonts.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_opentype: {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool \prg_return_true: \prg_return_false:
   }
   {
    \prg_return_false:
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_feature:nTF}
% Test whether the currently selected font contains the raw OpenType
% feature |#1|. E.g.: |\fontspec_if_feature:nTF {pnum} {True} {False}|
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_feature:n {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \prop_get:cnN {g_@@_ \f@family _prop} {script-num} \l_@@_tmp_tl
      \int_set:Nn \l_fontspec_script_int {\l_@@_tmp_tl}
      
      \prop_get:cnN {g_@@_ \f@family _prop} {lang-num} \l_@@_tmp_tl
      \int_set:Nn \l_fontspec_language_int {\l_@@_tmp_tl}
      
      \prop_get:cnN {g_@@_ \f@family _prop} {script-tag}  \l_fontspec_script_tl
      \prop_get:cnN {g_@@_ \f@family _prop} {lang-tag}  \l_fontspec_lang_tl

      \fontspec_check_ot_feat:nTF {#1} {\prg_return_true:} {\prg_return_false:}
     }
     {
      \prg_return_false:
     }
   }
   {
    \prg_return_false:
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_feature:nnnTF}
% Test whether the currently selected font with raw OpenType script tag |#1| and raw OpenType language tag |#2| contains the raw OpenType feature tag |#3|. E.g.: |\fontspec_if_feature:nTF {latn} {ROM} {pnum} {True} {False}|
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_feature:nnn {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \fontspec_iv_str_to_num:Nn \l_fontspec_script_int {#1}
      \fontspec_iv_str_to_num:Nn \l_fontspec_language_int {#2}
      \fontspec_check_ot_feat:nTF {#3} \prg_return_true: \prg_return_false:
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_script:nTF}
% Test whether the currently selected font contains the raw OpenType
% script |#1|. E.g.: |\fontspec_if_script:nTF {latn} {True} {False}|
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_script:n {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \fontspec_check_script:nTF {#1} \prg_return_true: \prg_return_false:
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_language:nTF}
% Test whether the currently selected font contains the raw OpenType language
% tag |#1|. E.g.: |\fontspec_if_language:nTF {ROM} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_language:n {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \prop_get:cnN {g_@@_ \f@family _prop} {script-num} \l_@@_tmp_tl
      \int_set:Nn \l_fontspec_script_int {\l_@@_tmp_tl}      
      \prop_get:cnN {g_@@_ \f@family _prop} {script-tag}  \l_fontspec_script_tl

      \fontspec_check_lang:nTF {#1} \prg_return_true: \prg_return_false:
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_language:nnTF}
% Test whether the currently selected font contains the raw OpenType language
% tag |#2| in script |#1|. E.g.: |\fontspec_if_language:nnTF {cyrl} {SRB} {True} {False}|.
% Returns false if the font is not loaded by fontspec or is not an OpenType
% font.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_language:nn {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \tl_set:Nn \l_fontspec_script_tl {#1}
      \fontspec_iv_str_to_num:Nn \l_fontspec_script_int {#1}
      \fontspec_check_lang:nTF {#2} \prg_return_true: \prg_return_false:
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_if_current_script:nTF}
% Test whether the currently loaded font is using the specified raw
% OpenType script tag |#1|.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_current_script:n {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \prop_get:cnN {g_@@_ \f@family _prop} {script-tag}  \l_@@_tmp_tl
      \str_if_eq:nVTF {#1}  \l_@@_tmp_tl
        {\prg_return_true:} {\prg_return_false:}
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_if_current_language:nTF}
% Test whether the currently loaded font is using the specified raw
% OpenType language tag |#1|.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_if_current_language:n {TF,T,F}
 {
  \fontspec_if_fontspec_font:TF
   {
    \prop_get:cnN {g_@@_ \f@family _prop} {fontdef} \l_@@_fontdef_tl
    \@@_font_set:Nnn \l_fontspec_font {\l_@@_fontdef_tl} {\f@size pt}
    \@@_set_font_type:
    \bool_if:NTF \l_@@_ot_bool
     {
      \prop_get:cnN {g_@@_ \f@family _prop} {lang-tag}  \l_@@_tmp_tl
      \str_if_eq:nVTF {#1} \l_@@_tmp_tl
        {\prg_return_true:} {\prg_return_false:}
     }
     { \prg_return_false: }
   }
   { \prg_return_false: }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_set_family:Nnn}
% \darg{family}
% \darg{fontspec features}
% \darg{font name}
% Defines a new font family from given \meta{features} and \meta{font},
% and stores the name in the variable \meta{family}.
% See the standard \pkg{fontspec} user commands for applications of this
% function.
%
% We want to store the actual name of the font family within the \meta{family}
% variable because the actual \LaTeX\ family name is automatically generated
% by fontspec and it's easier to keep it that way.
%
% Please use |\fontspec_set_family:Nnn| instead of |\fontspec_select:nn|,
% which may change in the future.
%    \begin{macrocode}
\cs_new:Nn \fontspec_set_family:Nnn
 {
  \tl_set:Nn \l_@@_family_label_tl { #1 }
  \fontspec_select:nn {#2}{#3}
  \tl_set_eq:NN #1 \l_fontspec_family_tl
 }
\cs_generate_variant:Nn \fontspec_set_family:Nnn {c}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fontspec_set_fontface:NNnn}
%    \begin{macrocode}
\cs_new:Nn \fontspec_set_fontface:NNnn
 {
  \tl_set:Nn \l_@@_family_label_tl { #1 }
  \fontspec_select:nn {#3}{#4}
  \tl_set_eq:NN #1 \l_fontspec_font
  \tl_set_eq:NN #2 \l_fontspec_family_tl
 }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{expl3 interface for font loading}
%
%    \begin{macrocode}
\cs_set:Nn \@@_fontwrap:n { "#1" }
%    \end{macrocode}
%
% Beginnings of an `l3font', I guess:
%    \begin{macrocode}
\cs_if_free:NT \font_set_eq:NN
 {
  \cs_set_eq:NN \font_set_eq:NN \tex_let:D
  \cs_set:Npn \font_set:Nnn #1#2#3
   {
    \font #1 = #2 ~at~ #3\scan_stop:
   }
  \cs_set:Npn \font_gset:Nnn #1#2#3
   {
    \global \font #1 = #2 ~at~ #3 \scan_stop:
   }
  \cs_set:Npn \font_suppress_not_found_error:
%<xetexx>    {\suppressfontnotfounderror=1}
%<luatex>    {\luatexsuppressfontnotfounderror=1}
  \prg_set_conditional:Nnn \@@_font_if_null:N {p,TF,T,F}
   {
    \ifx #1 \nullfont
      \prg_return_true:
    \else
      \prg_return_false:
    \fi
   }
 }
%    \end{macrocode}
%
%
% \begin{macro}{\fontspec_set:Nnn,\fontspec_gset:Nnn}
% Wrapper around \cs{font_set:Nnn} and \cs{font_gset:Nnn}.
%    \begin{macrocode}
\cs_new:Nn \@@_font_set:Nnn
 {
  \font_set:Nnn #1 {\@@_fontwrap:n {#2}} {#3}
 }
\cs_new:Nn \@@_font_gset:Nnn
 {
  \font_gset:Nnn #1 {\@@_fontwrap:n {#2}} {#3}
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\font_glyph_if_exist:NnTF}
%    \begin{macrocode}
\prg_new_conditional:Nnn \font_glyph_if_exist:Nn {p,TF,T,F}
 {
  \etex_iffontchar:D #1 #2 \scan_stop:
    \prg_return_true:
  \else:
    \prg_return_false:
  \fi:
 }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Internal macros}
% \label{sec:codeinternal}
%
% The macros from here in are used internally by all those defined above.
% They are not designed to remain consistent between versions.
%
%
%
%
% \begin{macro}{\fontspec_select:nn}
% This is the command that defines font families for use, the underlying
% procedure of all \cmd\fontspec-like commands. Given a
% list of font features (|#1|) for a requested font (|#2|),
% it will define an NFSS
% family for that font and put the family name (globally) into \cs{l_fontspec_family_tl}.
% The \TeX\ `\cs{font}' command is (globally) stored in \cs{l_fontspec_font}.
%
% This macro does its processing inside a group to attempt to restrict the scope of its internal processing.
% This works to some degree to insulate the internal commands from having to be manually cleared.
%
% Some often-used variables to know about:
% \begin{itemize}
% \item \cmd{\l_fontspec_fontname_tl} is used as the generic name of the font being defined.
% \item \cmd{\l_@@_fontid_tl} is the unique identifier of the font with all its features.
% \item \cmd{\l_fontspec_fontname_up_tl} is the font specifically to be used as the upright font.
% \item \cmd{\l_@@_basename_tl} is the (immutable) original argument used for |*|-replacing.
% \item \cmd{\l_fontspec_font} is the plain \TeX{} font of the upright font requested.
% \end{itemize}
%    \begin{macrocode}
\cs_set:Nn \fontspec_select:nn
 {
  \group_begin:
  \font_suppress_not_found_error:
  \@@_init:

  \@@_load_external_fontoptions:Nn \l_fontspec_fontname_tl {#2}
  \tl_set_eq:NN \l_fontspec_fontname_up_tl \l_fontspec_fontname_tl
  \tl_set_eq:NN \l_@@_basename_tl          \l_fontspec_fontname_tl

  \@@_extract_all_features:n {#1}
  \@@_preparse_features:

  \@@_load_font:
  \@@_set_scriptlang:
  \@@_get_features:Nn \l_@@_rawfeatures_sclist {}
  \bool_set_false:N \l_@@_firsttime_bool

  \@@_save_family:nTF {#2}
   {
    \@@_save_fontinfo:
    \@@_find_autofonts:
    \DeclareFontFamily{\g_fontspec_encoding_tl}{\l_fontspec_family_tl}{}
    \@@_set_faces:
    \@@_info:nxx {defining-font} {#1} {#2}
%<*debug>
    \typeout{"\l_@@_fontid_tl"~ defined.}
    \@@_warning:nxx {defining-font} {#1} {#2}
%</debug>
   }
   {
%<*debug>
    \typeout{"\l_@@_fontid_tl"~ already~ defined~ apparently.}
%</debug>
   }
  \group_end:
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_load_external_fontoptions:Nn}
% Load a possible \texttt{.fontspec} font configuration file.
% This file could set font-specific options for the font about to be loaded.
%    \begin{macrocode}
\cs_new:Nn \@@_load_external_fontoptions:Nn
 {
  \@@_sanitise_fontname:Nn #1 {#2}
  \prop_if_in:NVF \g_@@_fontopts_prop {#1}
   {
    \exp_args:No \file_if_exist:nT {#1.fontspec}
     { \file_input:n {#1.fontspec} }
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_extract_features:}
%    \begin{macrocode}
\cs_new:Nn \@@_extract_all_features:n
 {
  \@@_sanitise_fontname:Nn \l_@@_tmp_tl {\l_fontspec_fontname_tl}
  
  \bool_if:NTF \l_@@_disable_defaults_bool
   {
    \clist_set:Nx \l_@@_all_features_clist
     {#1}
   }
   {
    \prop_get:NVNF \g_@@_fontopts_prop \l_@@_tmp_tl \l_@@_fontopts_clist
     { \clist_clear:N \l_@@_fontopts_clist }

    \prop_get:NVNF \g_@@_fontopts_prop \l_@@_family_label_tl \l_@@_family_fontopts_clist
     { \clist_clear:N \l_@@_family_fontopts_clist }
    \tl_clear:N \l_@@_family_label_tl

    \clist_set:Nx \l_@@_all_features_clist
     {
      \g_@@_default_fontopts_clist,
      \l_@@_family_fontopts_clist,
      \l_@@_fontopts_clist,
      #1   
     }
   }
  \tl_set:Nx \l_@@_fontid_tl { \tl_to_str:N \l_fontspec_fontname_tl-:-\tl_to_str:N \l_@@_all_features_clist }
%<*debug>
  \typeout{fontid: \l_@@_fontid_tl}
%</debug>
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_preparse_features:}
% \darg{feature options}
% \darg{font name}
% Perform the (multi-step) feature parsing process.
%
% Convert the requested features to font definition
% strings. First the features are parsed for information about font
% loading (whether it's a named font or external font, etc.), and then
% information is extracted for the names of the other shape fonts.
%    \begin{macrocode}
\cs_new:Nn \@@_preparse_features:
 {
%    \end{macrocode}
% Detect if external fonts are to be used, possibly automatically, and
% parse fontspec features for bold/italic fonts and their features.
%    \begin{macrocode}
  \exp_args:NV \@@_if_detect_external:nT \l_fontspec_fontname_tl
   { \keys_set:nn {fontspec-preparse-external} {ExternalLocation} }

  \keys_set_known:nxN {fontspec-preparse-external}
   { \l_@@_all_features_clist }
   \l_@@_keys_leftover_clist
%    \end{macrocode}
% When \cmd{\l_fontspec_fontname_tl} is augmented with a prefix or whatever to create
% the name of the upright font (\cmd{\l_fontspec_fontname_up_tl}), this latter is the new `general
% font name' to use.
%    \begin{macrocode}
  \tl_set_eq:NN \l_fontspec_fontname_tl \l_fontspec_fontname_up_tl
  \keys_set_known:nxN {fontspec-renderer} {\l_@@_keys_leftover_clist}
    \l_@@_keys_leftover_clist
  \keys_set_known:nxN {fontspec-preparse} {\l_@@_keys_leftover_clist}
    \l_@@_fontfeat_clist
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_load_font:}
%    \begin{macrocode}
\cs_new:Nn \@@_load_font:
 {
  \@@_font_set:Nnn    \l_fontspec_font
     { \@@_fullname:n {\l_fontspec_fontname_up_tl} } {\f@size pt}
  \@@_font_if_null:NT \l_fontspec_font { \@@_error:nx {font-not-found} {\l_fontspec_fontname_up_tl} }
  \@@_set_font_type:
  \@@_font_gset:Nnn   \l_fontspec_font 
     { \@@_fullname:n {\l_fontspec_fontname_up_tl} } {\f@size pt}
  \l_fontspec_font % this is necessary for LuaLaTeX to check the scripts properly
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_if_detect_external:nnT}
% Check if either the fontname ends with a known font extension.
%    \begin{macrocode}
\prg_new_conditional:Nnn \@@_if_detect_external:n {T}
 {
  \clist_map_inline:Nn \l_@@_extensions_clist
   {
    \bool_set_false:N \l_@@_tmpa_bool
    \tl_if_in:nnT {#1 <= end_of_string} {##1 <= end_of_string}
      { \bool_set_true:N \l_@@_tmpa_bool \clist_map_break: }
   }
  \bool_if:NTF \l_@@_tmpa_bool \prg_return_true: \prg_return_false:
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_fullname:n}
% Constructs the complete font name based on a common piece of info.
%    \begin{macrocode}
\cs_set:Nn \@@_fullname:n
 {
  \@@_namewrap:n { #1 \l_@@_extension_tl }
  \l_fontspec_renderer_tl
  \l_@@_optical_size_tl
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_set_scriptlang:}
% Only necessary for OpenType fonts.
% First check if the font supports scripts, then apply defaults if
% none are explicitly requested. Similarly with the language settings.
%    \begin{macrocode}
\cs_new:Nn \@@_set_scriptlang:
 {
  \bool_if:NT \l_@@_firsttime_bool
   {
    \tl_if_empty:NTF \l_@@_script_name_tl
     {
      \fontspec_check_script:nTF {latn}
       {
        \tl_set:Nn \l_@@_script_name_tl {Latin}
        \tl_if_empty:NT \l_@@_lang_name_tl
         {
          \tl_set:Nn \l_@@_lang_name_tl {Default}
         }
        \keys_set:nx {fontspec} {Script=\l_@@_script_name_tl}
        \keys_set:nx {fontspec} {Language=\l_@@_lang_name_tl}
       }
       {
        \@@_info:n {no-scripts}
       }
     }
     {
      \tl_if_empty:NT \l_@@_lang_name_tl
       {
        \tl_set:Nn \l_@@_lang_name_tl {Default}
       }
      \keys_set:nx {fontspec} {Script=\l_@@_script_name_tl}
      \keys_set:nx {fontspec} {Language=\l_@@_lang_name_tl}
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_save_family:nTF}
% Check if the family is unique and, if so, save its information.
% (\cs{addfontfeature} and other macros use this data.)
% Then the font family and its shapes are defined in the NFSS.
%
% Now we have a unique (in fact, too unique!) string that contains
% the family name and every option in abbreviated form. This is used
% with a counter to create a simple NFSS family name for the font we're
% selecting.
%
%    \begin{macrocode}
\prg_new_conditional:Nnn \@@_save_family:n {TF}
 {
%<debug>\typeout{save~ family:~ #1}
  \cs_if_exist:NT \l_@@_nfss_fam_tl
   {
    \cs_set_eq:cN {g_@@_UID_\l_@@_fontid_tl} \l_@@_nfss_fam_tl
   }
  \cs_if_exist:cF {g_@@_UID_\l_@@_fontid_tl}
   {
    % The font name is fully expanded, in case it's defined in terms of macros, before having its spaces zapped:
    \tl_set:Nx \l_@@_tmp_tl {#1}
    \tl_remove_all:Nn \l_@@_tmp_tl {~}

    \cs_if_exist:cTF {g_@@_family_ \l_@@_tmp_tl _int}
     { \int_gincr:c  {g_@@_family_ \l_@@_tmp_tl _int} }
     { \int_new:c    {g_@@_family_ \l_@@_tmp_tl _int} }

    \tl_gset:cx {g_@@_UID_\l_@@_fontid_tl}
     {
      \l_@@_tmp_tl ( \int_use:c {g_@@_family_ \l_@@_tmp_tl _int} )
     }
   }
  \tl_gset:Nv \l_fontspec_family_tl {g_@@_UID_\l_@@_fontid_tl}
  \cs_if_exist:cTF {g_@@_ \l_fontspec_family_tl _prop}
    \prg_return_false: \prg_return_true:
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_save_fontinfo:nn}
% Saves the relevant font information for future processing.
%    \begin{macrocode}
\cs_generate_variant:Nn \prop_gput:Nnn {cnV}
\cs_generate_variant:Nn \prop_gput:Nnn {cnx}
\cs_new:Nn \@@_save_fontinfo:
 {
  \prop_new:c {g_@@_ \l_fontspec_family_tl _prop}
  \prop_gput:cnx {g_@@_ \l_fontspec_family_tl _prop} {fontname} { \l_@@_basename_tl }
  \prop_gput:cnx {g_@@_ \l_fontspec_family_tl _prop} {options}  { \l_@@_all_features_clist }
  \prop_gput:cnx {g_@@_ \l_fontspec_family_tl _prop} {fontdef}
   {
    \@@_fullname:n {\l_fontspec_fontname_tl} :
    \l_@@_pre_feat_sclist \l_@@_rawfeatures_sclist
   }
  \prop_gput:cnV {g_@@_ \l_fontspec_family_tl _prop} {script-num} \l_fontspec_script_int
  \prop_gput:cnV {g_@@_ \l_fontspec_family_tl _prop} {lang-num} \l_fontspec_language_int
  \prop_gput:cnV {g_@@_ \l_fontspec_family_tl _prop} {script-tag} \l_fontspec_script_tl
  \prop_gput:cnV {g_@@_ \l_fontspec_family_tl _prop} {lang-tag} \l_fontspec_lang_tl

 }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Setting font shapes in a family}
%
% All NFSS specifications take their default values, so if any of them
% are redefined, the shapes will be selected to fit in with the
% current state. For example, if \cmd\bfdefault\ is redefined to |b|, all
% bold shapes defined by this package will also be assigned to |b|.
%
% The combination shapes are searched first because they use information that may be redefined in the single cases.
% E.g., if no bold font is specified then |set_autofont| will attempt to set it.
% This has subtle/small ramifications on the logic of choosing the bold italic font.
%
% \begin{macro}{\@@_find_autofonts:}
%    \begin{macrocode}
\cs_new:Nn \@@_find_autofonts:
 { 
  \bool_if:nF {\l_@@_noit_bool || \l_@@_nobf_bool}
   {
    \@@_set_autofont:Nnn \l_fontspec_fontname_bfit_tl {\l_fontspec_fontname_it_tl} {/B}
    \@@_set_autofont:Nnn \l_fontspec_fontname_bfit_tl {\l_fontspec_fontname_bf_tl} {/I}
    \@@_set_autofont:Nnn \l_fontspec_fontname_bfit_tl {\l_fontspec_fontname_tl} {/BI}
   }

  \bool_if:NF \l_@@_nobf_bool
   {
    \@@_set_autofont:Nnn \l_fontspec_fontname_bf_tl {\l_fontspec_fontname_tl} {/B}
   }
   
  \bool_if:NF \l_@@_noit_bool
   {
    \@@_set_autofont:Nnn \l_fontspec_fontname_it_tl {\l_fontspec_fontname_tl} {/I}
   }

  \@@_set_autofont:Nnn \l_fontspec_fontname_bfsl_tl {\l_fontspec_fontname_sl_tl} {/B}
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_set_faces:}
%    \begin{macrocode}
\cs_new:Nn \@@_set_faces:
 {
  \@@_add_nfssfont:oooo \mddefault \updefault \l_fontspec_fontname_tl      \l_@@_fontfeat_up_clist
  \@@_add_nfssfont:oooo \bfdefault \updefault \l_fontspec_fontname_bf_tl   \l_@@_fontfeat_bf_clist
  \@@_add_nfssfont:oooo \mddefault \itdefault \l_fontspec_fontname_it_tl   \l_@@_fontfeat_it_clist
  \@@_add_nfssfont:oooo \mddefault \sldefault \l_fontspec_fontname_sl_tl   \l_@@_fontfeat_sl_clist
  \@@_add_nfssfont:oooo \bfdefault \itdefault \l_fontspec_fontname_bfit_tl \l_@@_fontfeat_bfit_clist
  \@@_add_nfssfont:oooo \bfdefault \sldefault \l_fontspec_fontname_bfsl_tl \l_@@_fontfeat_bfsl_clist

  \prop_map_inline:Nn \l_@@_nfssfont_prop { \@@_set_faces_aux:nnnnn ##2 }
 }
\cs_new:Nn \@@_set_faces_aux:nnnnn
 {  
  \fontspec_complete_fontname:Nn \l_@@_curr_fontname_tl {#3}
  \@@_make_font_shapes:Nnnnn \l_@@_curr_fontname_tl {#1} {#2} {#4} {#5}
 }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Fonts}
%
% \begin{macro}{\@@_set_font_type:}
% Now check if the font is to be rendered with \ATSUI\ or Harfbuzz. This will either
% be automatic (based on the font type), or specified by the user via a font feature.
%
% This macro sets booleans
% accordingly depending if the font in \cmd\l_fontspec_font\ is an \AAT\
% font or an OpenType font or a font with feature axes (either \AAT\ or
% Multiple Master), respectively.
%    \begin{macrocode}
\cs_new:Nn \@@_set_font_type:
%<*xetexx>
 {
  \bool_set_false:N \l_@@_tfm_bool
  \bool_set_false:N \l_@@_atsui_bool
  \bool_set_false:N \l_@@_ot_bool
  \bool_set_false:N \l_@@_mm_bool
  \bool_set_false:N \l_@@_graphite_bool
  \ifcase\XeTeXfonttype\l_fontspec_font
    \bool_set_true:N \l_@@_tfm_bool
  \or
    \bool_set_true:N \l_@@_atsui_bool
    \ifnum\XeTeXcountvariations\l_fontspec_font > \c_zero
      \bool_set_true:N \l_@@_mm_bool
    \fi
  \or
    \bool_set_true:N \l_@@_ot_bool
  \fi
%    \end{macrocode}
% If automatic, the \cmd{\l_fontspec_renderer_tl} token list will still be
% empty (other suffices that could be added will be later in the feature
% processing), and if it is indeed still empty, assign it a value so that the
% other weights of the font are specifically loaded with the same renderer.
%    \begin{macrocode}
  \tl_if_empty:NT \l_fontspec_renderer_tl
   {
    \bool_if:NTF \l_@@_atsui_bool
     { \tl_set:Nn \l_fontspec_renderer_tl {/AAT} }
     {
       \bool_if:NT \l_@@_ot_bool
        { \tl_set:Nn \l_fontspec_renderer_tl {/OT} }
     }
   }
 }
%</xetexx>
%<*luatex>
 {
  \bool_set_true:N \l_@@_ot_bool
 }
%</luatex>
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_set_autofont:Nnn}
% \darg{Font name tl}
% \darg{Base font name}
% \darg{Font name modifier}
%
% This function looks for font with \meta{name} and \meta{modifier} |#2#3|, and if found (i.e., different to font with name |#2|) stores it in tl |#1|. A modifier is something like |/B| to look for a bold font, for example.
%
% We can't match external fonts in this way (in \XeTeX\ anyway; todo: test with LuaTeX).
% If \meta{font name tl} is not empty, then it's already been specified by the user so abort.
% If \meta{Base font name} is not given, we also abort for obvious reasons.
%
% If \meta{font name tl} is empty, then proceed.
% If not found, \meta{font name tl} remains empty.
% Otherwise, we have a match.
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_if_empty:nF {x}
\cs_new:Nn \@@_set_autofont:Nnn
 {
  \bool_if:NF \l_@@_external_bool
   {
  \tl_if_empty:xF {#2}
   {
    \tl_if_empty:NT #1
     {
      \@@_if_autofont:nnTF {#2} {#3}
       { \tl_set:Nx #1 {#2#3} }
       { \@@_info:nx {no-font-shape} {#2#3} }
     }
   }
   }
 }

\prg_new_conditional:Nnn \@@_if_autofont:nn {T,TF}
 {
  \@@_font_set:Nnn \l_tmpa_font { \@@_fullname:n {#1}   } {\f@size pt}
  \@@_font_set:Nnn \l_tmpb_font { \@@_fullname:n {#1#2} } {\f@size pt}
  \str_if_eq_x:nnTF { \fontname \l_tmpa_font } { \fontname \l_tmpb_font }
   { \prg_return_false: }
   { \prg_return_true: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_make_font_shapes:Nnnnn}
%  \darg{Font name}
%  \darg{Font series}
%  \darg{Font shape}
%  \darg{Font features}
%  \darg{Size features}
%   This macro eventually uses \cs{DeclareFontShape} to define the font shape in
%   question.
%
%   The optional first
%   argument is used when making the font shapes for bold, italic, and
%   bold italic fonts using \XeTeX's auto-recognition with |#2| as |/B|, |/I|,
%   and |/BI| font name suffixes. If no such font is found, it falls
%   back to the original font name, in which case this macro doesn't
%   proceed and the font shape is not created for the NFSS.
%
% Next, the small caps are defined. [...] is used to
% define the appropriate string for activating small caps in the font,
% if they exist. If we are defining small caps for the upright shape,
% then the small caps shape default is used. For an \emph{italic}
% font, however, the shape parameter is overloaded and we must call
% italic small caps by their own identifier. See \vref{sec:sishape}
% for the code that enables this usage.
%    \begin{macrocode}
\cs_new:Nn \@@_make_font_shapes:Nnnnn
 {
  \group_begin:
    \@@_load_fontname:n {#1}
    \@@_declare_shape:nnxx {#2} {#3} { \l_@@_fontopts_clist, #4 } {#5}
  \group_end:
 }

\cs_new:Nn \@@_load_fontname:n
 {
    \@@_load_external_fontoptions:Nn \l_fontspec_fontname_tl {#1}
    \prop_get:NVNF \g_@@_fontopts_prop \l_fontspec_fontname_tl \l_@@_fontopts_clist
     { \clist_clear:N \l_@@_fontopts_clist }
    \@@_font_set:Nnn \l_fontspec_font {\@@_fullname:n {\l_fontspec_fontname_tl}} {\f@size pt}
    \@@_font_if_null:NT \l_fontspec_font { \@@_error:nx {font-not-found} {#1} }
 }
%    \end{macrocode}
% Note that the test for italics to choose the \cmd\sidefault\ shape
% only works while \cmd\fontspec_select:nn\ passes single tokens to this macro\dots
% \end{macro}
%
% \begin{macro}{\@@_declare_shape:nnnn}
% \darg{Font series}
% \darg{Font shape}
% \darg{Font features}
% \darg{Size features}
% Wrapper for \cmd\DeclareFontShape.
% And finally the actual font shape declaration using \cmd\l_@@_nfss_tl\ defined above.
% \cmd\l_@@_postadjust_tl\ is defined in various places to deal with things like the hyphenation
% character and interword spacing.
%
% The main part is to loop through \feat{SizeFeatures} arguments, which are of the form
% {\par\centering |SizeFeatures={{<one>},{<two>},{<three>}}|.\par}
%    \begin{macrocode}
\cs_new:Nn \@@_declare_shape:nnnn
 {
  \tl_clear:N \l_@@_nfss_tl
  \tl_clear:N \l_@@_nfss_sc_tl
  \tl_set_eq:NN \l_@@_saved_fontname_tl \l_fontspec_fontname_tl

  \exp_args:Nx \clist_map_inline:nn {#4}
   {
    \tl_clear:N \l_@@_size_tl
    \tl_set_eq:NN \l_@@_sizedfont_tl \l_@@_saved_fontname_tl % in case not spec'ed
    
    \keys_set_known:nxN {fontspec-sizing} { \exp_after:wN \use:n ##1 }
      \l_@@_sizing_leftover_clist
    \tl_if_empty:NT \l_@@_size_tl { \@@_error:n {no-size-info} }

    % "normal"
    \@@_load_fontname:n {\l_@@_sizedfont_tl}
    \@@_setup_nfss:Nnn \l_@@_nfss_tl {#3} {} 
    
    % small caps    
    \clist_set_eq:NN \l_@@_fontfeat_curr_clist \l_@@_fontfeat_sc_clist

    \bool_if:NF \l_@@_nosc_bool
     {
      \tl_if_empty:NTF \l_fontspec_fontname_sc_tl
       {
%<debug>      \typeout{Attempting~ small~ caps?}
        \@@_make_smallcaps:TF
         {
%<debug>      \typeout{Small~ caps~ found.}
          \clist_put_left:Nn \l_@@_fontfeat_curr_clist {Letters=SmallCaps}
         }
         {
%<debug>      \typeout{Small~ caps~ not~ found.}
          \bool_set_true:N \l_@@_nosc_bool
         }
       }
       { \@@_load_fontname:n {\l_fontspec_fontname_sc_tl} }% local for each size
     }

    \bool_if:NF \l_@@_nosc_bool
     {
      \@@_setup_nfss:Nnn \l_@@_nfss_sc_tl {#3} {\l_@@_fontfeat_curr_clist} 
     }

   }

  \@@_declare_shapes_normal:nn  {#1} {#2}
  \@@_declare_shape_slanted:nn  {#1} {#2}
  \@@_declare_shape_loginfo:nnn {#1} {#2} {#3}
 }
\cs_generate_variant:Nn \@@_declare_shape:nnnn {nnxx}

\cs_new:Nn \@@_setup_nfss:Nnn
 {
  \@@_get_features:Nn \l_@@_rawfeatures_sclist
   { #2 , \l_@@_sizing_leftover_clist , #3 }

  \tl_put_right:Nx #1
   {
    <\l_@@_size_tl> \l_@@_scale_tl
    \@@_fontwrap:n
     {
      \@@_fullname:n { \l_fontspec_fontname_tl }
      : \l_@@_pre_feat_sclist \l_@@_rawfeatures_sclist
     }
   }
 }

\cs_new:Nn \@@_declare_shapes_normal:nn
 {
    \@@_DeclareFontShape:xxxxxx {\g_fontspec_encoding_tl} {\l_fontspec_family_tl}
      {#1} {#2} {\l_@@_nfss_tl}{\l_@@_postadjust_tl}
      
    \bool_if:NF \l_@@_nosc_bool
     {
      \@@_DeclareFontShape:xxxxxx {\g_fontspec_encoding_tl} {\l_fontspec_family_tl}
        {#1}
        {\str_if_eq_x:nnTF {#2} {\itdefault} \sidefault \scdefault}
        {\l_@@_nfss_sc_tl}{\l_@@_postadjust_tl}
     }
 }

\cs_new:Nn \@@_DeclareFontShape:nnnnnn
 {
  \group_begin:
    \normalsize
    \cs_undefine:c {#1/#2/#3/#4/\f@size}
  \group_end:
  \DeclareFontShape{#1}{#2}{#3}{#4}{#5}{#6}
 }
\cs_generate_variant:Nn \@@_DeclareFontShape:nnnnnn {xxxxxx}
%    \end{macrocode}
% This extra stuff for the slanted shape substitution is a little bit awkward.
% We define the slanted shape to be a synonym for it when (a)~we're defining an italic font, but also (b)~when the default slanted shape isn't `it'.
% (Presumably this turned up once in a test and I realised it caused problems. I doubt this would happen much.)
%
% We should test when a slanted font has been specified and not run this code if so, but the \verb|\@@_set_slanted:| code will overwrite this anyway if necessary.
%    \begin{macrocode}
\cs_new:Nn \@@_declare_shape_slanted:nn
 {
  \bool_if:nT
   {
     \str_if_eq_x_p:nn {#2} {\itdefault}  &&
    !(\str_if_eq_x_p:nn {\itdefault} {\sldefault})
   }
   {
    \@@_DeclareFontShape:xxxxxx {\g_fontspec_encoding_tl}{\l_fontspec_family_tl}{#1}{\sldefault}
      {<->ssub*\l_fontspec_family_tl/#1/\itdefault}{\l_@@_postadjust_tl}
   }
 }
%    \end{macrocode}
% Lastly some informative messaging.
%    \begin{macrocode}
\cs_new:Nn \@@_declare_shape_loginfo:nnn
 {
  \tl_gput_right:Nx \l_fontspec_defined_shapes_tl
   {
    \exp_not:n { \\ \\ }
    *~ '\exp_not:N \str_case:nnn {#1/#2}
     {
       {\mddefault/\updefault} {normal}
       {\bfdefault/\updefault} {bold}
       {\mddefault/\itdefault} {italic}
       {\bfdefault/\itdefault} {bold~ italic}
     } {#2/#3}'~
    with~ NFSS~ spec.: \exp_not:N \\
    \l_@@_nfss_tl
    \exp_not:n { \\ \\ }
    *~ '\exp_not:N \str_case:nnn {#1/\scdefault}
     {
       {\mddefault/\scdefault} {small~ caps}
       {\bfdefault/\scdefault} {bold~ small~ caps}
       {\mddefault/\sidefault} {italic~ small~ caps}
       {\bfdefault/\sidefault} {bold~ italic~ small~ caps}
     } {#2/#3}'~
    with~ NFSS~ spec.: \exp_not:N \\
    \l_@@_nfss_sc_tl
    \tl_if_empty:NF \l_@@_postadjust_tl
     {
      \exp_not:N \\ and~ font~ adjustment~ code: \exp_not:N \\ \l_@@_postadjust_tl
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_@@_pre_feat_sclist}
% These are the features always applied to a font selection before other
% features.
%    \begin{macrocode}
\clist_set:Nn \l_@@_pre_feat_sclist
%<*xetexx>
 {
  \bool_if:NT \l_@@_ot_bool
   {
    \tl_if_empty:NF \l_fontspec_script_tl
     {
      script   = \l_fontspec_script_tl ;
      language = \l_fontspec_lang_tl   ;
     }
   }
 }
%</xetexx>
%<*luatex>
 {
  mode     = \l_fontspec_mode_tl   ;
  \tl_if_empty:NF \l_fontspec_script_tl
   {
    script   = \l_fontspec_script_tl ;
    language = \l_fontspec_lang_tl   ;
   }
 }
%</luatex>
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
% \subsubsection{Features}
%
% \begin{macro}{\@@_get_features:Nn}
%
%   This macro is a wrapper for |\keys_set:nn| which expands and adds a
%   default specification to the original passed options. It begins by
%   initialising the commands used to hold font-feature specific
%   strings.
%   Its argument is any additional features to prepend to the default.
%    \begin{macrocode}
\cs_set:Nn \@@_get_features:Nn
 {
  \sclist_clear:N \l_@@_rawfeatures_sclist
  \tl_clear:N \l_@@_scale_tl
  \tl_set_eq:NN \l_@@_opacity_tl \g_@@_opacity_tl
  \tl_set_eq:NN \l_@@_hexcol_tl \g_@@_hexcol_tl
  \tl_set_eq:NN \l_@@_postadjust_tl \g_@@_postadjust_tl
  \tl_clear:N \l_@@_wordspace_adjust_tl
  \tl_clear:N \l_@@_punctspace_adjust_tl

  \keys_set_known:nxN {fontspec-renderer} {\l_@@_fontfeat_clist,#2}
    \l_@@_keys_leftover_clist
  \keys_set:nx {fontspec} {\l_@@_keys_leftover_clist}
%    \end{macrocode}
% Finish the colour specification.
% Do not set the colour if not explicitly spec'd else \verb|\color| (using
% specials) will not work.
%    \begin{macrocode}
  \str_if_eq_x:nnF { \l_@@_hexcol_tl \l_@@_opacity_tl }
                   { \g_@@_hexcol_tl \g_@@_opacity_tl }
   {
    \@@_update_featstr:n { color = \l_@@_hexcol_tl\l_@@_opacity_tl }
   }
  
  \tl_set_eq:NN #1 \l_@@_rawfeatures_sclist
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_init:}
% Initialisations that either need to occur globally:
% (all setting of these variables is done locally inside a group)
%    \begin{macrocode}
\tl_clear:N \l_@@_family_label_tl
\tl_clear:N \l_fontspec_fontname_bf_tl
\tl_clear:N \l_fontspec_fontname_it_tl
\tl_clear:N \l_fontspec_fake_slant_tl
\tl_clear:N \l_fontspec_fake_embolden_tl
\tl_clear:N \l_fontspec_fontname_bfit_tl
\tl_clear:N \l_fontspec_fontname_sl_tl
\tl_clear:N \l_fontspec_fontname_bfsl_tl
\tl_clear:N \l_fontspec_fontname_sc_tl
\tl_clear:N \l_@@_fontfeat_up_clist
\tl_clear:N \l_@@_fontfeat_bf_clist
\tl_clear:N \l_@@_fontfeat_it_clist
\tl_clear:N \l_@@_fontfeat_bfit_clist
\tl_clear:N \l_@@_fontfeat_sl_clist
\tl_clear:N \l_@@_fontfeat_bfsl_clist
\tl_clear:N \l_@@_fontfeat_sc_clist
\tl_clear:N \l_@@_script_name_tl
\tl_clear:N \l_fontspec_script_tl
\tl_clear:N \l_@@_lang_name_tl
\tl_clear:N \l_fontspec_lang_tl
\tl_set:Nn  \g_@@_postadjust_tl { \l_@@_wordspace_adjust_tl \l_@@_punctspace_adjust_tl }

\clist_set:Nn \l_@@_sizefeat_clist {Size={-}}
\tl_new:N  \g_@@_hexcol_tl
\tl_new:N  \g_@@_opacity_tl
\tl_set:Nn \g_@@_hexcol_tl {000000}
\tl_set:Nn \g_@@_opacity_tl {FF~}
%    \end{macrocode}
% Or once per fontspec font invocation:
% (Some of these may be redundant.
% Check whether they're assigned to globally or not.)
%    \begin{macrocode}
\cs_set:Npn \@@_init:
 {
  \bool_set_false:N \l_@@_ot_bool
  \bool_set_true:N \l_@@_firsttime_bool
  \cs_set:Npn \@@_namewrap:n ##1 { ##1 }
  \tl_clear:N \l_@@_optical_size_tl
  \tl_clear:N \l_fontspec_renderer_tl
  \tl_clear:N \l_fontspec_defined_shapes_tl
  \tl_clear:N \g_@@_curr_series_tl

  % This is for detecting font families when assigning default features.
  % Replace defaults for the standard families because they're not set in the usual way:
  \exp_args:NV \str_case:nnn {\l_@@_family_label_tl}
   {
    {\rmdefault} { \tl_set:Nn \l_@@_family_label_tl {\g_@@_rmfamily_family} }
    {\sfdefault} { \tl_set:Nn \l_@@_family_label_tl {\g_@@_sffamily_family} }
    {\ttdefault} { \tl_set:Nn \l_@@_family_label_tl {\g_@@_ttfamily_family} }
   }{}

%<*luatex>
  \tl_set:Nn \l_fontspec_mode_tl {node}
  \luatexprehyphenchar   =`\-  % fixme
  \luatexposthyphenchar  = 0   % fixme
  \luatexpreexhyphenchar = 0   % fixme
  \luatexpostexhyphenchar= 0   % fixme
%</luatex>
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_make_smallcaps:TF}
% \label{mac:makesmallcaps}
% This macro checks if the font contains small caps.
%    \begin{macrocode}
\cs_set:Nn \fontspec_make_ot_smallcaps:TF
 {
  \fontspec_check_ot_feat:nTF {+smcp} {#1} {#2}
 }
%<*xetexx>
\cs_set:Nn \@@_make_smallcaps:TF
 {
  \bool_if:NTF \l_@@_ot_bool
   { \fontspec_make_ot_smallcaps:TF {#1} {#2} }
   {
     \bool_if:NT \l_@@_atsui_bool
      { \fontspec_make_AAT_feature_string:nnTF {3}{3} {#1} {#2} }
   }
 }
%</xetexx>
%<*luatex>
\cs_set_eq:NN \@@_make_smallcaps:TF \fontspec_make_ot_smallcaps:TF
%</luatex>
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\sclist_put_right:Nn}
% I'm hardly going to write an `sclist' module but a couple of functions are
% useful. Here, items in semi-colon lists are always followed by a semi-colon
% (as opposed to the s.-c's being placed between elements) so we can append
% sclists without worrying about it.
%    \begin{macrocode}
\cs_set_eq:NN \sclist_clear:N \tl_clear:N
\cs_new:Nn \sclist_gput_right:Nn
 { \tl_gput_right:Nn #1 {#2;} }
\cs_generate_variant:Nn \sclist_gput_right:Nn {Nx}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_update_featstr:n}
% \cmd{\l_@@_rawfeatures_sclist} is the string used to define the list of specific
% font features. Each time another font feature is requested, this
% macro is used to add that feature to the list. Font features are
% separated by semicolons.
%    \begin{macrocode}
\cs_new:Nn \@@_update_featstr:n
 {
  \bool_if:NF \l_@@_firsttime_bool
   {
    \sclist_gput_right:Nx \l_@@_rawfeatures_sclist {#1}
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\fontspec_make_feature:nnn}
%   This macro is called by each feature key selected, and runs
%   according to which type of font is selected.
%    \begin{macrocode}
\cs_new:Nn \fontspec_make_feature:nnn
%<*xetexx>
 {
  \bool_if:NTF \l_@@_ot_bool
   { \fontspec_make_OT_feature:n {#3} }
   {
     \bool_if:NT \l_@@_atsui_bool
      { \fontspec_make_AAT_feature:nn {#1}{#2} }
   }
 }
%</xetexx>
%<*luatex>
 { \fontspec_make_OT_feature:n {#3} }
%</luatex>
\cs_generate_variant:Nn \fontspec_make_feature:nnn {nnx}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new:Nn \fontspec_make_AAT_feature:nn
 {
  \tl_if_empty:nTF {#1}
   { \@@_warning:n {aat-feature-not-exist} }
   {
     \fontspec_make_AAT_feature_string:nnTF {#1}{#2}
      {
       \@@_update_featstr:n {\l_fontspec_feature_string_tl}
     }
     { \@@_warning:nx {aat-feature-not-exist-in-font} {#1,#2} }
   }
 }
\cs_new:Nn \fontspec_make_OT_feature:n
 {
  \tl_if_empty:nTF {#1}
   { \@@_warning:n {icu-feature-not-exist} }
   {
     \fontspec_check_ot_feat:nTF {#1}
      {
       \@@_update_featstr:n {#1}
      }
      { \@@_warning:nx {icu-feature-not-exist-in-font} {#1} }
   }
 }
\cs_new_protected:Nn \fontspec_make_numbered_feature:nn
 {
  \fontspec_check_ot_feat:nTF {#1}
   {
    \@@_update_featstr:n { #1 = #2 }
   }
   { \@@_warning:nx {icu-feature-not-exist-in-font} {#1} }
 }
\cs_generate_variant:Nn \fontspec_make_numbered_feature:nn {xn}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_define_font_feature:n}
% \begin{macro}{\@@_define_feature_option:nnnnn}
% \begin{macro}{\fontspec_define_numbered_feat:nnnn}
% These macros are used in order to simplify font feature definition later on.
%    \begin{macrocode}
\cs_new:Nn \@@_define_font_feature:n
 {
  \keys_define:nn {fontspec} { #1 .multichoice: }
 }
\cs_new:Nn \@@_define_feature_option:nnnnn
 {
  \keys_define:nn {fontspec}
   {
    #1/#2 .code:n = { \fontspec_make_feature:nnn{#3}{#4}{#5} }
   }
 }
\cs_new:Nn \fontspec_define_numbered_feat:nnnn
 {
  \keys_define:nn {fontspec}
   {
    #1/#2 .code:n =
      { \fontspec_make_numbered_feature:nn {#3}{#4} }
   }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\fontspec_make_AAT_feature_string:nnTF}
%   This macro takes the numerical codes for a font feature and
%   creates a specified macro containing the string required in the
%   font definition to turn that feature on or off. Used primarily in
%   [...], but also used to check if small caps
%   exists in the requested font (see page~\pageref{mac:makesmallcaps}).
%
% For exclusive selectors, it's easy; just grab the string:
% For \emph{non}-exclusive selectors, it's a little more complex.
% If the selector is even, it corresponds to switching the feature on.
% If the selector is \emph{odd}, it corresponds to switching the feature off.
% But \XeTeX\ doesn't return a selector string for this number, since the
% feature is defined for the `switching on' value. So we need to check the
% selector of the previous number, and then prefix the feature string with |!|
% to denote the switch.
%
% Finally, save out the complete feature string in \cmd\l_fontspec_feature_string_tl.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_make_AAT_feature_string:nn {TF,T,F}
 {
  \tl_set:Nx \l_tmpa_tl { \XeTeXfeaturename \l_fontspec_font #1 }
  \tl_if_empty:NTF \l_tmpa_tl
   { \prg_return_false: }
   {
    \int_compare:nTF { \XeTeXisexclusivefeature\l_fontspec_font #1 > 0 }
     {
      \tl_set:Nx \l_tmpb_tl {\XeTeXselectorname\l_fontspec_font #1\space #2}
     }
     {
      \int_if_even:nTF {#2}
       {
        \tl_set:Nx \l_tmpb_tl {\XeTeXselectorname\l_fontspec_font #1\space #2}
       }
       {
        \tl_set:Nx \l_tmpb_tl
         {
          \XeTeXselectorname\l_fontspec_font #1\space \numexpr#2-1\relax
         }
        \tl_if_empty:NF \l_tmpb_tl { \tl_put_left:Nn \l_tmpb_tl {!} }
       }
    }
    \tl_if_empty:NTF \l_tmpb_tl
     { \prg_return_false: }
     {
      \tl_set:Nx \l_fontspec_feature_string_tl { \l_tmpa_tl = \l_tmpb_tl }
      \prg_return_true:
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_iv_str_to_num:Nn}
% \begin{macro}{\fontspec_v_str_to_num:Nn}
% This macro takes a four character string and converts it to the
% numerical representation required for \XeTeX\ OpenType script/language/feature
% purposes. The output is stored in \cmd\l_fontspec_strnum_int.
%
% The reason it's ugly is because the input can be of the form of any of these:
% `|abcd|', `|abc|', `|abc |', `|ab|', `|ab  |', \etc.
% (It is assumed the first two chars are \emph{always} not spaces.) So this macro
% reads in the string, delimited by a space; this input is padded with \cmd\@empty s
% and anything beyond four chars is snipped. The \cmd\@empty s then are used to reconstruct
% the spaces in the string to number calculation.
%
% The variant \cmd\fontspec_v_str_to_num:n\ is used when looking at features, which are passed around
% with prepended plus and minus signs (\eg, \texttt{+liga}, \texttt{-dlig}); it
% simply strips off the first char of the input before calling the normal \cmd\fontspec_iv_str_to_num:n.
%    \begin{macrocode}
\cs_set:Nn \fontspec_iv_str_to_num:Nn
 {
  \fontspec_iv_str_to_num:w #1 \q_nil #2 \c_empty_tl \c_empty_tl \q_nil
 }
\cs_set:Npn \fontspec_iv_str_to_num:w #1 \q_nil #2#3#4#5#6 \q_nil
 {
  \int_set:Nn #1
   {
      `#2 * "1000000
    + `#3 * "10000
    + \ifx \c_empty_tl #4 32 \else `#4 \fi * "100
    + \ifx \c_empty_tl #5 32 \else `#5 \fi
   }
 }
\cs_generate_variant:Nn \fontspec_iv_str_to_num:Nn {No}
\cs_set:Nn \fontspec_v_str_to_num:Nn
 {
  \bool_if:nTF
   {
    \tl_if_head_eq_charcode_p:nN {#2} {+} ||
    \tl_if_head_eq_charcode_p:nN {#2} {-}
   }
   { \fontspec_iv_str_to_num:No #1 { \use_none:n #2 } }
   { \fontspec_iv_str_to_num:Nn #1 {#2} }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\fontspec_check_script:nTF}
% This macro takes an OpenType script tag and checks if it exists in the current
% font. The output boolean is \cmd\@tempswatrue. \cmd\l_fontspec_strnum_int\ is used to store
% the number corresponding to the script tag string.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_check_script:n {TF}
%<*xetexx>
 {
  \fontspec_iv_str_to_num:Nn \l_fontspec_strnum_int {#1}
  \int_set:Nn \l_tmpb_int { \XeTeXOTcountscripts \l_fontspec_font }
  \int_zero:N \l_tmpa_int
  \@tempswafalse
  \bool_until_do:nn { \int_compare_p:nNn \l_tmpa_int = \l_tmpb_int }
   {
    \ifnum \XeTeXOTscripttag\l_fontspec_font \l_tmpa_int = \l_fontspec_strnum_int
      \@tempswatrue
      \int_set:Nn \l_tmpa_int {\l_tmpb_int}
    \else
      \int_incr:N \l_tmpa_int
    \fi
   }
  \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
 }
%</xetexx>
%<*luatex>
 {
  \directlua{fontspec.check_ot_script("l_fontspec_font", "#1")}
  \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
 }
%</luatex>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_check_lang:nTF}
% This macro takes an OpenType language tag and checks if it exists in the current
% font/script. The output boolean is \cmd\@tempswatrue. \cmd\l_fontspec_strnum_int\ is used to store
% the number corresponding to the language tag string.
% The script used is whatever's held in \cmd\l_fontspec_script_int. By default, that's the
% number corresponding to `|latn|'.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_check_lang:n {TF}
%<*xetexx>
 {
  \fontspec_iv_str_to_num:Nn \l_fontspec_strnum_int {#1}
  \int_set:Nn \l_tmpb_int
   { \XeTeXOTcountlanguages \l_fontspec_font \l_fontspec_script_int }
  \int_zero:N \l_tmpa_int
  \@tempswafalse
  \bool_until_do:nn { \int_compare_p:nNn \l_tmpa_int = \l_tmpb_int }
   {
    \ifnum\XeTeXOTlanguagetag\l_fontspec_font\l_fontspec_script_int \l_tmpa_int =\l_fontspec_strnum_int
      \@tempswatrue
      \int_set:Nn \l_tmpa_int {\l_tmpb_int}
    \else
      \int_incr:N \l_tmpa_int
    \fi
   }
  \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
 }
%</xetexx>
%<*luatex>
 {
  \directlua
   {
    fontspec.check_ot_lang( "l_fontspec_font", "#1", "\l_fontspec_script_tl" )
   }
  \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
 }
%</luatex>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_check_ot_feat:nTF}
% \begin{macro}{\fontspec_check_ot_feat:nT}
% This macro takes an OpenType feature tag and checks if it exists in the current
% font/script/language.
% The output boolean is \cmd\@tempswa. \cmd\l_fontspec_strnum_int\ is used to store
% the number corresponding to the feature tag string.
% The script used is whatever's held in \cmd\l_fontspec_script_int. By default, that's the
% number corresponding to `|latn|'. The language used is \cmd\l_fontspec_language_int,
% by default |0|, the `default language'.
%    \begin{macrocode}
\prg_new_conditional:Nnn \fontspec_check_ot_feat:n {TF,T}
%<*xetexx>
 {
  \int_set:Nn \l_tmpb_int
   {
    \XeTeXOTcountfeatures \l_fontspec_font
                          \l_fontspec_script_int
                          \l_fontspec_language_int
   }
  \fontspec_v_str_to_num:Nn \l_fontspec_strnum_int {#1}
  \int_zero:N \l_tmpa_int
  \@tempswafalse
  \bool_until_do:nn { \int_compare_p:nNn \l_tmpa_int = \l_tmpb_int }
   {
    \ifnum\XeTeXOTfeaturetag\l_fontspec_font\l_fontspec_script_int\l_fontspec_language_int
         \l_tmpa_int =\l_fontspec_strnum_int
      \@tempswatrue
      \int_set:Nn \l_tmpa_int {\l_tmpb_int}
    \else
      \int_incr:N \l_tmpa_int
    \fi
   }
  \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
 }
%</xetexx>
%<*luatex>
 {
  \directlua
   {
    fontspec.check_ot_feat(
                           "l_fontspec_font", "#1",
                           "\l_fontspec_lang_tl", "\l_fontspec_script_tl"
                          )
   }
  \if@tempswa \prg_return_true: \else: \prg_return_false: \fi:
 }
%</luatex>
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{\pkg{keyval} definitions}
%
% This is the tedious section where we correlate all possible
% (eventually) font feature requests with their \XeTeX\ representations.
%
%    \begin{macrocode}
\cs_new:Nn \@@_keys_define_code:nnn
 {
  \keys_define:nn {#1} { #2 .code:n = {#3} } 
 }
%    \end{macrocode}
%
% \subsubsection{Pre-parsing naming information}
%
% These features are extracted from the font feature list before all others.
%
% \paragraph{\feat{ExternalLocation}}
% For fonts that aren't installed in the system. If no argument is given, the font is located
% with |kpsewhich|; it's either in the current directory or the \TeX\ tree. Otherwise, the
% argument given defines the file path of the font.
%    \begin{macrocode}
\bool_new:N \l_@@_external_bool
\@@_keys_define_code:nnn {fontspec-preparse-external} {ExternalLocation}
 {
  \bool_set_true:N \l_@@_nobf_bool
  \bool_set_true:N \l_@@_noit_bool
  \bool_set_true:N \l_@@_external_bool
  \cs_gset:Npn \@@_namewrap:n ##1 { [ #1 ##1 ] }
%<*xetexx>
  \keys_set:nn {fontspec-renderer} {Renderer=OpenType}
%</xetexx>
 }
\aliasfontfeature{ExternalLocation}{Path}
%    \end{macrocode}
%
% \paragraph{\feat{Extension}}
% For fonts that aren't installed in the system. Specifies the font extension
% to use.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse-external} {Extension}
 {
  \tl_set:Nn \l_@@_extension_tl {#1}
  \bool_if:NF \l_@@_external_bool
   {
    \keys_set:nn {fontspec-preparse-external} {ExternalLocation}
   }
 }
\tl_clear:N \l_@@_extension_tl
%    \end{macrocode}
%
% \subsubsection{Pre-parsed features}
%
% After the font name(s) have been sorted out, now need to extract any
% renderer/font configuration features that need to be processed before
% all other font features.
%
% \paragraph{\feat{Renderer}}
% This feature must be processed before all others (the other font shape and features options are also pre-parsed for convenience) because the renderer determines the format of the features and even whether certain features are available.
%    \begin{macrocode}
\keys_define:nn {fontspec-renderer}
 {
  Renderer .choice_code:n =
   {
    \int_compare:nTF {\l_keys_choice_int <= 3} {
%<*xetexx>
      \tl_set:Nv \l_fontspec_renderer_tl
        { g_fontspec_renderer_tag_ \l_keys_choice_tl }
%</xetexx>
%<*luatex>
      \@@_warning:nx {only-xetex-feature} {Renderer=AAT/OpenType/Graphite}
%</luatex>
     }
     {
%<*xetexx>
      \@@_warning:nx {only-luatex-feature} {Renderer=Full/Basic}
%</xetexx>
%<*luatex>
      \tl_set:Nv \l_fontspec_mode_tl
        { g_fontspec_mode_tag_ \l_keys_choice_tl }
%</luatex>
     }
   }
  ,
  Renderer .generate_choices:n = {AAT,ICU,OpenType,Graphite,Full,Basic}
 }
\tl_set:cn {g_fontspec_renderer_tag_AAT} {/AAT}
\tl_set:cn {g_fontspec_renderer_tag_ICU} {/OT}
\tl_set:cn {g_fontspec_renderer_tag_OpenType} {/OT}
\tl_set:cn {g_fontspec_renderer_tag_Graphite} {/GR}
\tl_set:cn {g_fontspec_mode_tag_Full}  {node}
\tl_set:cn {g_fontspec_mode_tag_Basic} {base}
%    \end{macrocode}
%
% \paragraph{OpenType script/language}
% See later for the resolutions from \pkg{fontspec} features to OpenType definitions.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {Script}
 {
%<xetexx>    \keys_set:nn {fontspec-renderer} {Renderer=OpenType}
  \tl_set:Nn \l_@@_script_name_tl {#1}
 }
%    \end{macrocode}
% Exactly the same:
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {Language}
 {
%<xetexx>    \keys_set:nn {fontspec-renderer} {Renderer=OpenType}
  \tl_set:Nn \l_@@_lang_name_tl {#1}
 }
%    \end{macrocode}
%
% \subsubsection{Bold/italic choosing options}
%
% The \feat{Bold}, \feat{Italic}, and \feat{BoldItalic}
% features are for defining explicitly the bold and italic fonts used
% in a font family.
%
% \paragraph{Bold (NFSS) Series}
% By default, \pkg{fontspec} uses the default bold series, \cs{bfdefault}.
% We want to be able to make this extensible.
%    \begin{macrocode}
\seq_new:N \g_@@_bf_series_seq
\@@_keys_define_code:nnn {fontspec-preparse-external} {BoldSeries}
 {
  \tl_gset:Nx \g_@@_curr_series_tl { #1 }
  \seq_gput_right:Nx \g_@@_bf_series_seq { #1 }
 }
%    \end{macrocode}
%
% \paragraph{Fonts}
% Upright:
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse-external} {UprightFont}
 {
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_up_tl {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse-external} {FontName}
 {
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_up_tl {#1}
 }
%    \end{macrocode}
% Bold:
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_if_eq:nnT {ox}
\cs_generate_variant:Nn \prop_put:Nnn {NxV}
\@@_keys_define_code:nnn {fontspec-preparse-external} {BoldFont}
 {
  \tl_if_empty:nTF {#1}
   {
    \bool_set_true:N \l_@@_nobf_bool
   }
   {
    \bool_set_false:N \l_@@_nobf_bool
    \fontspec_complete_fontname:Nn \l_@@_curr_bfname_tl {#1}
    
    \seq_if_empty:NT \g_@@_bf_series_seq
     {
      \tl_gset:Nx \g_@@_curr_series_tl {\bfdefault}
      \seq_put_right:Nx \g_@@_bf_series_seq {\bfdefault}
     }
    \tl_if_eq:oxT \g_@@_curr_series_tl {\bfdefault}
     { \tl_set_eq:NN \l_fontspec_fontname_bf_tl \l_@@_curr_bfname_tl }

%<debug>\typeout{Setting~bold~font~"\l_@@_curr_bfname_tl"~with~series~"\g_@@_curr_series_tl"}

    \prop_put:NxV \l_@@_nfss_prop
     {BoldFont-\g_@@_curr_series_tl} \l_@@_curr_bfname_tl

   }
 }
\prop_new:N \l_@@_nfss_prop
%    \end{macrocode}
% Same for italic:
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse-external} {ItalicFont}
 {
  \tl_if_empty:nTF {#1}
   {
    \bool_set_true:N \l_@@_noit_bool
   }
   {
    \bool_set_false:N \l_@@_noit_bool
    \fontspec_complete_fontname:Nn \l_fontspec_fontname_it_tl {#1}
   }
 }
%    \end{macrocode}
% Simpler for bold+italic \& slanted:
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse-external} {BoldItalicFont}
 {
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_bfit_tl {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse-external} {SlantedFont}
 {
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_sl_tl {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse-external} {BoldSlantedFont}
 {
  \fontspec_complete_fontname:Nn \l_fontspec_fontname_bfsl_tl {#1}
 }
%    \end{macrocode}
% Small caps isn't pre-parsed because it can vary with others above:
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {SmallCapsFont}
 {
  \tl_if_empty:nTF {#1}
   {
    \bool_set_true:N \l_@@_nosc_bool
   }
   {
    \bool_set_false:N \l_@@_nosc_bool
    \fontspec_complete_fontname:Nn \l_fontspec_fontname_sc_tl {#1}
   }
 }
%    \end{macrocode}
%
% \begin{macro}{\fontspec_complete_fontname:Nn}
% This macro defines |#1| as the input with any |*| tokens of its input
% replaced by the font name. This lets us define supplementary fonts in full
% (``\texttt{Baskerville Semibold}'') or in abbreviation (``\texttt{* Semibold}'').
%    \begin{macrocode}
\cs_set:Nn \fontspec_complete_fontname:Nn
 {
  \tl_set:Nx #1 {#2}
  \tl_replace_all:Nnx #1 {*} {\l_@@_basename_tl}
%<luatex>  \tl_remove_all:Nn #1 {~}
 }
\cs_generate_variant:Nn \tl_replace_all:Nnn {Nnx}
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Features}
%
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {UprightFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_up_clist {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse} {BoldFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_bf_clist {#1}
  
%  \prop_put:NxV \l_@@_nfss_prop
%     {BoldFont-\g_@@_curr_series_tl} \l_@@_curr_bfname_tl
 }
\@@_keys_define_code:nnn {fontspec-preparse} {ItalicFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_it_clist {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse} {BoldItalicFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_bfit_clist {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse} {SlantedFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_sl_clist {#1}
 }
\@@_keys_define_code:nnn {fontspec-preparse} {BoldSlantedFeatures}
 {
  \clist_set:Nn \l_@@_fontfeat_bfsl_clist {#1}
 }
%    \end{macrocode}
% Note that small caps features can vary by shape, so these in fact \emph{aren't} pre-parsed.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {SmallCapsFeatures}
 {
  \bool_if:NF \l_@@_firsttime_bool
   {
    \clist_set:Nn \l_@@_fontfeat_sc_clist {#1}
   }
 }
%    \end{macrocode}
%
% paragraph{Features varying by size}
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {SizeFeatures}
 {
  \clist_set:Nn \l_@@_sizefeat_clist {#1}
  \clist_put_right:Nn \l_@@_fontfeat_up_clist { SizeFeatures = {#1} }
 }
\@@_keys_define_code:nnn {fontspec-preparse-nested} {SizeFeatures}
 {
  \clist_set:Nn \l_@@_sizefeat_clist {#1}
  \tl_if_empty:NT \l_@@_this_font_tl
   { \tl_set:Nn \l_@@_this_font_tl { -- } } % needs to be non-empty as a flag
 }
\@@_keys_define_code:nnn {fontspec-preparse-nested} {Font}
 {
  \tl_set:Nn \l_@@_this_font_tl {#1}
 }
\@@_keys_define_code:nnn {fontspec} {SizeFeatures}
 {
  % dummy
 }
\@@_keys_define_code:nnn {fontspec} {Font}
 {
  % dummy
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-sizing} {Size}
 {
  \tl_set:Nn \l_@@_size_tl {#1}
 }
\@@_keys_define_code:nnn {fontspec-sizing} {Font}
 {
  \fontspec_complete_fontname:Nn \l_@@_sizedfont_tl {#1}
 }
%    \end{macrocode}
%
% \subsubsection{Font-independent features}
%
% These features can be applied to any font.
%
% \paragraph{NFSS family}
% Interactions with other packages will sometimes require setting the NFSS family explicitly.
% (By default \pkg{fontspec} auto-generates one based on the font name.)
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec-preparse} {NFSSFamily}
 {
  \tl_set:Nx \l_@@_nfss_fam_tl { #1 }
  \cs_undefine:c {g_@@_UID_\l_@@_fontid_tl}
  \tl_if_exist:NT \l_fontspec_family_tl
   { \cs_undefine:c {g_@@_ \l_fontspec_family_tl _prop} }
 }
%    \end{macrocode}
%
% \paragraph{NFSS series/shape}
% This option looks similar in name but has a very different function.
%    \begin{macrocode}
\cs_generate_variant:Nn \prop_put:Nnn {Nxx}
\prop_new:N \l_@@_nfssfont_prop
\@@_keys_define_code:nnn {fontspec} {FontFace}
 {
  \tl_set:No \l_@@_arg_tl { \use_iii:nnn #1 }
  \tl_set_eq:NN \l_@@_this_feat_tl \l_@@_arg_tl
  \tl_clear:N \l_@@_this_font_tl
  \int_compare:nT { \clist_count:N \l_@@_arg_tl = 1 }
   {
%<*debug>
    \typeout{FontFace~ parsing:~ one~ clist~ item}
%</debug>
    \tl_if_in:NnF \l_@@_arg_tl {=}
     {
%<*debug>
      \typeout{FontFace~ parsing:~ no~ equals~ =>~ font~ name~ only}
%</debug>
      \tl_set_eq:NN \l_@@_this_font_tl \l_@@_arg_tl
      \tl_clear:N \l_@@_this_feat_tl
     }
   }
   
  \@@_add_nfssfont:oooo
   {\use_i:nnn #1}{\use_ii:nnn #1}{\l_@@_this_font_tl}{\l_@@_this_feat_tl}
 }
%    \end{macrocode}
%
%
% \begin{macro}{\@@_add_nfssfont:nnnn}
% \darg{series}
% \darg{shape}
% \darg{fontname}
% \darg{fontspec features}
%    \begin{macrocode}
\cs_new:Nn \@@_add_nfssfont:nnnn
 {
  \tl_set:Nx \l_@@_this_font_tl {#3}

  \tl_if_empty:xTF {#4}
   { \clist_set:Nn \l_@@_sizefeat_clist {Size={-}} }
   { \keys_set_known:noN {fontspec-preparse-nested} {#4} \l_@@_tmp_tl }
   
  \tl_if_empty:NF \l_@@_this_font_tl
   {
    \prop_put:Nxx \l_@@_nfssfont_prop {#1/#2}
     { {#1}{#2}{\l_@@_this_font_tl}{#4}{\l_@@_sizefeat_clist} }
   }
 }
\cs_generate_variant:Nn \@@_add_nfssfont:nnnn {ooo}
\cs_generate_variant:Nn \@@_add_nfssfont:nnnn {oooo}
\cs_generate_variant:Nn \tl_if_empty:nTF {x}
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Scale}
% If the input isn't one of the pre-defined string options, then
% it's gotta be numerical. \cs{fontspec_calc_scale:n} does all the work in
% the auto-scaling cases.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {Scale}
 {
  \str_case:nnn {#1}
   {
    {MatchLowercase} { \@@_calc_scale:n {5} }
    {MatchUppercase} { \@@_calc_scale:n {8} }
   }
   { \tl_set:Nx \l_@@_scale_tl {#1} }
  \tl_set:Nx \l_@@_scale_tl { s*[\l_@@_scale_tl] }
 }
%    \end{macrocode}
%
% \begin{macro}{\@@_calc_scale:n}
% This macro calculates the amount of scaling between the default
% roman font and the (default shape of) the font being selected such
% that the font dimension that is input is equal for both. The only
% font dimensions that justify this are 5 (lowercase height)
% and 8 (uppercase height in \XeTeX).
%
% This script is executed for every extra shape, which seems wasteful,
% but allows alternate italic shapes from a separate font, say, to
% be loaded and to be auto-scaled correctly. Even if this would be ugly.
%    \begin{macrocode}
\cs_new:Nn \@@_calc_scale:n
 {
  \group_begin:
    \rmfamily
    \@@_set_font_dimen:NnN \l_@@_tmpa_dim {#1} \font
    \@@_set_font_dimen:NnN \l_@@_tmpb_dim {#1} \l_fontspec_font
    \tl_gset:Nx \l_@@_scale_tl
     {
      \fp_eval:n { \dim_to_fp:n {\l_@@_tmpa_dim} /
                   \dim_to_fp:n {\l_@@_tmpb_dim} }
     }
    \@@_info:n {set-scale}
  \group_end:
 }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_set_font_dimen:NnN}
% This function sets the dimension |#1| (for font |#3|) to `fontdimen' |#2|
% for either font dimension 5 (x-height) or 8 (cap-height). If, for some
% reason, these return an incorrect `zero' value (as \cs{fontdimen8} might
% for a \texttt{.tfm} font), then we cheat and measure the height of a glyph.
% We assume in this case that the font contains either an `X' or an `x'.
%    \begin{macrocode}
\cs_new:Nn \@@_set_font_dimen:NnN
 {
  \dim_set:Nn #1 { \fontdimen #2 #3 }
  \dim_compare:nNnT #1 = {0pt}
   {
    \settoheight #1
     {
      \str_if_eq:nnTF {#3} {\font} \rmfamily #3
      \int_case:nnn #2
       {
         {5} {x} % x-height
         {8} {X} % cap-height
       } {?} % "else" clause; never reached.
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
%
% \paragraph{Inter-word space}
% These options set the relevant \cmd\fontdimen s for the
% font being loaded.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {WordSpace}
 {
  \bool_if:NF \l_@@_firsttime_bool
   { \_fontspec_parse_wordspace:w #1,,,\q_stop }
 }
%    \end{macrocode}
%
% \begin{macro}{\_fontspec_parse_wordspace:w}
% This macro determines if the input to \feat{WordSpace} is
% of the form |{X}| or |{X,Y,Z}| and executes the font scaling.
% If the former input, it executes |{X,X,X}|.
%    \begin{macrocode}
\cs_set:Npn \_fontspec_parse_wordspace:w #1,#2,#3,#4 \q_stop
 {
  \tl_if_empty:nTF {#4}
   {
    \tl_set:Nn \l_@@_wordspace_adjust_tl
     {
      \fontdimen 2 \font = #1 \fontdimen 2 \font
      \fontdimen 3 \font = #1 \fontdimen 3 \font
      \fontdimen 4 \font = #1 \fontdimen 4 \font
     }
   }
   {
    \tl_set:Nn \l_@@_wordspace_adjust_tl
     {
      \fontdimen 2 \font = #1 \fontdimen 2 \font
      \fontdimen 3 \font = #2 \fontdimen 3 \font
      \fontdimen 4 \font = #3 \fontdimen 4 \font
     }
   }
 }
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Punctuation space}
% Scaling factor for the nominal \cmd\fontdimen \#7.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {PunctuationSpace}
 {
  \str_case_x:nnn {#1}
   {
    {WordSpace}
    {
     \tl_set:Nn \l_@@_punctspace_adjust_tl
      { \fontdimen 7 \font = 0 \fontdimen 2 \font }    
    }
    {TwiceWordSpace}
    {
     \tl_set:Nn \l_@@_punctspace_adjust_tl
      { \fontdimen 7 \font = 1 \fontdimen 2 \font }    
    }
   }
   {
     \tl_set:Nn \l_@@_punctspace_adjust_tl
     { \fontdimen 7 \font = #1 \fontdimen 7 \font }
   }
 }
%    \end{macrocode}
%
% \paragraph{Secret hook into the font-adjustment code}
%
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {FontAdjustment}
 {
  \tl_put_right:Nx \l_@@_postadjust_tl {#1}
 }
%    \end{macrocode}
%
% \paragraph{Letterspacing}
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {LetterSpace}
 {
  \@@_update_featstr:n {letterspace=#1}
 }
%    \end{macrocode}
%
% \paragraph{Hyphenation character}
% This feature takes one of three arguments: `\opt{None}',
% \meta{glyph}, or \meta{slot}. If the input isn't the first,
% and it's one character, then it's the second; otherwise, it's
% the third.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {HyphenChar}
 {
  \str_if_eq:nnTF {#1} {None}
   {
    \tl_put_right:Nn \l_@@_postadjust_tl
      { \hyphenchar \font = \c_minus_one }
   }
   {
    \tl_if_single:nTF {#1}
     { \tl_set:Nn \l_fontspec_hyphenchar_tl {`#1} }
     { \tl_set:Nn \l_fontspec_hyphenchar_tl { #1} }
    \font_glyph_if_exist:NnTF \l_fontspec_font {\l_fontspec_hyphenchar_tl}
     {
      \tl_put_right:Nn \l_@@_postadjust_tl
%<*xetexx>
        { \hyphenchar \font = \l_fontspec_hyphenchar_tl \scan_stop: }
%</xetexx>
%<*luatex>
        {
          \hyphenchar \font = \c_zero
          \luatexprehyphenchar = \l_fontspec_hyphenchar_tl \scan_stop:
        }
%</luatex>
     }
     { \@@_error:nx {no-glyph}{#1} }
   }
 }
%    \end{macrocode}
%
% \paragraph{Color}
% Hooks into pkg{xcolor}, which names its colours \texttt{\char`\\color@<name>}.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {Color}
 {
  \cs_if_exist:cTF { \token_to_str:N \color@ #1 }
   {
    \convertcolorspec{named}{#1}{HTML}\l_@@_hexcol_tl
   }
   {
    \int_compare:nTF { \tl_count:n {#1} == 6 }
     { \tl_set:Nn \l_@@_hexcol_tl {#1} }
     {
      \int_compare:nTF { \tl_count:n {#1} == 8 }
       { \fontspec_parse_colour:viii #1 }
       {
        \bool_if:NF \l_@@_firsttime_bool
         { \@@_warning:nx {bad-colour} {#1} }
       }
     }
   }
 }
\cs_set:Npn \fontspec_parse_colour:viii #1#2#3#4#5#6#7#8
 {
  \tl_set:Nn \l_@@_hexcol_tl {#1#2#3#4#5#6}
  \tl_if_eq:NNF \l_@@_opacity_tl \g_@@_opacity_tl
   {
    \bool_if:NF \l_@@_firsttime_bool
     { \@@_warning:nx {opa-twice-col} {#7#8} }
   }
  \tl_set:Nn \l_@@_opacity_tl {#7#8}
 }
\aliasfontfeature{Color}{Colour}
%    \end{macrocode}
%    \begin{macrocode}
\int_new:N \l_@@_tmp_int
\@@_keys_define_code:nnn {fontspec} {Opacity}
 {
  \int_set:Nn \l_@@_tmp_int {255}
  \@@_int_mult_truncate:Nn \l_@@_tmp_int { #1 }
  \tl_if_eq:NNF \l_@@_opacity_tl \g_@@_opacity_tl
   {
    \bool_if:NF \l_@@_firsttime_bool
     { \@@_warning:nx {opa-twice} {#1} }
   }
  \tl_set:Nx \l_@@_opacity_tl
   {
     \int_compare:nT { \l_@@_tmp_int <= "F } {0} % zero pad
     \int_to_hexadecimal:n { \l_@@_tmp_int }
   }
 }
%    \end{macrocode}
%
%
% \paragraph{Mapping}
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {Mapping}
%<*xetexx>
 {
  \@@_update_featstr:n { mapping = #1 }
 }
%</xetexx>
%<*luatex>
 {
  \str_if_eq:nnTF {#1} {tex-text}
   {
    \@@_warning:n {no-mapping-ligtex}
    \msg_redirect_name:nnn {fontspec} {no-mapping-ligtex} {none}
    \keys_set:nn {fontspec} { Ligatures=TeX }
   }
   { \@@_warning:n {no-mapping} }
 }
%</luatex>
%    \end{macrocode}
%
% \paragraph{FeatureFile}
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {FeatureFile}
 {
  \@@_update_featstr:n { featurefile = #1 }
 }
%    \end{macrocode}
%
%
% \subsubsection{Continuous font axes}
%
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {Weight}
 {
  \@@_update_featstr:n{weight=#1}
 }
\@@_keys_define_code:nnn {fontspec} {Width}
 {
  \@@_update_featstr:n{width=#1}
 }
\@@_keys_define_code:nnn {fontspec} {OpticalSize}
%<*xetexx>
 {
  \bool_if:NTF \l_@@_ot_bool
   {
    \tl_set:Nn \l_@@_optical_size_tl {/ S = #1}
   }
   {
    \bool_if:NT \l_@@_mm_bool
     {
      \@@_update_featstr:n { optical size = #1 }
     }
   }
  \bool_if:nT { !\l_@@_ot_bool && !\l_@@_mm_bool }
   {
    \bool_if:NT \l_@@_firsttime_bool
     { \@@_warning:n {no-opticals} }
   }
 }
%</xetexx>
%<*luatex>
 {
  \tl_set:Nn \l_@@_optical_size_tl {/ S = #1}
 }
%</luatex>
%    \end{macrocode}
%
% \subsubsection{Font transformations}
% These are to be specified to apply directly to a font shape:
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  FakeSlant .code:n =
   {
    \@@_update_featstr:n{slant=#1}
   },
  FakeSlant .default:n = {0.2}
}
\keys_define:nn {fontspec}
 {
  FakeStretch .code:n =
   {
    \@@_update_featstr:n{extend=#1}
   },
  FakeStretch .default:n = {1.2}
}
%<*xetexx>
\keys_define:nn {fontspec}
 {
  FakeBold .code:n =
   {
    \@@_update_featstr:n {embolden=#1}
   },
  FakeBold .default:n = {1.5}
 }
%</xetexx>
%<*luatex>
\keys_define:nn {fontspec}
 {
  FakeBold .code:n = { \@@_warning:n {fakebold-only-xetex} }
 }
%</luatex>
%    \end{macrocode}
% These are to be given to a shape that has no real bold/italic
% to signal that \pkg{fontspec} should automatically create `fake' shapes.
%
% The behaviour is currently that only if both \opt{AutoFakeSlant} \emph{and}
% \opt{AutoFakeBold} are specified, the bold italic is also faked.
%
% These features presently \emph{override} real shapes found in the font;
% in the future I'd like these features to be ignored in this case, instead.
% (This is just a bit harder to program in the current design of
% \pkg{fontspec}.)
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  AutoFakeSlant .code:n =
   {
    \bool_if:NT \l_@@_firsttime_bool
     {
      \tl_set:Nn \l_fontspec_fake_slant_tl {#1}
      \clist_put_right:Nn \l_@@_fontfeat_it_clist {FakeSlant=#1}
      \tl_set_eq:NN \l_fontspec_fontname_it_tl \l_fontspec_fontname_tl
      \bool_set_false:N \l_@@_noit_bool

      \tl_if_empty:NF \l_fontspec_fake_embolden_tl
       {
        \clist_put_right:Nx \l_@@_fontfeat_bfit_clist
         {FakeBold=\l_fontspec_fake_embolden_tl}
        \clist_put_right:Nx \l_@@_fontfeat_bfit_clist {FakeSlant=#1}
        \tl_set_eq:NN \l_fontspec_fontname_bfit_tl \l_fontspec_fontname_tl
       }
     }
   },
  AutoFakeSlant .default:n = {0.2}
}
%    \end{macrocode}
% Same but reversed:
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  AutoFakeBold .code:n =
   {
    \bool_if:NT \l_@@_firsttime_bool
     {
      \tl_set:Nn \l_fontspec_fake_embolden_tl {#1}
      \clist_put_right:Nn \l_@@_fontfeat_bf_clist {FakeBold=#1}
      \tl_set_eq:NN \l_fontspec_fontname_bf_tl \l_fontspec_fontname_tl
      \bool_set_false:N \l_@@_nobf_bool

      \tl_if_empty:NF \l_fontspec_fake_slant_tl
       {
        \clist_put_right:Nx \l_@@_fontfeat_bfit_clist
         {FakeSlant=\l_fontspec_fake_slant_tl}
        \clist_put_right:Nx \l_@@_fontfeat_bfit_clist {FakeBold=#1}
        \tl_set_eq:NN \l_fontspec_fontname_bfit_tl \l_fontspec_fontname_tl
       }
     }
   },
  AutoFakeBold .default:n = {1.5}
}
%    \end{macrocode}
%
%
% \subsubsection{Ligatures}
% The call to the nested keyval family must be wrapped in braces to
% hide the parent list (this later requires the use of global
% definitions (|\xdef|) in [...]). Both \AAT\ and OpenType
% names are offered to chose |Rare|/|Discretionary| ligatures.
%    \begin{macrocode}
\@@_define_font_feature:n{Ligatures}
\@@_define_feature_option:nnnnn{Ligatures}{Required}       {1}{0}{+rlig}
\@@_define_feature_option:nnnnn{Ligatures}{NoRequired}     {1}{1}{-rlig}
\@@_define_feature_option:nnnnn{Ligatures}{Common}         {1}{2}{+liga}
\@@_define_feature_option:nnnnn{Ligatures}{NoCommon}       {1}{3}{-liga}
\@@_define_feature_option:nnnnn{Ligatures}{Rare}           {1}{4}{+dlig}
\@@_define_feature_option:nnnnn{Ligatures}{NoRare}         {1}{5}{-dlig}
\@@_define_feature_option:nnnnn{Ligatures}{Discretionary}  {1}{4}{+dlig}
\@@_define_feature_option:nnnnn{Ligatures}{NoDiscretionary}{1}{5}{-dlig}
\@@_define_feature_option:nnnnn{Ligatures}{Contextual}     {}{}  {+clig}
\@@_define_feature_option:nnnnn{Ligatures}{NoContextual}   {}{}  {-clig}
\@@_define_feature_option:nnnnn{Ligatures}{Historic}       {}{}  {+hlig}
\@@_define_feature_option:nnnnn{Ligatures}{NoHistoric}     {}{}  {-hlig}
\@@_define_feature_option:nnnnn{Ligatures}{Logos}          {1}{6} {}
\@@_define_feature_option:nnnnn{Ligatures}{NoLogos}        {1}{7} {}
\@@_define_feature_option:nnnnn{Ligatures}{Rebus}          {1}{8} {}
\@@_define_feature_option:nnnnn{Ligatures}{NoRebus}        {1}{9} {}
\@@_define_feature_option:nnnnn{Ligatures}{Diphthong}      {1}{10}{}
\@@_define_feature_option:nnnnn{Ligatures}{NoDiphthong}    {1}{11}{}
\@@_define_feature_option:nnnnn{Ligatures}{Squared}        {1}{12}{}
\@@_define_feature_option:nnnnn{Ligatures}{NoSquared}      {1}{13}{}
\@@_define_feature_option:nnnnn{Ligatures}{AbbrevSquared}  {1}{14}{}
\@@_define_feature_option:nnnnn{Ligatures}{NoAbbrevSquared}{1}{15}{}
\@@_define_feature_option:nnnnn{Ligatures}{Icelandic}      {1}{32}{}
\@@_define_feature_option:nnnnn{Ligatures}{NoIcelandic}    {1}{33}{}
%    \end{macrocode}
% Emulate CM extra ligatures.
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  Ligatures / TeX .code:n =
   {
%<*xetexx>
    \@@_update_featstr:n { mapping = tex-text }
%</xetexx>
%<*luatex>
    \@@_update_featstr:n { +tlig; +trep }
%</luatex>
   }
 }
%    \end{macrocode}
%
% \subsubsection{Letters}
%    \begin{macrocode}
\@@_define_font_feature:n{Letters}
\@@_define_feature_option:nnnnn{Letters}{Normal}             {3}{0}{}
\@@_define_feature_option:nnnnn{Letters}{Uppercase}          {3}{1}{+case}
\@@_define_feature_option:nnnnn{Letters}{Lowercase}          {3}{2}{}
\@@_define_feature_option:nnnnn{Letters}{SmallCaps}          {3}{3}{+smcp}
\@@_define_feature_option:nnnnn{Letters}{PetiteCaps}         {} {} {+pcap}
\@@_define_feature_option:nnnnn{Letters}{UppercaseSmallCaps} {} {} {+c2sc}
\@@_define_feature_option:nnnnn{Letters}{UppercasePetiteCaps}{} {} {+c2pc}
\@@_define_feature_option:nnnnn{Letters}{InitialCaps}        {3}{4}{}
\@@_define_feature_option:nnnnn{Letters}{Unicase}            {} {} {+unic}
\@@_define_feature_option:nnnnn{Letters}{Random}             {} {} {+rand}
%    \end{macrocode}
%
% \subsubsection{Numbers}
%
% These were originally separated into \feat{NumberCase} and
% \feat{NumberSpacing} following \AAT, but it makes more sense to
% combine them.
%
% Both naming conventions are offered to select the number case.
%
%    \begin{macrocode}
\@@_define_font_feature:n{Numbers}
\@@_define_feature_option:nnnnn{Numbers}{Monospaced}   {6} {0}{+tnum}
\@@_define_feature_option:nnnnn{Numbers}{Proportional} {6} {1}{+pnum}
\@@_define_feature_option:nnnnn{Numbers}{Lowercase}    {21}{0}{+onum}
\@@_define_feature_option:nnnnn{Numbers}{OldStyle}     {21}{0}{+onum}
\@@_define_feature_option:nnnnn{Numbers}{Uppercase}    {21}{1}{+lnum}
\@@_define_feature_option:nnnnn{Numbers}{Lining}       {21}{1}{+lnum}
\@@_define_feature_option:nnnnn{Numbers}{SlashedZero}  {14}{5}{+zero}
\@@_define_feature_option:nnnnn{Numbers}{NoSlashedZero}{14}{4}{-zero}
%    \end{macrocode}
%
% |luaotload| provides a custom |anum| feature for replacing Latin
% (AKA Arabic) numbers with Arabic (AKA Indic-Arabic). The same feature
% maps to Farsi (Persian) numbers if font language is Farsi.
%
%    \begin{macrocode}
\luatex_if_engine:T
 {
  \@@_define_feature_option:nnnnn{Numbers}{Arabic}{}{}{+anum}
 }
%    \end{macrocode}
%
% \subsubsection{Contextuals}
%    \begin{macrocode}
\@@_define_font_feature:n  {Contextuals}
\@@_define_feature_option:nnnnn{Contextuals}{Swash}        {} {} {+cswh}
\@@_define_feature_option:nnnnn{Contextuals}{NoSwash}      {} {} {-cswh}
\@@_define_feature_option:nnnnn{Contextuals}{Alternate}    {} {} {+calt}
\@@_define_feature_option:nnnnn{Contextuals}{NoAlternate}  {} {} {-calt}
\@@_define_feature_option:nnnnn{Contextuals}{WordInitial}  {8}{0}{+init}
\@@_define_feature_option:nnnnn{Contextuals}{NoWordInitial}{8}{1}{-init}
\@@_define_feature_option:nnnnn{Contextuals}{WordFinal}    {8}{2}{+fina}
\@@_define_feature_option:nnnnn{Contextuals}{NoWordFinal}  {8}{3}{-fina}
\@@_define_feature_option:nnnnn{Contextuals}{LineInitial}  {8}{4}{}
\@@_define_feature_option:nnnnn{Contextuals}{NoLineInitial}{8}{5}{}
\@@_define_feature_option:nnnnn{Contextuals}{LineFinal}    {8}{6}{+falt}
\@@_define_feature_option:nnnnn{Contextuals}{NoLineFinal}  {8}{7}{-falt}
\@@_define_feature_option:nnnnn{Contextuals}{Inner}        {8}{8}{+medi}
\@@_define_feature_option:nnnnn{Contextuals}{NoInner}      {8}{9}{-medi}
%    \end{macrocode}
%
% \subsubsection{Diacritics}
%    \begin{macrocode}
\@@_define_font_feature:n{Diacritics}
\@@_define_feature_option:nnnnn{Diacritics}{Show}        {9}{0}{}
\@@_define_feature_option:nnnnn{Diacritics}{Hide}        {9}{1}{}
\@@_define_feature_option:nnnnn{Diacritics}{Decompose}   {9}{2}{}
\@@_define_feature_option:nnnnn{Diacritics}{MarkToBase}  {}{}{+mark}
\@@_define_feature_option:nnnnn{Diacritics}{NoMarkToBase}{}{}{-mark}
\@@_define_feature_option:nnnnn{Diacritics}{MarkToMark}  {}{}{+mkmk}
\@@_define_feature_option:nnnnn{Diacritics}{NoMarkToMark}{}{}{-mkmk}
\@@_define_feature_option:nnnnn{Diacritics}{AboveBase}   {}{}{+abvm}
\@@_define_feature_option:nnnnn{Diacritics}{NoAboveBase} {}{}{-abvm}
\@@_define_feature_option:nnnnn{Diacritics}{BelowBase}   {}{}{+blwm}
\@@_define_feature_option:nnnnn{Diacritics}{NoBelowBase} {}{}{-blwm}
%    \end{macrocode}
%
% \subsubsection{Kerning}
%    \begin{macrocode}
\@@_define_font_feature:n{Kerning}
\@@_define_feature_option:nnnnn{Kerning}{Uppercase}{}{}{+cpsp}
\@@_define_feature_option:nnnnn{Kerning}{On}       {}{}{+kern}
\@@_define_feature_option:nnnnn{Kerning}{Off}      {}{}{-kern}
%\@@_define_feature_option:nnnnn{Kerning}{Vertical}{}{}{+vkrn}
%\@@_define_feature_option:nnnnn{Kerning}
%    {VerticalAlternateProportional}{}{}{+vpal}
%\@@_define_feature_option:nnnnn{Kerning}{VerticalAlternateHalfWidth}{}{}{+vhal}
%    \end{macrocode}
%
% \subsubsection{Vertical position}
%    \begin{macrocode}
\@@_define_font_feature:n{VerticalPosition}
\@@_define_feature_option:nnnnn{VerticalPosition}{Normal}     {10}{0}{}
\@@_define_feature_option:nnnnn{VerticalPosition}{Superior}   {10}{1}{+sups}
\@@_define_feature_option:nnnnn{VerticalPosition}{Inferior}   {10}{2}{+subs}
\@@_define_feature_option:nnnnn{VerticalPosition}{Ordinal}    {10}{3}{+ordn}
\@@_define_feature_option:nnnnn{VerticalPosition}{Numerator}  {}  {} {+numr}
\@@_define_feature_option:nnnnn{VerticalPosition}{Denominator}{}  {} {+dnom}
\@@_define_feature_option:nnnnn{VerticalPosition}{ScientificInferior}{}{}{+sinf}
%    \end{macrocode}
%
% \subsubsection{Fractions}
%    \begin{macrocode}
\@@_define_font_feature:n{Fractions}
\@@_define_feature_option:nnnnn{Fractions}{On}       {11}{1}{+frac}
\@@_define_feature_option:nnnnn{Fractions}{Off}      {11}{0}{-frac}
\@@_define_feature_option:nnnnn{Fractions}{Diagonal} {11}{2}{}
\@@_define_feature_option:nnnnn{Fractions}{Alternate}{}  {} {+afrc}
%    \end{macrocode}
%
% \subsubsection{Alternates and variants}
% Selected numerically because they don't have standard names. Very
% easy to process, very annoying for the user!
%
%    \begin{macrocode}
\@@_define_font_feature:n { Alternate }
\keys_define:nn {fontspec}
 {
  Alternate .default:n = {0} ,
  Alternate / unknown .code:n =
   {
    \clist_map_inline:nn {#1}
      { \fontspec_make_feature:nnx {17}{##1} { \fontspec_salt:n {##1} } }
   }
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set:Nn \fontspec_salt:n { +salt = #1 }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_define_font_feature:n {Variant}
\keys_define:nn {fontspec}
 {
  Variant .default:n = {0} ,
  Variant / unknown .code:n =
   {
    \clist_map_inline:nn {#1}
      { \fontspec_make_feature:nnx {18}{##1} { +ss \two@digits {##1} } }
   }
 }
\aliasfontfeature{Variant}{StylisticSet}
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_define_font_feature:n { CharacterVariant }
\use:x
 {
  \cs_new:Npn \exp_not:N \fontspec_parse_cv:w
      ##1 \c_colon_str ##2 \c_colon_str ##3 \exp_not:N \q_nil
   {
     \fontspec_make_numbered_feature:xn
       { +cv \exp_not:N \two@digits {##1} } {##2}
   }
  \keys_define:nn {fontspec}
   {
    CharacterVariant / unknown .code:n =
     {
      \clist_map_inline:nn {##1}
       {
        \exp_not:N \fontspec_parse_cv:w
          ####1 \c_colon_str 0 \c_colon_str \exp_not:N \q_nil
       }
     }
   }
 }
%    \end{macrocode}
% Possibilities: \verb|a:0:\q_nil| or \verb|a:b:0:\q_nil|.
%
%
%
% \subsubsection{Style}
%    \begin{macrocode}
\@@_define_font_feature:n{Style}
\@@_define_feature_option:nnnnn{Style}{Alternate}     {}  {} {+salt}
\@@_define_feature_option:nnnnn{Style}{Italic}        {32}{2}{+ital}
\@@_define_feature_option:nnnnn{Style}{Ruby}          {28}{2}{+ruby}
\@@_define_feature_option:nnnnn{Style}{Swash}         {}  {} {+swsh}
\@@_define_feature_option:nnnnn{Style}{Historic}      {}  {} {+hist}
\@@_define_feature_option:nnnnn{Style}{Display}       {19}{1}{}
\@@_define_feature_option:nnnnn{Style}{Engraved}      {19}{2}{}
\@@_define_feature_option:nnnnn{Style}{TitlingCaps}   {19}{4}{+titl}
\@@_define_feature_option:nnnnn{Style}{TallCaps}      {19}{5}{}
\@@_define_feature_option:nnnnn{Style}{HorizontalKana}{}  {} {+hkna}
\@@_define_feature_option:nnnnn{Style}{VerticalKana}  {}  {} {+vkna}
\fontspec_define_numbered_feat:nnnn {Style} {MathScript}       {+ssty} {0}
\fontspec_define_numbered_feat:nnnn {Style} {MathScriptScript} {+ssty} {1}
%    \end{macrocode}
%
% \subsubsection{CJK shape}
%    \begin{macrocode}
\@@_define_font_feature:n{CJKShape}
\@@_define_feature_option:nnnnn{CJKShape}{Traditional}{20}{0} {+trad}
\@@_define_feature_option:nnnnn{CJKShape}{Simplified} {20}{1} {+smpl}
\@@_define_feature_option:nnnnn{CJKShape}{JIS1978}    {20}{2} {+jp78}
\@@_define_feature_option:nnnnn{CJKShape}{JIS1983}    {20}{3} {+jp83}
\@@_define_feature_option:nnnnn{CJKShape}{JIS1990}    {20}{4} {+jp90}
\@@_define_feature_option:nnnnn{CJKShape}{Expert}     {20}{10}{+expt}
\@@_define_feature_option:nnnnn{CJKShape}{NLC}        {20}{13}{+nlck}
%    \end{macrocode}
%
% \subsubsection{Character width}
%    \begin{macrocode}
\@@_define_font_feature:n{CharacterWidth}
\@@_define_feature_option:nnnnn{CharacterWidth}{Proportional}{22}{0}{+pwid}
\@@_define_feature_option:nnnnn{CharacterWidth}{Full}{22}{1}{+fwid}
\@@_define_feature_option:nnnnn{CharacterWidth}{Half}{22}{2}{+hwid}
\@@_define_feature_option:nnnnn{CharacterWidth}{Third}{22}{3}{+twid}
\@@_define_feature_option:nnnnn{CharacterWidth}{Quarter}{22}{4}{+qwid}
\@@_define_feature_option:nnnnn{CharacterWidth}{AlternateProportional}{22}{5}{+palt}
\@@_define_feature_option:nnnnn{CharacterWidth}{AlternateHalf}{22}{6}{+halt}
\@@_define_feature_option:nnnnn{CharacterWidth}{Default}{22}{7}{}
%    \end{macrocode}
%
% \subsubsection{Annotation}
%    \begin{macrocode}
\@@_define_feature_option:nnnnn{Annotation}{Off}{24}{0}{}
\@@_define_feature_option:nnnnn{Annotation}{Box}{24}{1}{}
\@@_define_feature_option:nnnnn{Annotation}{RoundedBox}{24}{2}{}
\@@_define_feature_option:nnnnn{Annotation}{Circle}{24}{3}{}
\@@_define_feature_option:nnnnn{Annotation}{BlackCircle}{24}{4}{}
\@@_define_feature_option:nnnnn{Annotation}{Parenthesis}{24}{5}{}
\@@_define_feature_option:nnnnn{Annotation}{Period}{24}{6}{}
\@@_define_feature_option:nnnnn{Annotation}{RomanNumerals}{24}{7}{}
\@@_define_feature_option:nnnnn{Annotation}{Diamond}{24}{8}{}
\@@_define_feature_option:nnnnn{Annotation}{BlackSquare}{24}{9}{}
\@@_define_feature_option:nnnnn{Annotation}{BlackRoundSquare}{24}{10}{}
\@@_define_feature_option:nnnnn{Annotation}{DoubleCircle}{24}{11}{}
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_define_font_feature:n { Annotation }
\keys_define:nn {fontspec}
 {
  Annotation .default:n = {0} ,
  Annotation / unknown .code:n =
   {
    \fontspec_make_feature:nnx {}{}{ +nalt=#1 }
   }
 }
%    \end{macrocode}
%
%
% \subsubsection{Vertical}
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  Vertical .choice: ,
  Vertical / RotatedGlyphs .code:n =
   {
    \bool_if:NTF \l_@@_ot_bool
     {
      \fontspec_make_feature:nnn{}{}{+vrt2}
      \@@_update_featstr:n {vertical}
     }
     {
      \@@_update_featstr:n {vertical}
     }
   }
 }
%    \end{macrocode}
%
% \subsubsection{Script}
%    \begin{macrocode}
\newfontscript{Arabic}{arab}            \newfontscript{Armenian}{armn}
\newfontscript{Balinese}{bali}          \newfontscript{Bengali}{beng}
\newfontscript{Bopomofo}{bopo}          \newfontscript{Braille}{brai}
\newfontscript{Buginese}{bugi}          \newfontscript{Buhid}{buhd}
\newfontscript{Byzantine~Music}{byzm}
\newfontscript{Canadian~Syllabics}{cans}
\newfontscript{Cherokee}{cher}
\newfontscript{CJK~Ideographic}{hani}   \newfontscript{Coptic}{copt}
\newfontscript{Cypriot~Syllabary}{cprt} \newfontscript{Cyrillic}{cyrl}
\newfontscript{Default}{DFLT}           \newfontscript{Deseret}{dsrt}
\newfontscript{Devanagari}{deva}        \newfontscript{Ethiopic}{ethi}
\newfontscript{Georgian}{geor}          \newfontscript{Glagolitic}{glag}
\newfontscript{Gothic}{goth}            \newfontscript{Greek}{grek}
\newfontscript{Gujarati}{gujr}          \newfontscript{Gurmukhi}{guru}
\newfontscript{Hangul~Jamo}{jamo}       \newfontscript{Hangul}{hang}
\newfontscript{Hanunoo}{hano}           \newfontscript{Hebrew}{hebr}
\newfontscript{Hiragana~and~Katakana}{kana}
\newfontscript{Javanese}{java}          \newfontscript{Kannada}{knda}
\newfontscript{Kharosthi}{khar}         \newfontscript{Khmer}{khmr}
\newfontscript{Lao}{lao~}               \newfontscript{Latin}{latn}
\newfontscript{Limbu}{limb}             \newfontscript{Linear~B}{linb}
\newfontscript{Malayalam}{mlym}         \newfontscript{Math}{math}
\newfontscript{Mongolian}{mong}
\newfontscript{Musical~Symbols}{musc}   \newfontscript{Myanmar}{mymr}
\newfontscript{N'ko}{nko~}              \newfontscript{Ogham}{ogam}
\newfontscript{Old~Italic}{ital}
\newfontscript{Old~Persian~Cuneiform}{xpeo}
\newfontscript{Oriya}{orya}             \newfontscript{Osmanya}{osma}
\newfontscript{Phags-pa}{phag}          \newfontscript{Phoenician}{phnx}
\newfontscript{Runic}{runr}             \newfontscript{Shavian}{shaw}
\newfontscript{Sinhala}{sinh}
\newfontscript{Sumero-Akkadian~Cuneiform}{xsux}
\newfontscript{Syloti~Nagri}{sylo}      \newfontscript{Syriac}{syrc}
\newfontscript{Tagalog}{tglg}           \newfontscript{Tagbanwa}{tagb}
\newfontscript{Tai~Le}{tale}            \newfontscript{Tai~Lu}{talu}
\newfontscript{Tamil}{taml}             \newfontscript{Telugu}{telu}
\newfontscript{Thaana}{thaa}            \newfontscript{Thai}{thai}
\newfontscript{Tibetan}{tibt}           \newfontscript{Tifinagh}{tfng}
\newfontscript{Ugaritic~Cuneiform}{ugar}\newfontscript{Yi}{yi~~}
%    \end{macrocode}
% For convenience:
%    \begin{macrocode}
\newfontscript{Kana}{kana}
\newfontscript{Maths}{math}
\newfontscript{CJK}{hani}
%    \end{macrocode}
%
% \subsubsection{Language}
%    \begin{macrocode}
\newfontlanguage{Abaza}{ABA}\newfontlanguage{Abkhazian}{ABK}
\newfontlanguage{Adyghe}{ADY}\newfontlanguage{Afrikaans}{AFK}
\newfontlanguage{Afar}{AFR}\newfontlanguage{Agaw}{AGW}
\newfontlanguage{Altai}{ALT}\newfontlanguage{Amharic}{AMH}
\newfontlanguage{Arabic}{ARA}\newfontlanguage{Aari}{ARI}
\newfontlanguage{Arakanese}{ARK}\newfontlanguage{Assamese}{ASM}
\newfontlanguage{Athapaskan}{ATH}\newfontlanguage{Avar}{AVR}
\newfontlanguage{Awadhi}{AWA}\newfontlanguage{Aymara}{AYM}
\newfontlanguage{Azeri}{AZE}\newfontlanguage{Badaga}{BAD}
\newfontlanguage{Baghelkhandi}{BAG}\newfontlanguage{Balkar}{BAL}
\newfontlanguage{Baule}{BAU}\newfontlanguage{Berber}{BBR}
\newfontlanguage{Bench}{BCH}\newfontlanguage{Bible~Cree}{BCR}
\newfontlanguage{Belarussian}{BEL}\newfontlanguage{Bemba}{BEM}
\newfontlanguage{Bengali}{BEN}\newfontlanguage{Bulgarian}{BGR}
\newfontlanguage{Bhili}{BHI}\newfontlanguage{Bhojpuri}{BHO}
\newfontlanguage{Bikol}{BIK}\newfontlanguage{Bilen}{BIL}
\newfontlanguage{Blackfoot}{BKF}\newfontlanguage{Balochi}{BLI}
\newfontlanguage{Balante}{BLN}\newfontlanguage{Balti}{BLT}
\newfontlanguage{Bambara}{BMB}\newfontlanguage{Bamileke}{BML}
\newfontlanguage{Breton}{BRE}\newfontlanguage{Brahui}{BRH}
\newfontlanguage{Braj~Bhasha}{BRI}\newfontlanguage{Burmese}{BRM}
\newfontlanguage{Bashkir}{BSH}\newfontlanguage{Beti}{BTI}
\newfontlanguage{Catalan}{CAT}\newfontlanguage{Cebuano}{CEB}
\newfontlanguage{Chechen}{CHE}\newfontlanguage{Chaha~Gurage}{CHG}
\newfontlanguage{Chattisgarhi}{CHH}\newfontlanguage{Chichewa}{CHI}
\newfontlanguage{Chukchi}{CHK}\newfontlanguage{Chipewyan}{CHP}
\newfontlanguage{Cherokee}{CHR}\newfontlanguage{Chuvash}{CHU}
\newfontlanguage{Comorian}{CMR}\newfontlanguage{Coptic}{COP}
\newfontlanguage{Cree}{CRE}\newfontlanguage{Carrier}{CRR}
\newfontlanguage{Crimean~Tatar}{CRT}\newfontlanguage{Church~Slavonic}{CSL}
\newfontlanguage{Czech}{CSY}\newfontlanguage{Danish}{DAN}
\newfontlanguage{Dargwa}{DAR}\newfontlanguage{Woods~Cree}{DCR}
\newfontlanguage{German}{DEU}
\newfontlanguage{Dogri}{DGR}\newfontlanguage{Divehi}{DIV}
\newfontlanguage{Djerma}{DJR}\newfontlanguage{Dangme}{DNG}
\newfontlanguage{Dinka}{DNK}\newfontlanguage{Dungan}{DUN}
\newfontlanguage{Dzongkha}{DZN}\newfontlanguage{Ebira}{EBI}
\newfontlanguage{Eastern~Cree}{ECR}\newfontlanguage{Edo}{EDO}
\newfontlanguage{Efik}{EFI}\newfontlanguage{Greek}{ELL}
\newfontlanguage{English}{ENG}\newfontlanguage{Erzya}{ERZ}
\newfontlanguage{Spanish}{ESP}\newfontlanguage{Estonian}{ETI}
\newfontlanguage{Basque}{EUQ}\newfontlanguage{Evenki}{EVK}
\newfontlanguage{Even}{EVN}\newfontlanguage{Ewe}{EWE}
\newfontlanguage{French~Antillean}{FAN}
\newfontlanguage{Farsi}{FAR}
\newfontlanguage{Parsi}{FAR}
\newfontlanguage{Persian}{FAR}
\newfontlanguage{Finnish}{FIN}\newfontlanguage{Fijian}{FJI}
\newfontlanguage{Flemish}{FLE}\newfontlanguage{Forest~Nenets}{FNE}
\newfontlanguage{Fon}{FON}\newfontlanguage{Faroese}{FOS}
\newfontlanguage{French}{FRA}\newfontlanguage{Frisian}{FRI}
\newfontlanguage{Friulian}{FRL}\newfontlanguage{Futa}{FTA}
\newfontlanguage{Fulani}{FUL}\newfontlanguage{Ga}{GAD}
\newfontlanguage{Gaelic}{GAE}\newfontlanguage{Gagauz}{GAG}
\newfontlanguage{Galician}{GAL}\newfontlanguage{Garshuni}{GAR}
\newfontlanguage{Garhwali}{GAW}\newfontlanguage{Ge'ez}{GEZ}
\newfontlanguage{Gilyak}{GIL}\newfontlanguage{Gumuz}{GMZ}
\newfontlanguage{Gondi}{GON}\newfontlanguage{Greenlandic}{GRN}
\newfontlanguage{Garo}{GRO}\newfontlanguage{Guarani}{GUA}
\newfontlanguage{Gujarati}{GUJ}\newfontlanguage{Haitian}{HAI}
\newfontlanguage{Halam}{HAL}\newfontlanguage{Harauti}{HAR}
\newfontlanguage{Hausa}{HAU}\newfontlanguage{Hawaiin}{HAW}
\newfontlanguage{Hammer-Banna}{HBN}\newfontlanguage{Hiligaynon}{HIL}
\newfontlanguage{Hindi}{HIN}\newfontlanguage{High~Mari}{HMA}
\newfontlanguage{Hindko}{HND}\newfontlanguage{Ho}{HO}
\newfontlanguage{Harari}{HRI}\newfontlanguage{Croatian}{HRV}
\newfontlanguage{Hungarian}{HUN}\newfontlanguage{Armenian}{HYE}
\newfontlanguage{Igbo}{IBO}\newfontlanguage{Ijo}{IJO}
\newfontlanguage{Ilokano}{ILO}\newfontlanguage{Indonesian}{IND}
\newfontlanguage{Ingush}{ING}\newfontlanguage{Inuktitut}{INU}
\newfontlanguage{Irish}{IRI}\newfontlanguage{Irish~Traditional}{IRT}
\newfontlanguage{Icelandic}{ISL}\newfontlanguage{Inari~Sami}{ISM}
\newfontlanguage{Italian}{ITA}\newfontlanguage{Hebrew}{IWR}
\newfontlanguage{Javanese}{JAV}\newfontlanguage{Yiddish}{JII}
\newfontlanguage{Japanese}{JAN}\newfontlanguage{Judezmo}{JUD}
\newfontlanguage{Jula}{JUL}\newfontlanguage{Kabardian}{KAB}
\newfontlanguage{Kachchi}{KAC}\newfontlanguage{Kalenjin}{KAL}
\newfontlanguage{Kannada}{KAN}\newfontlanguage{Karachay}{KAR}
\newfontlanguage{Georgian}{KAT}\newfontlanguage{Kazakh}{KAZ}
\newfontlanguage{Kebena}{KEB}\newfontlanguage{Khutsuri~Georgian}{KGE}
\newfontlanguage{Khakass}{KHA}\newfontlanguage{Khanty-Kazim}{KHK}
\newfontlanguage{Khmer}{KHM}\newfontlanguage{Khanty-Shurishkar}{KHS}
\newfontlanguage{Khanty-Vakhi}{KHV}\newfontlanguage{Khowar}{KHW}
\newfontlanguage{Kikuyu}{KIK}\newfontlanguage{Kirghiz}{KIR}
\newfontlanguage{Kisii}{KIS}\newfontlanguage{Kokni}{KKN}
\newfontlanguage{Kalmyk}{KLM}\newfontlanguage{Kamba}{KMB}
\newfontlanguage{Kumaoni}{KMN}\newfontlanguage{Komo}{KMO}
\newfontlanguage{Komso}{KMS}\newfontlanguage{Kanuri}{KNR}
\newfontlanguage{Kodagu}{KOD}\newfontlanguage{Korean~Old~Hangul}{KOH}
\newfontlanguage{Konkani}{KOK}\newfontlanguage{Kikongo}{KON}
\newfontlanguage{Komi-Permyak}{KOP}\newfontlanguage{Korean}{KOR}
\newfontlanguage{Komi-Zyrian}{KOZ}\newfontlanguage{Kpelle}{KPL}
\newfontlanguage{Krio}{KRI}\newfontlanguage{Karakalpak}{KRK}
\newfontlanguage{Karelian}{KRL}\newfontlanguage{Karaim}{KRM}
\newfontlanguage{Karen}{KRN}\newfontlanguage{Koorete}{KRT}
\newfontlanguage{Kashmiri}{KSH}\newfontlanguage{Khasi}{KSI}
\newfontlanguage{Kildin~Sami}{KSM}\newfontlanguage{Kui}{KUI}
\newfontlanguage{Kulvi}{KUL}\newfontlanguage{Kumyk}{KUM}
\newfontlanguage{Kurdish}{KUR}\newfontlanguage{Kurukh}{KUU}
\newfontlanguage{Kuy}{KUY}\newfontlanguage{Koryak}{KYK}
\newfontlanguage{Ladin}{LAD}\newfontlanguage{Lahuli}{LAH}
\newfontlanguage{Lak}{LAK}\newfontlanguage{Lambani}{LAM}
\newfontlanguage{Lao}{LAO}\newfontlanguage{Latin}{LAT}
\newfontlanguage{Laz}{LAZ}\newfontlanguage{L-Cree}{LCR}
\newfontlanguage{Ladakhi}{LDK}\newfontlanguage{Lezgi}{LEZ}
\newfontlanguage{Lingala}{LIN}\newfontlanguage{Low~Mari}{LMA}
\newfontlanguage{Limbu}{LMB}\newfontlanguage{Lomwe}{LMW}
\newfontlanguage{Lower~Sorbian}{LSB}\newfontlanguage{Lule~Sami}{LSM}
\newfontlanguage{Lithuanian}{LTH}\newfontlanguage{Luba}{LUB}
\newfontlanguage{Luganda}{LUG}\newfontlanguage{Luhya}{LUH}
\newfontlanguage{Luo}{LUO}\newfontlanguage{Latvian}{LVI}
\newfontlanguage{Majang}{MAJ}\newfontlanguage{Makua}{MAK}
\newfontlanguage{Malayalam~Traditional}{MAL}\newfontlanguage{Mansi}{MAN}
\newfontlanguage{Marathi}{MAR}\newfontlanguage{Marwari}{MAW}
\newfontlanguage{Mbundu}{MBN}\newfontlanguage{Manchu}{MCH}
\newfontlanguage{Moose~Cree}{MCR}\newfontlanguage{Mende}{MDE}
\newfontlanguage{Me'en}{MEN}\newfontlanguage{Mizo}{MIZ}
\newfontlanguage{Macedonian}{MKD}\newfontlanguage{Male}{MLE}
\newfontlanguage{Malagasy}{MLG}\newfontlanguage{Malinke}{MLN}
\newfontlanguage{Malayalam~Reformed}{MLR}\newfontlanguage{Malay}{MLY}
\newfontlanguage{Mandinka}{MND}\newfontlanguage{Mongolian}{MNG}
\newfontlanguage{Manipuri}{MNI}\newfontlanguage{Maninka}{MNK}
\newfontlanguage{Manx~Gaelic}{MNX}\newfontlanguage{Moksha}{MOK}
\newfontlanguage{Moldavian}{MOL}\newfontlanguage{Mon}{MON}
\newfontlanguage{Moroccan}{MOR}\newfontlanguage{Maori}{MRI}
\newfontlanguage{Maithili}{MTH}\newfontlanguage{Maltese}{MTS}
\newfontlanguage{Mundari}{MUN}\newfontlanguage{Naga-Assamese}{NAG}
\newfontlanguage{Nanai}{NAN}\newfontlanguage{Naskapi}{NAS}
\newfontlanguage{N-Cree}{NCR}\newfontlanguage{Ndebele}{NDB}
\newfontlanguage{Ndonga}{NDG}\newfontlanguage{Nepali}{NEP}
\newfontlanguage{Newari}{NEW}\newfontlanguage{Nagari}{NGR}
\newfontlanguage{Norway~House~Cree}{NHC}\newfontlanguage{Nisi}{NIS}
\newfontlanguage{Niuean}{NIU}\newfontlanguage{Nkole}{NKL}
\newfontlanguage{N'ko}{NKO}\newfontlanguage{Dutch}{NLD}
\newfontlanguage{Nogai}{NOG}\newfontlanguage{Norwegian}{NOR}
\newfontlanguage{Northern~Sami}{NSM}\newfontlanguage{Northern~Tai}{NTA}
\newfontlanguage{Esperanto}{NTO}\newfontlanguage{Nynorsk}{NYN}
\newfontlanguage{Oji-Cree}{OCR}\newfontlanguage{Ojibway}{OJB}
\newfontlanguage{Oriya}{ORI}\newfontlanguage{Oromo}{ORO}
\newfontlanguage{Ossetian}{OSS}\newfontlanguage{Palestinian~Aramaic}{PAA}
\newfontlanguage{Pali}{PAL}\newfontlanguage{Punjabi}{PAN}
\newfontlanguage{Palpa}{PAP}\newfontlanguage{Pashto}{PAS}
\newfontlanguage{Polytonic~Greek}{PGR}\newfontlanguage{Pilipino}{PIL}
\newfontlanguage{Palaung}{PLG}\newfontlanguage{Polish}{PLK}
\newfontlanguage{Provencal}{PRO}\newfontlanguage{Portuguese}{PTG}
\newfontlanguage{Chin}{QIN}\newfontlanguage{Rajasthani}{RAJ}
\newfontlanguage{R-Cree}{RCR}\newfontlanguage{Russian~Buriat}{RBU}
\newfontlanguage{Riang}{RIA}\newfontlanguage{Rhaeto-Romanic}{RMS}
\newfontlanguage{Romanian}{ROM}\newfontlanguage{Romany}{ROY}
\newfontlanguage{Rusyn}{RSY}\newfontlanguage{Ruanda}{RUA}
\newfontlanguage{Russian}{RUS}\newfontlanguage{Sadri}{SAD}
\newfontlanguage{Sanskrit}{SAN}\newfontlanguage{Santali}{SAT}
\newfontlanguage{Sayisi}{SAY}\newfontlanguage{Sekota}{SEK}
\newfontlanguage{Selkup}{SEL}\newfontlanguage{Sango}{SGO}
\newfontlanguage{Shan}{SHN}\newfontlanguage{Sibe}{SIB}
\newfontlanguage{Sidamo}{SID}\newfontlanguage{Silte~Gurage}{SIG}
\newfontlanguage{Skolt~Sami}{SKS}\newfontlanguage{Slovak}{SKY}
\newfontlanguage{Slavey}{SLA}\newfontlanguage{Slovenian}{SLV}
\newfontlanguage{Somali}{SML}\newfontlanguage{Samoan}{SMO}
\newfontlanguage{Sena}{SNA}\newfontlanguage{Sindhi}{SND}
\newfontlanguage{Sinhalese}{SNH}\newfontlanguage{Soninke}{SNK}
\newfontlanguage{Sodo~Gurage}{SOG}\newfontlanguage{Sotho}{SOT}
\newfontlanguage{Albanian}{SQI}\newfontlanguage{Serbian}{SRB}
\newfontlanguage{Saraiki}{SRK}\newfontlanguage{Serer}{SRR}
\newfontlanguage{South~Slavey}{SSL}\newfontlanguage{Southern~Sami}{SSM}
\newfontlanguage{Suri}{SUR}\newfontlanguage{Svan}{SVA}
\newfontlanguage{Swedish}{SVE}\newfontlanguage{Swadaya~Aramaic}{SWA}
\newfontlanguage{Swahili}{SWK}\newfontlanguage{Swazi}{SWZ}
\newfontlanguage{Sutu}{SXT}\newfontlanguage{Syriac}{SYR}
\newfontlanguage{Tabasaran}{TAB}\newfontlanguage{Tajiki}{TAJ}
\newfontlanguage{Tamil}{TAM}\newfontlanguage{Tatar}{TAT}
\newfontlanguage{TH-Cree}{TCR}\newfontlanguage{Telugu}{TEL}
\newfontlanguage{Tongan}{TGN}\newfontlanguage{Tigre}{TGR}
\newfontlanguage{Tigrinya}{TGY}\newfontlanguage{Thai}{THA}
\newfontlanguage{Tahitian}{THT}\newfontlanguage{Tibetan}{TIB}
\newfontlanguage{Turkmen}{TKM}\newfontlanguage{Temne}{TMN}
\newfontlanguage{Tswana}{TNA}\newfontlanguage{Tundra~Nenets}{TNE}
\newfontlanguage{Tonga}{TNG}\newfontlanguage{Todo}{TOD}
\newfontlanguage{Tsonga}{TSG}\newfontlanguage{Turoyo~Aramaic}{TUA}
\newfontlanguage{Tulu}{TUL}\newfontlanguage{Tuvin}{TUV}
\newfontlanguage{Twi}{TWI}\newfontlanguage{Udmurt}{UDM}
\newfontlanguage{Ukrainian}{UKR}\newfontlanguage{Urdu}{URD}
\newfontlanguage{Upper~Sorbian}{USB}\newfontlanguage{Uyghur}{UYG}
\newfontlanguage{Uzbek}{UZB}\newfontlanguage{Venda}{VEN}
\newfontlanguage{Vietnamese}{VIT}\newfontlanguage{Wa}{WA}
\newfontlanguage{Wagdi}{WAG}\newfontlanguage{West-Cree}{WCR}
\newfontlanguage{Welsh}{WEL}\newfontlanguage{Wolof}{WLF}
\newfontlanguage{Tai~Lue}{XBD}\newfontlanguage{Xhosa}{XHS}
\newfontlanguage{Yakut}{YAK}\newfontlanguage{Yoruba}{YBA}
\newfontlanguage{Y-Cree}{YCR}\newfontlanguage{Yi~Classic}{YIC}
\newfontlanguage{Yi~Modern}{YIM}\newfontlanguage{Chinese~Hong~Kong}{ZHH}
\newfontlanguage{Chinese~Phonetic}{ZHP}
\newfontlanguage{Chinese~Simplified}{ZHS}
\newfontlanguage{Chinese~Traditional}{ZHT}\newfontlanguage{Zande}{ZND}
\newfontlanguage{Zulu}{ZUL}
%    \end{macrocode}
%
% \paragraph{Turkish} Turns out that many fonts use `TUR' as their Turkish language tag rather than the specified `TRK'. So we check for both:
%    \begin{macrocode}
\keys_define:nn {fontspec}
 {
  Language / Turkish .code:n =
   {
    \fontspec_check_lang:nTF {TRK}
     {
      \int_set:Nn \l_fontspec_language_int {\l_fontspec_strnum_int}
      \tl_set:Nn \l_fontspec_lang_tl {TRK}
     }
     {
      \fontspec_check_lang:nTF {TUR}
       {
        \int_set:Nn \l_fontspec_language_int {\l_fontspec_strnum_int}
        \tl_set:Nn \l_fontspec_lang_tl {TUR}
       }
       {
        \@@_warning:nx {language-not-exist} {Turkish}
        \keys_set:nn {fontspec} {Language=Default}
       }
     }
   }
 }
%    \end{macrocode}
%
% \paragraph{Default}
%
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec}{ Language / Default }
 {
  \tl_set:Nn \l_fontspec_lang_tl {DFLT}
  \int_zero:N \l_fontspec_language_int
 }
%    \end{macrocode}
%
% \subsubsection{Raw feature string}
% This allows savvy \XeTeX-ers to input font features manually if they have
% already memorised the OpenType abbreviations and don't mind not having error checking.
%    \begin{macrocode}
\@@_keys_define_code:nnn {fontspec} {RawFeature}
 {
  \@@_update_featstr:n {#1}
 }
%    \end{macrocode}
%
%
%
% \subsection{Italic small caps} \label{sec:sishape}
% The following code for utilising italic small caps sensibly is
% inspired from Philip Lehman's \textit{The Font Installation
%   Guide}. Note that |\upshape| needs to be used \emph{twice} to get
% from italic small caps to regular upright (it always goes to small
% caps, then regular upright).
% \begin{macro}{\sishape}
% \begin{macro}{\textsi}
%     First, the commands for actually selecting italic small caps are
%     defined. I use |si| as the NFSS shape for italic small caps, but
%     I have seen |itsc| and |slsc| also used. |\sidefault| may be
%     redefined to one of these if required for compatibility.
%    \begin{macrocode}
\providecommand*{\sidefault}{si}
\DeclareRobustCommand{\sishape}
 {
  \not@math@alphabet\sishape\relax
  \fontshape\sidefault\selectfont
 }
\DeclareTextFontCommand{\textsi}{\sishape}
%    \end{macrocode}
% \end{macro} \end{macro}
% \begin{macro}{\fontspec_blend_shape:nnn}
%   This is the macro which enables the overload on the |\..shape|
%   commands. It takes three such arguments. In essence, the macro
%   selects the first argument, unless the second argument is already
%   selected, in which case it selects the third.
%    \begin{macrocode}
\cs_new:Nn \fontspec_blend_shape:nnn
 {
  \bool_if:nTF
   {
    \str_if_eq_x_p:nn {\f@shape} {#2} &&
    \cs_if_exist_p:c {\f@encoding/\f@family/\f@series/#3}
   }
   { \fontshape{#3}\selectfont }
   { \fontshape{#1}\selectfont }
 }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\itshape} \begin{macro}{\scshape} \begin{macro}{\upshape}
%       Here the original |\..shape| commands are redefined to use the
%       merge shape macro.
%    \begin{macrocode}
\DeclareRobustCommand \itshape
 {
  \not@math@alphabet\itshape\mathit
  \fontspec_blend_shape:nnn\itdefault\scdefault\sidefault
 }
\DeclareRobustCommand \slshape
 {
  \not@math@alphabet\slshape\relax
  \fontspec_blend_shape:nnn\sldefault\scdefault\sidefault
 }
\DeclareRobustCommand \scshape
 {
  \not@math@alphabet\scshape\relax
  \fontspec_blend_shape:nnn\scdefault\itdefault\sidefault
 }
\DeclareRobustCommand \upshape
 {
  \not@math@alphabet\upshape\relax
  \fontspec_blend_shape:nnn\updefault\sidefault\scdefault
 }
%    \end{macrocode}
% \end{macro} \end{macro} \end{macro}
%
% \subsection{Selecting maths fonts}
% Here, the fonts used in math mode are redefined to correspond to the
% default roman, sans serif and typewriter fonts. Unfortunately, you
% can only define maths fonts in the preamble, otherwise I'd run this
% code whenever \cs{setmainfont} and friends was run.
%
% \begin{macro}{\fontspec_setup_maths:}
% Everything here is performed \cs{AtBeginDocument} in order to
% overwrite \pkg{euler}'s attempt. This means \pkg{fontspec} must be
% loaded \emph{after} \pkg{euler}. We set up a conditional to return
% an error if this rule is violated.
%
% Since every maths setup is slightly different, we also take
% different paths for defining various math glyphs depending which
% maths font package has been loaded.
%
%    \begin{macrocode}
\@ifpackageloaded{euler}
 {
  \bool_set_true:N \g_@@_pkg_euler_loaded_bool
 }
 {
  \bool_set_false:N \g_@@_pkg_euler_loaded_bool
 }
\cs_set:Nn \fontspec_setup_maths:
 {
  \@ifpackageloaded{euler}
   {
    \bool_if:NTF \g_@@_pkg_euler_loaded_bool
     { \bool_set_true:N \g_@@_math_euler_bool }
     { \@@_error:n {euler-too-late} }
   }
   {}
  \@ifpackageloaded{lucbmath}{\bool_set_true:N \g_@@_math_lucida_bool}{}
  \@ifpackageloaded{lucidabr}{\bool_set_true:N \g_@@_math_lucida_bool}{}
  \@ifpackageloaded{lucimatx}{\bool_set_true:N \g_@@_math_lucida_bool}{}
%    \end{macrocode}
% Knuth's CM fonts fonts are all squashed together, combining letters,
% accents, text symbols and maths symbols all in the one font,
% \texttt{cmr}, plus other things in other fonts. Because we are
% changing the roman font in the document, we need to redefine all of
% the maths glyphs in \LaTeX's \texttt{operators} maths font to still
% go back to the legacy \texttt{cmr} font for all these random glyphs,
% unless a separate maths font package has been loaded instead.
%
% In every case, the maths accents are always taken from the
% \texttt{operators} font, which is generally the main text
% font. (Actually, there is a \cmd\hat\ accent in
% \texttt{EulerFractur}, but it's \emph{ugly}. So I ignore it. Sorry
% if this causes inconvenience.)
%    \begin{macrocode}
  \DeclareSymbolFont{legacymaths}{OT1}{cmr}{m}{n}
  \SetSymbolFont{legacymaths}{bold}{OT1}{cmr}{bx}{n}
  \DeclareMathAccent{\acute}   {\mathalpha}{legacymaths}{19}
  \DeclareMathAccent{\grave}   {\mathalpha}{legacymaths}{18}
  \DeclareMathAccent{\ddot}    {\mathalpha}{legacymaths}{127}
  \DeclareMathAccent{\tilde}   {\mathalpha}{legacymaths}{126}
  \DeclareMathAccent{\bar}     {\mathalpha}{legacymaths}{22}
  \DeclareMathAccent{\breve}   {\mathalpha}{legacymaths}{21}
  \DeclareMathAccent{\check}   {\mathalpha}{legacymaths}{20}
  \DeclareMathAccent{\hat}     {\mathalpha}{legacymaths}{94} % too bad, euler
  \DeclareMathAccent{\dot}     {\mathalpha}{legacymaths}{95}
  \DeclareMathAccent{\mathring}{\mathalpha}{legacymaths}{23}
%    \end{macrocode}
% \paragraph{\cmd\colon: what's going on?} Okay, so \verb":" and \cmd\colon\ in maths mode are defined in a few places, so I need to work out what does what. Respectively, we have:
% \begin{Verbatim}
% % fontmath.ltx:
% \DeclareMathSymbol{\colon}{\mathpunct}{operators}{"3A}
% \DeclareMathSymbol{:}{\mathrel}{operators}{"3A}
%
% % amsmath.sty:
% \renewcommand{\colon}{\nobreak\mskip2mu\mathpunct{}\nonscript
%  \mkern-\thinmuskip{:}\mskip6muplus1mu\relax}
%
% % euler.sty:
% \DeclareMathSymbol{:}\mathrel  {EulerFraktur}{"3A}
%
% % lucbmath.sty:
% \DeclareMathSymbol{\@tempb}{\mathpunct}{operators}{58}
% \ifx\colon\@tempb
%   \DeclareMathSymbol{\colon}{\mathpunct}{operators}{58}
% \fi
% \DeclareMathSymbol{:}{\mathrel}{operators}{58}
% \end{Verbatim}
% ($\mathrm{3A_{16}}=\mathrm{58_{10}}$) So I think, based on this summary, that it is fair to tell \pkg{fontspec} to `replace' the operators font with legacymaths for this symbol, except when \pkg{amsmath} is loaded since we want to keep its definition.
%
%
%    \begin{macrocode}
  \group_begin:
    \mathchardef\@tempa="603A \relax
    \ifx\colon\@tempa
      \DeclareMathSymbol{\colon}{\mathpunct}{legacymaths}{58}
    \fi
  \group_end:
%    \end{macrocode}
% The following symbols are only defined specifically in \pkg{euler}, so skip them
% if that package is loaded.
%    \begin{macrocode}
  \bool_if:NF \g_@@_math_euler_bool
   {
    \DeclareMathSymbol{!}{\mathclose}{legacymaths}{33}
    \DeclareMathSymbol{:}{\mathrel}  {legacymaths}{58}
    \DeclareMathSymbol{;}{\mathpunct}{legacymaths}{59}
    \DeclareMathSymbol{?}{\mathclose}{legacymaths}{63}
%    \end{macrocode}
% And these ones are defined both in \pkg{euler} and \pkg{lucbmath},
% so we only need to run this code if no extra maths package has been
% loaded.
%    \begin{macrocode}
    \bool_if:NF \g_@@_math_lucida_bool
     {
      \DeclareMathSymbol{0}{\mathalpha}{legacymaths}{`0}
      \DeclareMathSymbol{1}{\mathalpha}{legacymaths}{`1}
      \DeclareMathSymbol{2}{\mathalpha}{legacymaths}{`2}
      \DeclareMathSymbol{3}{\mathalpha}{legacymaths}{`3}
      \DeclareMathSymbol{4}{\mathalpha}{legacymaths}{`4}
      \DeclareMathSymbol{5}{\mathalpha}{legacymaths}{`5}
      \DeclareMathSymbol{6}{\mathalpha}{legacymaths}{`6}
      \DeclareMathSymbol{7}{\mathalpha}{legacymaths}{`7}
      \DeclareMathSymbol{8}{\mathalpha}{legacymaths}{`8}
      \DeclareMathSymbol{9}{\mathalpha}{legacymaths}{`9}
      \DeclareMathSymbol{\Gamma}{\mathalpha}{legacymaths}{0}
      \DeclareMathSymbol{\Delta}{\mathalpha}{legacymaths}{1}
      \DeclareMathSymbol{\Theta}{\mathalpha}{legacymaths}{2}
      \DeclareMathSymbol{\Lambda}{\mathalpha}{legacymaths}{3}
      \DeclareMathSymbol{\Xi}{\mathalpha}{legacymaths}{4}
      \DeclareMathSymbol{\Pi}{\mathalpha}{legacymaths}{5}
      \DeclareMathSymbol{\Sigma}{\mathalpha}{legacymaths}{6}
      \DeclareMathSymbol{\Upsilon}{\mathalpha}{legacymaths}{7}
      \DeclareMathSymbol{\Phi}{\mathalpha}{legacymaths}{8}
      \DeclareMathSymbol{\Psi}{\mathalpha}{legacymaths}{9}
      \DeclareMathSymbol{\Omega}{\mathalpha}{legacymaths}{10}
      \DeclareMathSymbol{+}{\mathbin}{legacymaths}{43}
      \DeclareMathSymbol{=}{\mathrel}{legacymaths}{61}
      \DeclareMathDelimiter{(}{\mathopen} {legacymaths}{40}{largesymbols}{0}
      \DeclareMathDelimiter{)}{\mathclose}{legacymaths}{41}{largesymbols}{1}
      \DeclareMathDelimiter{[}{\mathopen} {legacymaths}{91}{largesymbols}{2}
      \DeclareMathDelimiter{]}{\mathclose}{legacymaths}{93}{largesymbols}{3}
      \DeclareMathDelimiter{/}{\mathord}{legacymaths}{47}{largesymbols}{14}
      \DeclareMathSymbol{\mathdollar}{\mathord}{legacymaths}{36}
    }
  }
%    \end{macrocode}
% Finally, we change the font definitions for \cmd\mathrm\ and so
% on. These are defined using the \cmd\g_@@_mathrm_tl\ (\dots) macros,
% which default to \cmd\rmdefault\ but may be specified with the
% \cmd\setmathrm\ (\dots) commands in the preamble.
%
% Since \LaTeX\ only generally defines one level of boldness, we omit
% \cmd\mathbf\ in the \textsf{bold} maths series. It can be specified
% as per usual with \cmd\setboldmathrm, which stores the appropriate
% family name in \cmd\g_@@_bfmathrm_tl.
%    \begin{macrocode}
  \DeclareSymbolFont{operators}\g_fontspec_encoding_tl\g_@@_mathrm_tl\mddefault\updefault
  \SetSymbolFont{operators}{normal}\g_fontspec_encoding_tl\g_@@_mathrm_tl\mddefault\updefault
  \DeclareSymbolFontAlphabet\mathrm{operators}
  \SetMathAlphabet\mathit{normal}\g_fontspec_encoding_tl\g_@@_mathrm_tl\mddefault\itdefault
  \SetMathAlphabet\mathbf{normal}\g_fontspec_encoding_tl\g_@@_mathrm_tl\bfdefault\updefault
  \SetMathAlphabet\mathsf{normal}\g_fontspec_encoding_tl\g_@@_mathsf_tl\mddefault\updefault
  \SetMathAlphabet\mathtt{normal}\g_fontspec_encoding_tl\g_@@_mathtt_tl\mddefault\updefault
  \SetSymbolFont{operators}{bold}\g_fontspec_encoding_tl\g_@@_mathrm_tl\bfdefault\updefault
  \tl_if_empty:NTF \g_@@_bfmathrm_tl
   {
    \SetMathAlphabet\mathit{bold}\g_fontspec_encoding_tl\g_@@_mathrm_tl\bfdefault\itdefault
   }
   {
    \SetMathAlphabet\mathrm{bold}\g_fontspec_encoding_tl\g_@@_bfmathrm_tl\mddefault\updefault
    \SetMathAlphabet\mathbf{bold}\g_fontspec_encoding_tl\g_@@_bfmathrm_tl\bfdefault\updefault
    \SetMathAlphabet\mathit{bold}\g_fontspec_encoding_tl\g_@@_bfmathrm_tl\mddefault\itdefault
   }
  \SetMathAlphabet\mathsf{bold}\g_fontspec_encoding_tl\g_@@_mathsf_tl\bfdefault\updefault
  \SetMathAlphabet\mathtt{bold}\g_fontspec_encoding_tl\g_@@_mathtt_tl\bfdefault\updefault
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_maybe_setup_maths:}
% We're a little less sophisticated about not executing the maths setup if various other maths font packages are loaded. This list is based on the wonderful `\LaTeX Font Catalogue': \url{http://www.tug.dk/FontCatalogue/mathfonts.html}. I'm sure there are more I've missed. Do the \TeX\ Gyre fonts have maths support yet?
%
% Untested: would |\unless\ifnum\Gamma=28672\relax\bool_set_false:N \g_@@_math_bool\fi| be a better test?
% This needs more cooperation with euler and lucida, I think.
%    \begin{macrocode}
\cs_new:Nn \fontspec_maybe_setup_maths:
 {
  \@ifpackageloaded{anttor}
   {
    \ifx\define@antt@mathversions a\bool_set_false:N \g_@@_math_bool\fi
   }{}
  \@ifpackageloaded{arev}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{eulervm}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{mathdesign}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{concmath}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{cmbright}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{mathesf}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{gfsartemisia}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{gfsneohellenic}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{iwona}
   {
    \ifx\define@iwona@mathversions a\bool_set_false:N \g_@@_math_bool\fi
   }{}
  \@ifpackageloaded{kpfonts}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{kmath}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{kurier}
   {
    \ifx\define@kurier@mathversions a\bool_set_false:N \g_@@_math_bool\fi
   }{}
  \@ifpackageloaded{fouriernc}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{fourier}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{lmodern}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{mathpazo}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{mathptmx}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{MinionPro}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{unicode-math}{\bool_set_false:N \g_@@_math_bool}{}
  \@ifpackageloaded{breqn}{\bool_set_false:N \g_@@_math_bool}{}
  \bool_if:NT \g_@@_math_bool
   {
    \@@_info:n {setup-math}
    \fontspec_setup_maths:
   }
 }
\AtBeginDocument{\fontspec_maybe_setup_maths:}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Finishing up}
% Now we just want to set up loading the \texttt{.cfg} file, if it exists.
%    \begin{macrocode}
\bool_if:NT \g_@@_cfg_bool
 {
  \InputIfFileExists{fontspec.cfg}
    {}
    {\typeout{No~ fontspec.cfg~ file~ found;~ no~ configuration~ loaded.}}
 }
%    \end{macrocode}
%
% \subsection{Compatibility}
%
% \begin{macro}{\zf@enc}
% \begin{macro}{\zf@family}
% \begin{macro}{\zf@basefont}
% \begin{macro}{\zf@fontspec}
% Old interfaces.
% These are needed by, at least, the \pkg{mathspec} package.
%    \begin{macrocode}
\tl_set:Nn \zf@enc { \g_fontspec_encoding_tl }
\cs_set:Npn \zf@fontspec #1 #2
 {
  \fontspec_select:nn {#1} {#2}
  \tl_set:Nn \zf@family { \l_fontspec_family_tl }
  \tl_set:Nn \zf@basefont { \l_fontspec_font }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% The end! Thanks for coming.
%    \begin{macrocode}
\ExplSyntaxOff
%</fontspec&(xetexx|luatex)>
%    \end{macrocode}
%
% \clearpage
% \part{fontspec.lua}
%
%    \begin{macrocode}
%<*lua>
%    \end{macrocode}
% First we define some metadata.
%    \begin{macrocode}
fontspec          = fontspec or {}
local fontspec    = fontspec
fontspec.module   = {
    name          = "fontspec",
    version       = "2.3c",
    date          = "2013/05/20",
    description   = "Advanced font selection for LuaLaTeX.",
    author        = "Khaled Hosny, Philipp Gesang",
    copyright     = "Khaled Hosny, Philipp Gesang",
    license       = "LPPL"
}

local err, warn, info, log = luatexbase.provides_module(fontspec.module)

%    \end{macrocode}
% Some utility functions
%    \begin{macrocode}
fontspec.log     = log
fontspec.warning = warn
fontspec.error   = err

function fontspec.sprint (...)
    tex.sprint(luatexbase.catcodetables['latex-package'], ...)
end
%    \end{macrocode}
%
% The following lines check for existence of a certain script, language or
% feature in a given font.
%
%    \begin{macrocode}
local check_script   = luaotfload.aux.provides_script
local check_language = luaotfload.aux.provides_language
local check_feature  = luaotfload.aux.provides_feature
%    \end{macrocode}
%
% The following are the function that get called from \TeX\ end.
%
%    \begin{macrocode}
local function tempswatrue()  fontspec.sprint([[\@tempswatrue]])  end
local function tempswafalse() fontspec.sprint([[\@tempswafalse]]) end
%    \end{macrocode}
%
%    \begin{macrocode}
function fontspec.check_ot_script(fnt, script)
    if check_script(font.id(fnt), script) then
        tempswatrue()
    else
        tempswafalse()
    end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function fontspec.check_ot_lang(fnt, lang, script)
    if check_language(font.id(fnt), script, lang) then
        tempswatrue()
    else
        tempswafalse()
    end
end
%    \end{macrocode}
%
%    \begin{macrocode}
function fontspec.check_ot_feat(fnt, feat, lang, script)
    for _, f in ipairs { "+trep", "+tlig", "+anum" } do
        if feat == f then
            tempswatrue()
            return
        end
    end
    if check_feature(font.id(fnt), script, lang, feat) then
        tempswatrue()
    else
        tempswafalse()
    end
end
%    \end{macrocode}
%
%    \begin{macrocode}
local get_math_dimension = luaotfload.aux.get_math_dimension
function fontspec.mathfontdimen(fnt, str)
    local mathdimens = get_math_dimension(fnt, str)
    if mathdimens then
        fontspec.sprint(mathdimens)
        fontspec.sprint("sp")
    else
        fontspec.sprint("0pt")
    end
end
%    \end{macrocode}
%
%    \begin{macrocode}
%</lua>
%    \end{macrocode}
%
% \clearpage
% \part{fontspec-patches.sty}
%
%    \begin{macrocode}
%<*patches>
%    \end{macrocode}
%
% \subsection{Unicode footnote symbols}
% We used to load \pkg{fixltx2e} but this is not recommended; it should ideally be loaded before \cs{begindocument}, especially from TL2014 onwards.
%    \begin{macrocode}
\ExplSyntaxOn
\cs_set:Npn \@fnsymbol #1
 {
  \int_case:nnF {#1}
   {
    {0} {}
    {1} { \mode_if_math:TF *\textasteriskcentered }
    {2} { \mode_if_math:TF \dagger\textdagger }
    {3} { \mode_if_math:TF \ddagger\textdaggerdbl }
    {4} { \mode_if_math:TF \mathsection\textsection }
    {5} { \mode_if_math:TF \mathparagraph\textparagraph }
    {6} { \mode_if_math:TF \|\textbardbl }
    {7} { \mode_if_math:TF {**}{\textasteriskcentered\textasteriskcentered} }
    {8} { \mode_if_math:TF {\dagger\dagger}{\textdagger\textdagger} }
    {9} { \mode_if_math:TF {\ddagger\ddagger}{\textdaggerdbl\textdaggerdbl} }
   }
   { \@ctrerr }
 }
%    \end{macrocode}
%
% \subsection{Emph}
%
% \begin{macro}{\em}
% \begin{macro}{\emph}
% \begin{macro}{\emshape}
% \begin{macro}{\eminnershape}
% Redefinition of |{\em ...}| and |\emph{...}| to use \textsc{nfss} info to detect when the inner shape should be used.
%    \begin{macrocode}
\DeclareRobustCommand \em
 {
  \@nomath\em
  \str_if_eq_x:nnTF \f@shape \itdefault \eminnershape
  {
    \str_if_eq_x:nnTF \f@shape \sldefault \eminnershape \emshape
  }
 }
\DeclareTextFontCommand{\emph}{\em}
\cs_set_eq:NN \emshape \itshape
\cs_set_eq:NN \eminnershape \upshape
%    \end{macrocode}
% \end{macro} \end{macro}
% \end{macro} \end{macro}
%
% \subsection{\cmd\-}
%
% \begin{macro}{\-}
% This macro is courtesy of Frank Mittelbach and the \LaTeXe\ source code.
%    \begin{macrocode}
\DeclareRobustCommand{\-}
 {
  \discretionary
   {
    \char\ifnum\hyphenchar\font<\z@
           \xlx@defaulthyphenchar
         \else
           \hyphenchar\font
         \fi
   }{}{}
 }
\def\xlx@defaulthyphenchar{`\-}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Verbatims}
%
% Many thanks to Apostolos Syropoulos for discovering this problem and writing the  redefinion of \LaTeX's |verbatim| environment and \cs{verb*} command.
%
% \begin{macro}{\fontspec_visible_space:}
% Print \unichar{2434}{Open box}, which is used to visibly display a space character.
%    \begin{macrocode}
\cs_new:Nn \fontspec_visible_space:
 {
  \font_glyph_if_exist:NnTF \font {"2423}
   { \char"2423\scan_stop: }
   { \fontspec_visible_space_fallback: }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_visible_space:@fallback}
% If the current font doesn't have \unichar{2434}{Open box}, use Latin Modern Mono instead.
%    \begin{macrocode}
\cs_new:Nn \fontspec_visible_space_fallback:
 {
  {
   \usefont{\g_fontspec_encoding_tl}{lmtt}{\f@series}{\f@shape}
   \textvisiblespace
  }
 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fontspec_print_visible_spaces:}
% Helper macro to turn spaces (\verb|^^20|) active and print visible space instead.
%    \begin{macrocode}
\group_begin:
\char_set_catcode_active:n{"20}%
\cs_gset:Npn\fontspec_print_visible_spaces:{%
\char_set_catcode_active:n{"20}%
\cs_set_eq:NN^^20\fontspec_visible_space:%
}%
\group_end:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\verb}
% \begin{macro}{\verb*}
% Redefine \cmd\verb\ to use \cmd\fontspec_print_visible_spaces:.
%    \begin{macrocode}
\def\verb
 {
  \relax\ifmmode\hbox\else\leavevmode\null\fi
  \bgroup
    \verb@eol@error \let\do\@makeother \dospecials
    \verbatim@font\@noligs
    \@ifstar\@@sverb\@verb
 }
\def\@@sverb{\fontspec_print_visible_spaces:\@sverb}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% It's better to put small things into \cmd\AtBeginDocument, so here we go:
%    \begin{macrocode}
\AtBeginDocument
 {
  \fontspec_patch_verbatim:
  \fontspec_patch_moreverb:
  \fontspec_patch_fancyvrb:
  \fontspec_patch_listings:
 }
%    \end{macrocode}
%
% \begin{environment}{verbatim*}
% With the \pkg{verbatim} package.
%    \begin{macrocode}
\cs_set:Npn \fontspec_patch_verbatim:
 {
  \@ifpackageloaded{verbatim}
   {
    \cs_set:cpn {verbatim*}
     {
      \group_begin: \@verbatim \fontspec_print_visible_spaces: \verbatim@start
     }
   }
%    \end{macrocode}
% This is for vanilla \LaTeX.
%    \begin{macrocode}
   {
    \cs_set:cpn {verbatim*}
     {
      \@verbatim \fontspec_print_visible_spaces: \@sxverbatim
     }
   }
 }
%    \end{macrocode}
% \end{environment}
%
% \begin{environment}{listingcont*}
% This is for \pkg{moreverb}.
% The main |listing*| environment inherits this definition.
%    \begin{macrocode}
\cs_set:Npn \fontspec_patch_moreverb:
 {
  \@ifpackageloaded{moreverb}{
    \cs_set:cpn {listingcont*}
     {
      \cs_set:Npn \verbatim@processline
       {
        \thelisting@line \global\advance\listing@line\c_one
        \the\verbatim@line\par
       }
      \@verbatim \fontspec_print_visible_spaces: \verbatim@start
     }
  }{}
 }
%    \end{macrocode}
% \end{environment}
%
% \pkg{listings} and \pkg{fancvrb} make things nice and easy:
%    \begin{macrocode}
\cs_set:Npn \fontspec_patch_fancyvrb:
 {
  \@ifpackageloaded{fancyvrb}
   {
    \cs_set_eq:NN \FancyVerbSpace \fontspec_visible_space:
   }{}
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_set:Npn \fontspec_patch_listings:
 {
  \@ifpackageloaded{listings}
   {
    \cs_set_eq:NN \lst@visiblespace \fontspec_visible_space:
   }{}
 }
%    \end{macrocode}
%
% \subsection{\cs{oldstylenums}}
%
%
% \begin{macro}{\oldstylenums}
% \begin{macro}{\liningnums}
% This command obviously needs a redefinition.
% And we may as well provide the reverse command.
%    \begin{macrocode}
\RenewDocumentCommand \oldstylenums {m}
 {
  { \addfontfeature{Numbers=OldStyle} #1 }
 }
\NewDocumentCommand \liningnums {m}
 {
  { \addfontfeature{Numbers=Lining} #1 }
 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%    \begin{macrocode}
%</patches>
%    \end{macrocode}
%
% \clearpage
% \part{fontspec.cfg}
%
%    \begin{macrocode}
%<*cfg>
%    \end{macrocode}
%
%    \begin{macrocode}

\defaultfontfeatures
 [\rmfamily,\sffamily]
 {Ligatures=TeX}
 
\defaultfontfeatures
 [\ttfamily]
 {WordSpace={1,0,0},
  PunctuationSpace=WordSpace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% FOR BACKWARDS COMPATIBILITY WITH PREVIOUS VERSIONS %%%

% Entries here in time may be deleted.
% Please advise of any problems this causes.

\aliasfontfeatureoption{Ligatures}{Historic}{Historical}
\let\newfontinstance\newfontfamily

%    \end{macrocode}
%
%    \begin{macrocode}
%</cfg>
%    \end{macrocode}
%
% \clearpage
% \PrintChanges
%
% \clearpage
% \setcounter{IndexColumns}{2}
% \PrintIndex
%
% \Finale
%
% \iffalse
%<*example>
%
%    \begin{macrocode}
\documentclass{article}

\usepackage{fontspec}

\setmainfont{TeX Gyre Pagella}
\setsansfont{TeX Gyre Heros}[Scale=MatchLowercase]
\setmonofont{Inconsolata}[Scale=MatchLowercase]

\begin{document}
\pagestyle{empty}

\section*{The basics of the \textsf{fontspec} package}

The \textsf{fontspec} package enables automatic font selection
for \LaTeX{} documents typeset with Xe\TeX{} or Lua\TeX.
The basic command is

{\centering \verb|\fontspec{font display name}[font features]|.\par}

The default, sans serif, and typewriter fonts may be set with the
commands \verb|\setmainfont|, \verb|\setsansfont| and \verb|\setmonofont|,
respectively, as shown in the preamble. They take the
same syntax as the \verb|\fontspec| package. All expected font
shapes are available:

\begin{center}
  {\itshape Italics and \scshape small caps\dots}\\
  {\sffamily\bfseries Bold sans serif and \itshape bold italic sans serif\dots}
\end{center}

Text fonts in maths mode are also changed (e.g., notice the cosine function in
`$\cos(n\pi)=\pm 1$') but only if the roman and sans serif fonts are set in
the preamble; \verb|\setmainfont| will not affect these maths mode fonts when
called mid-document.
Maths symbols themselves are not affected.

Notice the font features used to load the default fonts in the preamble.
\verb|Ligatures=TeX| is automatically enabled for the roman and sans font,
allowing regular \TeX{} ligatures like \verb|``---''| for ``---''.
\verb|Scale=MatchLowercase| automatically scales the fonts to
the same x-height.

Please see the complete \textsf{fontspec} documentation for further
information.

\end{document}
%    \end{macrocode}
%
%</example>
%
%<*doc-style>
%    \begin{macrocode}
\ProvidesPackage{fontspec-style}

\usepackage{booktabs,calc,caption,color,enumitem,fancyvrb,hologo,graphicx,ifthen,url,varioref,varwidth,microtype,tocloft}

% ToC formatting:
\setlength\cftsubsecnumwidth{1.4\cftsubsecnumwidth}
\def\@cfttocstart{\small\begin{multicols}{2}}
\def\@cfttocfinish{\end{multicols}}

\fvset{gobble=2}

\captionsetup[table]{position=above}
\captionsetup[figure]{position=above}

\newcommand\XeTeX{\hologo{XeTeX}}
\newcommand\XeLaTeX{\hologo{XeLaTeX}}
\newcommand\LuaTeX{\hologo{LuaTeX}}
\newcommand\LuaLaTeX{\hologo{LuaLaTeX}}
\usepackage{tgpagella,eulervm}
\usepackage{inconsolata}
\usepackage[
  bookmarks=true,
  colorlinks=true,
  linkcolor=niceblue,
  urlcolor=niceblue,
  citecolor=niceblue,
  pdftitle={The fontspec package},
  pdfsubject={Advanced font selection for XeLaTeX/LuaLaTeX},
  pdfauthor={Will Robertson},
  pdfkeywords={xetex, xelatex, luatex, lualatex, unicode, opentype, aat}
  ]{hyperref}

%% ToC
\def\@dotsep{1000}
\setcounter{tocdepth}{2}
\setlength\columnseprule{0.4pt}
\renewcommand\tableofcontents{\relax
  \begin{multicols}{2}[\section*{\contentsname}]\relax
    \@starttoc{toc}\relax
  \end{multicols}}

%% Index
\setcounter{IndexColumns}{2}
\renewenvironment{theglossary}
  {\small\list{}{}
     \item\relax
     \glossary@prologue\GlossaryParms
     \let\item\@idxitem \ignorespaces
     \def\pfill{\hspace*{\fill}}}
  {\endlist}

%% varioref definitions:
\labelformat{table}{Table~#1}
\labelformat{section}{Section~#1}
\labelformat{subsection}{Section~#1}

\definecolor{niceblue}{rgb}{0.1,0.2,0.8}

\newsavebox\X
\newsavebox\Y

\newcounter{example}

\newcommand\exref[1]{Example~\ref{ex:#1}}
\newcommand\Exref[1]{Example~\ref{ex:#1}}

\newenvironment{Xexample}[3][]
  {\VerbatimEnvironment\begin{Fexample}[#1]{#2}{#3}{X}}
  {\end{Fexample}}

\newenvironment{Lexample}[3][]
  {\VerbatimEnvironment\begin{Fexample}[#1]{#2}{#3}{L}}
  {\end{Fexample}}



\newenvironment{Fexample}[4][]
  {%
    \def\options{#1}%
    \def\filename{#2}%
    \def\captiontext{#3}%
    \def\prefix{#4}
    \refstepcounter{example}%
    \label{ex:\filename}%
    \IfFileExists{doc-files/\theexample-\prefix-\filename.tex}{}{%
      \immediate\write18{cd doc-files && rm -f \theexample-* ;}%
    }%
    \VerbatimEnvironment
    \begin{VerbatimOut}{doc-files/\theexample-\prefix-\filename.tex}}
% text in the environment
  {\end{VerbatimOut}
    \begin{figure}
      \setlength\parindent{0pt}%
      \edef\@tempa{[gobble=0,fontsize=\noexpand\small,\options]}%
      \savebox\X{%
                  \expandafter\BVerbatimInput
                  \@tempa{doc-files/\theexample-\prefix-\filename.tex}%
                }%
      \IfFileExists{doc-files/\theexample-\prefix-\filename.pdf}{}
         {%
           \edef\1{%
             cd doc-files; \csname prog@\prefix\endcsname
             "%
             \unexpanded{%
               \documentclass{article}%
               \usepackage{booktabs,ifthen,graphicx,xcolor,varwidth}
               \usepackage[active,tightpage]{preview}%
               \usepackage{fontspec}%
               \defaultfontfeatures{Ligatures=TeX} \begin{document}\begin{preview}\begin{varwidth}{0.7\linewidth}\input} \theexample-\prefix-\filename.tex
             \unexpanded{\end{varwidth}\end{preview}\end{document}}
             "
           }%
           \immediate\write18{
              mkdir -p doc-files/;
              cp -a fontspec.dtx doc-files/;
              cd doc-files;
              tex fontspec.dtx > /dev/null ;
           }
           \immediate\write18{\unexpanded\expandafter{\1}}%
         }%
      \savebox\Y{%
      \IfFileExists{doc-files/\theexample-\prefix-\filename.pdf}
          {\includegraphics{doc-files/\theexample-\prefix-\filename.pdf}}
          {Graphic not generated.}%
      }
      % TYPESETTING
      \rule[0.5\baselineskip]{\columnwidth}{1pt}%
      \vspace{-1.2ex}%
      \def\@tempa{\small\textsf{Example~\theexample:~}}%
      \settowidth\@tempdima{\@tempa\captiontext}%
      \par
      \ifdim\@tempdima>\linewidth
        \settowidth\@tempdima{\@tempa}%
        \@tempa\parbox[t]{\linewidth-\@tempdima}{\small\captiontext}%
        \vspace{0.4\baselineskip}%
      \else
        \parbox{\linewidth}{\centering\@tempa~\captiontext}%
      \fi
      \par\rule[0.4\baselineskip]{\columnwidth}{0.4pt}\par
      \ifdim\dimexpr\wd\X+\wd\Y>\linewidth\relax
        \null\hfill\makebox[0pt][r]{\usebox\Y}\usebox\X
      \else
        \hfill\usebox\Y\hfill\usebox\X
      \fi
      \par\rule[0.5\baselineskip]{\columnwidth}{1pt}
    \end{figure}
}

\def\prog@X{xelatex
               -jobname=\theexample-X-\filename\space}

\def\prog@L{lualatex
               -jobname=\theexample-L-\filename\space}

%%%%%%%%%%%%%%%%%%%%%%

\newcommand*\setexsize[1]{\let\examplesize#1}
\newcommand*\setverbwidth[1]{\def\auxwidth{#1}}

%% Various labelling commands:
\newcommand*\name[1]{{#1}}
\newcommand*\pkg[1]{\textsf{#1}}
\newcommand*\opt[1]{\texttt{#1}}
\newcommand*\feat[1]{\texttt{#1}}

\let\latin\textit
\def\eg{\latin{e.g.}}
\def\ie{\latin{i.e.}}
\def\Eg{\latin{E.g.}}
\def\Ie{\latin{I.e.}}
\def\etc{\@ifnextchar.{\latin{etc}}{\latin{etc.}\@}}

\newcommand\note[1]{\unskip\footnote{#1}}

\def\MacOSX{Mac~OS~X}
\def\AAT{\textsc{aat}}
\def\ATSUI{\textsc{atsui}}

%% (La)TeX font-related declarations:
\linespread{1.05}      % Pagella needs more space between lines
\frenchspacing         % Remove ugly extra space after punctuation

\makeatletter
\newcounter{argument}
\g@addto@macro\endmacro{\setcounter{argument}{0}}
\newcommand*\darg[1]{%
  \stepcounter{argument}%
  \noindent{\ttfamily\char`\#\theargument~:~}#1\par}
\newcommand*\doarg[1]{%
  \stepcounter{argument}%
  \noindent{\ttfamily\makebox[0pt][r]{[}\char`\#\theargument]:~}#1\par}
\makeatother

\newcommand\unichar[2]{\textsc{\MakeLowercase{u+#1: #2}}}

\newcommand\cmdbox[1]{%
  \smallskip\par\noindent
  \fbox{\begin{varwidth}{\linewidth}
    #1%
  \end{varwidth}}%
  \smallskip
}
\def\CMD#1{\texttt{\null#1\unskip}}

\usepackage{xparse}
\NewDocumentCommand \otf {somm} {%
  \IfBooleanTF #1
  {%
    \gdef\NOTE{\par\smallskip {$\ast$ \footnotesize This feature is activated by default.}}%
    \IfNoValueTF {#2} {\gdef\offname{No#3}}{\gdef\offname{#2}}%
    \featname&#3&$\ast$&\texttt{#4}\\
    \featname&\offname&&\texttt{#4}~~{\footnotesize(\textit{deactivate})}\\
  }
  {\featname&#3&&\texttt{#4}\\}%
}
\newenvironment{features}[1]{%
  \def\NOTE{}
  \def\thisfeatname{#1}%
  \def\featname{\thisfeatname~~\texttt=~~\null\gdef\featname{}}%
  \begin{table}
    \caption{Options for the OpenType font feature `\thisfeatname'.}
    \edef\@tempa{\noexpand\label{feat:\thisfeatname}}\@tempa
    \centering
    \begin{tabular}{@{}l@{}l@{\hspace{0.5\tabcolsep}}l@{\hspace{0.5\tabcolsep}}l@{}}
    \toprule
    Feature & Option && Tag \\
    \midrule
}{
    \bottomrule
    \end{tabular}
    \NOTE
  \end{table}
}

%%%%%%%%%%%

\def \MakePrivateLetters {%
  \catcode `\@ = 11
  \catcode `\_ = 11
  \catcode `\: = 11
}

%% for LaTeX3 csnames
\catcode `\_= 11

\renewcommand\partname{Part}

%    \end{macrocode}
%</doc-style>
% \fi
\endinput
